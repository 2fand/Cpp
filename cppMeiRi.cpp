#include <iostream>// <-- 必备
#include <string>
#include <cstring>
#include <Windows.h>
#include <cstdlib>
#include <ctime>
#include <climits>
#include <deque>
#include <stack>
#include <set>
#include <numeric>
#include <vector>
#include <algorithm>
#include <list>
using namespace std;// <-- 必备
#define PANADD(A,B) ((A) < (B) ? 1 : -1) // <------ “C++两点成一线”中的宏
#define NAME(A) #A // <------ “#”中的宏
#define CAT(A,B) A##B // <------ “##”中的宏
#define NU 45 // <------ “##”中的宏
#define LL // <------ “##”中的宏
#define E ; // <------ “##”中的宏
#define OF using namespace std; // <------ “##”中的宏
/*
int main() {
	cout << endl;cout << "a";
	return 0;
}
*///“cout”^
/*
int main() {
	int i = 0;
	cin >> i;
	cout << i << endl;
	return 0;
}
*///“cin”^
/*
int main() {
	cout << __DATE__ << endl;
	return 0;
}
*///“__DATE__”^
/*
int main() {
	string str = "Hello, world!";
	cout << str << endl;
	return 0;
}
*///“string”^
/*
int main() {
	int i = 0;
	int ia = 0;
	int ib = 0;
	cin >> i >> ia >> ib;
	if (i >= ia && i >= ib) {
		cout << i << endl;
	}
	else if (ia >= i && ia >= ib) {
		cout << ia << endl;
	}
	else {
		cout << ib << endl;
	}
	return 0;
}
*///“求三数最大值”(考虑相等的情况)^
/*
int main() {
	int i = 0;
	cin >> i;
	switch (i) {
	case 0:
		cout << "Hello, world!" << endl;
		break;
	case 1:
		cout << "Byebye, world!" << endl;
		break;
	default:
		cout << "NiHao, world!" << endl;
		break;
	}
	return 0;
}
*///“switch语句”^
/*
int main() {
	int i = 0;
	cin >> i;
	cout << (i << 1) << endl;
	cout << (i >> 1) << endl;
	return 0;
}
*///“<<和>>”^
/*
int main() {
	int i = 0;
	int ia = 0;
	cin >> i >> ia;
	cout << (i ^ ia) << endl;
	return 0;
}
*///“按位异或^”^
/*
int main() {
	cout << "\033[36mBLUE" << endl;
	return 0;
}
*///“BLUE”^
/*
int main() {
	cout << "\033[33;4mYELLOW" << endl;
	return 0;
}
*///“YELLOW”^
/*
int main() {
	cout << "\033[32;1;7mGREEN" << endl;
	return 0;
}
*///“GREEN”^
/*
int main() {
	int i = 0;
	cin >> i;
	i > 0 && cout << "+";
	cout << i << endl;
	return 0;
}
*///自动添加正负号^
/*
int main() {
	cout << 1145E4;
	return 0;
}
*///“1145E4”^
/*
int main() {
	cout << 6E8F;
	return 0;
}
*///“6E8F”^
/*
int main() {
	int arr[10] = { 0,1,2,3,4,5,7,6,8,9 };
	int i = 0;
	for (; i < 10; i++) {
		cout << arr[i] << " ";
	}
	cout << endl;
	return 0;
}
*///“数组”^
/*
int main() {
	string str = "Hello, ";
	cout << str;
	str = "world!\n";
	cout << str;
	return 0;
}
*///“string字符串的特殊之处”^
/*
int main() {
	int i = 0;
	int* ip = &i;
	*ip = 114514;
	cout << "ip = 0x" << ip << endl;
	cout << "*ip = " << *ip << endl;
	cout << "i = " << i << endl;
	return 0;
}
*///“指针”^
/*
struct Box {
	int ix;
	int iy;
};
int main() {
	Box b = { 3,7 };
	Box ba = { 4,5 };
	cout << "箱子b的xy坐标：(" << b.ix << ", " << b.iy << ")" << endl << "箱子ba的xy坐标：(" << ba.ix << ", " << ba.iy << ")" << endl;
	return 0;
}
*///“结构体”^
/*
union test {
	int i;
	char ch;
};
int main() {
	test t = {114514};
	cout << t.i << " " << t.ch << endl;
    return 0;
}
*///“联合”^
/*
enum RGB {
	R,
	G,
	B,
};
int main() {
	cout << "R = " << R << endl;
	cout << "G = " << G << endl;
	cout << "B = " << B << endl;
	return 0;
}
*///“枚举”^
/*
int main() {
	int* ip = new int(10);
	cout << "*ip = " << *ip << endl;
	cout << "*ip = " << *ip << endl;
	cout << "*ip = " << *ip << endl;
	delete ip;
	//cout << "*ip = " << *ip << endl; <-- ERROR
	return 0;
}
*///“new和delete”^
/*
int main() {
	int i = 114514;
	int& ia = i;
	cout << "i = " << i << "    ia = " << ia << endl;
	ia = 666;
	cout << "i = " << i << "    ia = " << ia << endl;
	i = 1314520;
	cout << "i = " << i << "    ia = " << ia << endl;
	return 0;
}
*///“引用&”^
/*
void printmaze(char strmaze[5][5][5]) {
	cout << "-----@" << endl;
	int i = 0;
	int ia = 0;
	int ib = 0;
	for (; i < 5; i++) {
		for (ia = 0; ia < 5; ia++) {
			for (ib = 0; ib < 5; ib++) {
				cout << "\033[" << ('G' == strmaze[i][ia][ib] ? "32;1" : "0") << "m" << strmaze[i][ia][ib] << "\033[0m";
			}
			cout << "|" << endl;
		}
		cout << "-----@" << endl;
	}
}
int main() {
	char strmaze[5][5][5] = {
		'P','*',' ','*','*',
		'*',' ',' ',' ','*',
		' ',' ','*',' ',' ',
		' ','*','*','*',' ',
		' ',' ','*',' ',' ',

		' ',' ','*',' ',' ',
		' ','*',' ','*',' ',
		'*','*','*','*','*',
		' ',' ','*',' ',' ',
		' ',' ','*',' ',' ',

		'*',' ',' ','*',' ',
		'*',' ','*',' ',' ',
		' ','*',' ','*','*',
		' ',' ','*',' ',' ',
		' ',' ','*',' ',' ',

		'*','*',' ',' ',' ',
		' ',' ','*','*',' ',
		' ',' ','*',' ','*',
		' ',' ','*',' ',' ',
		' ',' ','*','*',' ',

		'*','*',' ',' ',' ',
		'*',' ',' ',' ',' ',
		' ','*','*',' ','*',
		' ',' ','*','*','*',
		' ','*',' ',' ','G',
	};
	char* cp = &strmaze[0][0][0];
	char ch = 0;
	cout << "欢迎你来玩这个3D迷宫，在这个迷宫中，“P”是你，“*”是墙，空格是你可以走的地方，而\033[32;1m“G”\033[0m是\033[32;1m终点\033[0m，走到这就能让你胜利了，并且，按“w”能使你往上移，按“a”能使你往左移，按“s”能使你往下移，按“d”能使你往右移，按“q”能使你上一层，按“e”能使你下一层。这就是这迷宫的规则，你听明白了吗?" << endl << endl;
	system("pause");
	system("cls");
	while ('G' == strmaze[4][4][4]) {
		int ix = (cp - &strmaze[0][0][0]) / 25;
		int iy = (cp - &strmaze[0][0][0]) / 5 % 5;
		int iz = (cp - &strmaze[0][0][0]) % 5;
		printmaze(strmaze);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'w':
			iy && '*' != *(cp - 5) && (cp -= 5);
			break;
		case 'a':
			iz && '*' != *(cp - 1) && (cp--);
			break;
		case 's':
			4 != iy && '*' != *(cp + 5) && (cp += 5);
			break;
		case 'd':
			4 != iz && '*' != *(cp + 1) && (cp++);
			break;
		case 'q':
			ix && '*' != *(cp - 25) && (cp -= 25);
			break;
		case 'e':
			4 != ix && '*' != *(cp + 25) && (cp += 25);
			break;
		default:
			break;
		}
		*cp = 'P';
		system("cls");
	}
	system("color 0A");
	cout << "恭喜你，你赢了" << endl;
	return 0;
}
*///“C++3D迷宫”(选自我的CSDN博客)^
/*
void fun() {
	cout << -1 << endl;
}
void fun(int i) {
	cout << 1 << " " << i << endl;
}
int main() {
	fun();
	fun(7);
	fun(114514);
	return 0;
}
*///“函数重载”^
/*
enum RBYG {
	R = 1,
	B = 2,
	Y = 4,
	G = 7,
};
struct heal {
	int ix;
	int iy;
	enum RBYG rbyg;
	int HOrD;
};
void printmaze(const char strmaze[11][11], const int ihea, heal healarr[54]) {
	int i = 0;
	int ia = 0;
	int ib = 0;
	string str = "0";
	for (; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			for (ib = 0; ib < 54; ib++) {
				if (healarr[ib].ix == i && healarr[ib].iy == ia) {
					if (2 == healarr[ib].HOrD || -2 == healarr[ib].HOrD) {
						str = "35;1";
					}
					else {
						switch (healarr[ib].rbyg) {
						case R:
							str = "31;1";
							break;
						case B:
							str = "36";
							break;
						case Y:
							str = "33";
							break;
						case G:
							str = "32;1";
							break;
						default:
							break;
						}
					}
					break;
				}
			}
			cout << "\033[" << ('P' != strmaze[i][ia] ? 'G' == strmaze[i][ia] ? "32;1" : str : "0") << "m" << strmaze[i][ia] << "\033[0m";
			str = "0";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl << "\033[3" << (ihea > 6 ? "2;1" : ihea > 3 ? "3" : "1") << "m你现在的生命值为：" << ihea << endl << "\033[0m";
}
int main() {
	char str[9] = "color 0";
	char strmaze[11][11] = {
		'P','X','O',' ',' ',' ',' ','X','X','O','O',
		'*','*','*','*',' ','X',' ',' ','X','O','O',
		'O','X','X','X',' ',' ','X',' ',' ','*','*',
		'*','*','*','*','O',' ','*','*','X','O','O',
		' ','X',' ','*','*','*','*',' ',' ','X','O',
		' ','X','X','*','X','O','*',' ',' ',' ','X',
		'X','*',' ','O',' ','X','*',' ',' ','X','O',
		' ','*','X',' ','X',' ',' ','*',' ',' ','X',
		'O','*','X','*',' ',' ',' ','*',' ','X','X',
		'X','O','X','*','X',' ',' ',' ','X','X','X',
		'O','X','O','*','O','X',' ','X','X','X','G',
	};
	char strmazer[11][11] = { 0 };
	char* cp = &strmaze[0][0];
	char ch = 0;
	int ihea = 10;
	int i = 0;
	heal healarr[54] = { {0,1,R,-1},{0,2,R,1},{0,7,R,-1},{0,8,B,-1},{0,9,R,1},{0,10,R,1},{1,5,G,-1},{1,8,Y,-1},{1,9,R,1},{1,10,B,1},{2,0,G,1},{2,1,R,-1},{2,2,R,-1},{2,3,R,-1},{2,6,B,-1},{3,4,Y,1},{3,8,Y,-1},{3,9,R,1},{3,10,R,1},{4,1,B,-1},{4,9,B,-1},{4,10,Y,1},{5,1,R,-1},{5,2,R,-1},{5,4,R,1},{5,5,R,-1},{5,10,B,-1},{6,0,Y,-1},{6,3,G,1},{6,5,Y,-1},{6,9,Y,-1},{6,10,Y,2},{7,2,R,-1},{7,4,G,-1},{7,10,B,-1},{8,0,Y,1},{8,2,B,-1},{8,9,R,-1},{8,10,G,-1},{9,0,R,-1},{9,1,G,1},{9,2,Y,-1},{9,4,B,1},{9,8,R,-1},{9,9,G,-2},{9,10,G,-2},{10,0,Y,1},{10,1,B,-1},{10,2,G,1},{10,4,B,1},{10,5,R,-1},{10,7,B,-1},{10,8,G,-1},{10,9,G,-2} };
	heal healarrR[54] = { 0 };
	memcpy(healarrR, healarr, sizeof healarr);
	memcpy(strmazer, strmaze, sizeof strmaze);
	cout << "欢迎你来玩这个\033[31m掉血迷宫\033[0m，在这个迷宫中，“P”是你，“*”是墙，空格是你可以走的地方，而\033[32;1m“G”\033[0m是\033[32;1m终点\033[0m，走到这能让你\033[32;1m胜利\033[0m，并且，按“w”使你上移，按“a”使你左移，按“s”使你下移，按“d”使你右移，按“r”重置这个迷宫，\033[31;1m“X”\033[0m是\033[31;1m陷阱\033[0m，你如果踩了他，就会根据它的\033[31;1m颜\033[0;36m色\033[31m扣掉相应的血\033[0m，其中，\033[31;1m红色扣1血\033[0m，\033[36m蓝色扣2血\033[0m，\033[33m黄色扣4血\033[0m，\033[32;1m绿色扣7血\033[0m，而\033[35;1m紫色扣14血\033[0m，\033[4m并且会\033[31m永远出现在这个迷宫中\033[0m，而\033[32;1m“O”\033[0m是\033[32;1m血瓶\033[0m。到这就会使你用\033[32;1m血瓶加血\033[0m，\033[4m但\033[32;1;4m血瓶\033[0;4m用完之后就不能再使用了\033[0m，其中，\033[31;1m红色加1血\033[0m，\033[36m蓝色加2血\033[0m，\033[33m黄色加4血\033[0m，\033[32;1m绿色加7血\033[0m，\033[35;1m紫色加14血\033[0m。这就是这迷宫的规则，你听明白了吗?" << endl << endl;
	system("pause");
	system("cls");
	while ('G' == strmaze[10][10] && ihea >= 1) {
		int ix = (cp - &strmaze[0][0]) / 11;
		int iy = (cp - &strmaze[0][0]) % 11;
		for (i = 0; i < 54; i++) {
			healarr[i].HOrD < 0 && ('P' == strmaze[healarr[i].ix][healarr[i].iy] && (ihea += healarr[i].rbyg * healarr[i].HOrD), ' ' == strmaze[healarr[i].ix][healarr[i].iy] && (strmaze[healarr[i].ix][healarr[i].iy] = 'X'));
			healarr[i].HOrD > 0 && ('P' == strmaze[healarr[i].ix][healarr[i].iy] && (ihea += healarr[i].rbyg * healarr[i].HOrD), 'O' != strmaze[healarr[i].ix][healarr[i].iy] && (healarr[i].HOrD = 0));
		}
		printmaze(strmaze, ihea, healarr);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'w':
			ix && '*' != *(cp - 11) && (cp -= 11);
			break;
		case 'a':
			iy && '*' != *(cp - 1) && (cp--);
			break;
		case 's':
			10 != ix && '*' != *(cp + 11) && (cp += 11);
			break;
		case 'd':
			10 != iy && '*' != *(cp + 1) && (cp++);
			break;
		case 'r':
			memcpy(healarr, healarrR, sizeof healarr);
			memcpy(strmaze, strmazer, sizeof strmaze);
			ihea = 10;
			cp = &strmaze[0][0];
			break; 
		default:
			break;
		}
		*cp = 'P';
		system("cls");
	}
	ihea >= 1 && (str[7] = 'A'), ihea >= 1 || (str[7] = '4');
	system(str);
	cout << (ihea >= 1 ? "恭喜你，你赢了" : "很遗憾，你输了") << endl;
	return 0;
}
*///“C++掉血迷宫”(选自我的CSDN博客)^
/*
class One {
public:
	int i;
	int fun() {
		return 1;
	}
};
int main() {
	One o = { 0 };
	One oa = { 2 };
	cout << o.i << " " << oa.i << endl;
	cout << o.fun() << " " << oa.fun() << endl;
	return 0;
}
*///“类(对象)的使用”^
/*
class Test {
public:
	Test() {
		cout << "Hello, world!" << endl;
	}
};
int main() {
	Test t;
	return 0;
}
*///“构造函数”^
/*
class Test {
public:
	~Test() {
		cout << "Hello, world!" << endl;
	}
};
int main() {
	Test t;
	return 0;
}
*///“析构函数”^
/*
int main() {
	auto i = 123;
	cout << i << endl;
	return 0;
}
*///“auto”^
/*
int main() {
	static int i = 123;
	cout << i << endl;
	return 0;
}
*///“static”^
/*
int main() {
	register int i = 123;
	cout << i << endl;
	return 0;
}
*///“register”^
/*
class Test {
public:
	int i;
private:
	int ia;
};
int main() {
	Test t;
	t.i = 123;
	//t.ia = 123;//ERR
	cout << t.i << endl;
	//cout << t.ia << endl;//ERR
	return 0;
}
*///“private”^
/*
void printmaze(const char strmaze[11][11]) {
	int i = 0;
	int ia = 0;
	for (; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('0' == strmaze[i][ia] ? "33" : 'G' == strmaze[i][ia] ? "32;1" : "0") << "m" << strmaze[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
int main() {
	char strmaze[11][11] = {
		'P','0','*','0','*','0','0',' ','0',' ',' ',
		' ',' ','*',' ','*',' ',' ','0',' ',' ',' ',
		'*','*','*',' ','*',' ','*',' ','*',' ',' ',
		'0',' ','*',' ','*','0','*',' ',' ',' ',' ',
		' ',' ','*',' ',' ',' ','0','*','*','*',' ',
		' ','0','*',' ','0','0',' ','*',' ','*','*',
		' ',' ','*','*',' ',' ','0','*','*','*','0',
		' ',' ','*','0','*',' ',' ','*',' ',' ',' ',
		'0',' ','*',' ','*',' ','*',' ',' ','*','0',
		' ',' ','*',' ','*','*','*','0',' ','*',' ',
		' ',' ','*',' ',' ','0',' ',' ',' ','*','G',
	};
	char* cp = &strmaze[0][0];
	char ch = 0;
	int i = 0;
	bool bpw = 0;
	int doorarr[36] = {0,1,3,0,5,1,0,8,8,0,0,3,3,5,4,6,1,7,0,5,0,6,6,6,5,5,9,7,6,10,8,10,5,4,7,3};
	cout << "欢迎你来玩这个\033[33m门\033[0m迷宫，在这个迷宫中，“P”是你，“*”是墙，你不能走到这，空格是你可以走的地方，“w”使你上移，“a”使你左移，“s”使你下移，“d”使你右移，而\033[32;1m“G”\033[0m是\033[32;1m终点\033[0m，走到这能让你\033[32;1m胜利\033[0m，并且，\033[33m“0”\033[0m是\033[33m门\033[0m，按“\033[33mz\033[0m”键进入就可以走到\033[33m另外一扇门\033[0m的前面。这就是这迷宫的规则，你听明白了吗?" << endl << endl;
	system("pause");
	system("cls");
	while ('G' == strmaze[10][10]) {
		int ix = (cp - &strmaze[0][0]) / 11;
		int iy = (cp - &strmaze[0][0]) % 11;
		printmaze(strmaze);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'w':
			ix && '*' != *(cp - 11) && '0' != *(cp - 11) && (cp -= 11);
			bpw = 1;
			break;
		case 'a':
			iy && '*' != *(cp - 1) && '0' != *(cp - 1) && (cp--);
			bpw = 0;
			break;
		case 's':
			10 != ix && '*' != *(cp + 11) && '0' != *(cp + 11) && (cp += 11);
			bpw = 0;
			break;
		case 'd':
			10 != iy && '*' != *(cp + 1) && '0' != *(cp + 1) && (cp++);
			bpw = 0;
			break;
		case 'z':
			if (bpw) {
				for (i = 0; i < 36; i += 2) {
					if (ix - 1 == doorarr[i] && iy == doorarr[i + 1]) {
						if (i / 2 % 2) {
							cp = &strmaze[doorarr[i - 2] + 1][doorarr[i - 1]];
						}
						else {
							cp = &strmaze[doorarr[i + 2] + 1][doorarr[i + 3]];
						}
					}
				}
			}
			break;
		default:
			break;
		}
		*cp = 'P';
		system("cls");
	}
	system("color 0A");
	cout << "恭喜你，你赢了" << endl;
	return 0;
}
*///“C++门迷宫”(选自我的CSDN博客)^
/*
class Test {
public:
	int i;
protected:
	int ia;
};
int main() {
	Test t;
	t.i = 123;
	//t.ia = 123;//ERR
	cout << t.i << endl;
	//cout << t.ia << endl;//ERR
	return 0;
}
*///“protected”^
/*
void printmap(const char strmap[11][11]) {
	int i = 0;
	int ia = 0;
	for (; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('@' == strmap[i][ia] ? "33" : '+' == strmap[i][ia] || '-' == strmap[i][ia] || '|' == strmap[i][ia] ? "33;1" : "0") << "m" << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------*" << endl;
}
int main() {
	char strmap[11][11] = {0};
	int dotarr[4] = { -1, -1, -1, -1 };
	int i = 1;
	memset(strmap, ' ', sizeof strmap);
	for (; i < 3; i++) {
		printmap(strmap);
		cout << "请输入第" << i << "个点的xy坐标(x y)(0<=x<=10, 0<=y<=10)" << (2 == i ? "\033[4m(不可重叠)\033[0m" : "") << " -> ";
		cin >> dotarr[(i - 1) * 2] >> dotarr[(i - 1) * 2 + 1];
		while (dotarr[(i - 1) * 2] < 0 || dotarr[(i - 1) * 2] > 10 || dotarr[(i - 1) * 2 + 1] < 0 || dotarr[(i - 1) * 2 + 1] > 10 || dotarr[0] == dotarr[2] && dotarr[1] == dotarr[3]) {
			cout << "\033[31;1m输入错误\033[0m，请重新输入(0<=x<=10, 0<=y<=10) -> ";
			cin >> dotarr[(i - 1) * 2] >> dotarr[(i - 1) * 2 + 1];
		}
		strmap[dotarr[(i - 1) * 2]][dotarr[(i - 1) * 2 + 1]] = '@';
		system("cls");
	}
	for (char* cp = &strmap[dotarr[0]][dotarr[1]]; !(dotarr[0] == dotarr[2] && dotarr[1] == dotarr[3]); Sleep(100)) {
		system("cls");
		printmap(strmap);
		if (dotarr[1] != dotarr[3]) {
			(cp += PANADD(dotarr[1], dotarr[3]));
			(dotarr[1] += PANADD(dotarr[1], dotarr[3])) == dotarr[3] && (*cp = '+'), dotarr[1] == dotarr[3] || (*cp = '-');
			continue;
		}
		dotarr[0] != dotarr[2] && (cp += 11 * PANADD(dotarr[0], dotarr[2]), (*cp = '|'), (dotarr[0] += PANADD(dotarr[0], dotarr[2])));
	}
	return 0;
}
*///“C++两点成一线”(选自我的CSDN博客)^
/*
int main() {
	int i = 0;
	int ia = 56;
	string str = "48+989+";
	cout << NAME(i) << " = " << i << endl;
	cout << NAME(ia) << " = " << ia << endl;
	cout << NAME(str) << " = " << str << endl;
	return 0;
}
*///“#”^
/*
int main() {
	cout << __FILE__ << endl;
	return 0;
}
*///“__FILE__”^
/*
int main() {
	cout << __LINE__ << endl;
	return 0;
}
*///“__LINE__”^
/*
int main() {
	cout << __FUNCTION__ << endl;
	return 0;
}
*///“__FUNCTION__”^
/*
void fun(int i = 10){
	cout << i << endl;
}
int main() {
	fun();
	fun(114154);
	return 0;
}
*///“函数的默认参数”^
/*
enum ABC {
	en,
	dl
};
int main() {
	cout << CAT(114, 514) << endl;
	cout << CAT(en, dl);
	cout << CAT(NU, LL) << " " << CAT(E, OF) << endl;
	return 0;
}
*///“##”^
/*
void fun(int) {
	//cout << int << endl;//ERR
	cout << "!@#$%^&*()" << endl;
}
int main() {
	//fun();//ERR
	fun(-78904367);
	fun(')');
	return 0;
}
*///“函数的占位参数”^
/*
void fun(int = 123) {
	//cout << int << endl;//ERR
	cout << "!@#$%asdfghjkl^&*()" << endl;
}
int main() {
	fun();//OK
	fun(-78904367);
	fun(')');
	return 0;
}
*///“函数的默认占位参数”^
/*
class m_int {
public:
	m_int(int inum) {
		i = inum;
	}
	int operator+(m_int mi){
		return i + mi.i;
	}
	int i;
};
int main() {
	m_int mi = 10;
	m_int mia = 666;
	cout << mi + mia << endl;
	return 0;
}
*///“重载加号运算符”^
/*
class m_int {
public:
	m_int(int inum) {
		i = inum;
	}
	int operator-(m_int mi){
		return i - mi.i;
	}
	int i;
};
int main() {
	m_int mi = 10;
	m_int mia = 666;
	cout << mi - mia << endl;
	return 0;
}
*///“重载减号运算符”^
/*
class m_int {
public:
	m_int(int inum) {
		i = inum;
	}
	int operator*(m_int mi){
		return i * mi.i;
	}
	int i;
};
int main() {
	m_int mi = 10;
	m_int mia = 666;
	cout << mi * mia << endl;
	return 0;
}
*///“重载乘号运算符”^
/*
struct near {
	int i;
	int ia;
	int ix;
	int iy;
	int iwalk;
};
void printnear(const char* const cp, char ca, near* n) {
	int i = 0;
	int arr[9] = { -33,-32,-31,-1,0,1,31,32,33 };
	for (; i < 9; i++) {
		cout << "\033[" << ('G' == cp[arr[i]] ? "32;1m" : 4 == i && '0' == ca && (n->i == n->ix || n->ia == n->iy) ? "32m" : "0m") << cp[arr[i]] << "\033[0m" << (i % 3 - 2 ? "" : "#\n");
	}
	cout << "####" << endl << "你走了\033[" << ('0' == ca ? "32;1m" : "31;1m") << n->iwalk << "\033[0m步" << endl;
}
int main() {
	srand((unsigned int)time(NULL));
	near n = { rand() % 30 + 1, rand() % 30 + 1 };
	char strmaze[32][32] = {
		'@','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','@',
		'|',' ',' ',' ',' ','*',' ',' ','*',' ',' ',' ',' ',' ','*',' ',' ',' ',' ',' ',' ','*',' ',' ',' ','*',' ',' ',' ',' ',' ','|',
		'|','*',' ','*',' ','*',' ',' ','*',' ',' ','*',' ','*','*',' ','*','*',' ',' ',' ',' ',' ','*',' ','*',' ','*',' ',' ',' ','|',
		'|',' ',' ',' ',' ','*','*',' ',' ',' ','*',' ',' ','*',' ','*',' ',' ','*',' ','*',' ',' ','*',' ',' ',' ',' ',' ','*',' ','|',
		'|',' ','*',' ','*','*',' ',' ','*','*','*',' ',' ','*',' ',' ',' ',' ','*','*',' ',' ','*',' ','*',' ','*',' ','*',' ',' ','|',
		'|',' ',' ',' ',' ','*',' ','*',' ',' ',' ',' ',' ',' ',' ',' ','*',' ','*',' ',' ','*','*',' ','*',' ',' ','*',' ',' ','*','|',
		'|',' ','*',' ',' ','*','*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',' ',' ','*',' ',' ','*',' ',' ',' ',' ',' ',' ',' ',' ','|',
		'|','*','*','*',' ',' ',' ','*',' ',' ','*','*','*',' ','*',' ',' ','*',' ','*',' ','*',' ',' ',' ',' ',' ',' ','*','*',' ','|',
		'|',' ','*',' ',' ','*',' ',' ',' ',' ','*',' ','*',' ','*','*',' ','*',' ','*',' ','*',' ',' ','*','*',' ','*',' ',' ','*','|',
		'|',' ','*','*','*','*',' ',' ',' ','*',' ',' ',' ','*',' ',' ','*',' ',' ',' ','*',' ',' ',' ',' ',' ',' ',' ','*',' ',' ','|',
		'|',' ',' ','*',' ',' ',' ','*','*',' ',' ',' ','*',' ',' ','*','*',' ','*',' ',' ',' ','*',' ',' ',' ','*',' ',' ',' ',' ','|',
		'|','*',' ',' ','*',' ',' ',' ',' ',' ',' ','*',' ',' ','*',' ',' ',' ','*','*',' ',' ',' ',' ','*',' ',' ','*',' ',' ',' ','|',
		'|',' ',' ',' ',' ',' ','*',' ','*',' ','*',' ',' ',' ',' ',' ',' ','*',' ','*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',' ','|',
		'|',' ','*',' ',' ','*',' ',' ','*',' ','*',' ','*',' ','*',' ','*',' ',' ','*',' ',' ','*',' ',' ',' ',' ',' ','*',' ',' ','|',
		'|',' ',' ','*',' ','*',' ',' ','*',' ',' ',' ','*','*','*',' ',' ',' ',' ',' ',' ','*','*','*',' ','*',' ','*',' ',' ','*','|',
		'|','*',' ','*',' ',' ','*',' ','*',' ','*',' ',' ','*',' ','*',' ','*',' ',' ','*','*',' ',' ',' ',' ',' ',' ','*',' ',' ','|',
		'|',' ',' ','*',' ',' ',' ','*','*',' ',' ',' ','*',' ',' ',' ',' ',' ','*',' ',' ','*','*','*',' ',' ',' ',' ',' ',' ',' ','|',
		'|',' ',' ','*',' ',' ',' ',' ','*',' ',' ',' ',' ','*',' ',' ',' ',' ',' ','*',' ',' ',' ','*',' ',' ','*',' ',' ',' ','*','|',
		'|',' ',' ','*','*',' ','*','*',' ','*',' ',' ',' ',' ','*',' ','*',' ',' ','*','*','*','*','*',' ','*','*','*','*',' ',' ','|',
		'|',' ',' ','*',' ','*',' ',' ',' ',' ','*',' ',' ',' ',' ','*','*',' ',' ','*',' ','*',' ',' ',' ','*',' ',' ','*','*',' ','|',
		'|',' ','*',' ',' ',' ','*',' ',' ',' ','*',' ','*',' ',' ',' ',' ','*',' ',' ',' ','*',' ',' ','*',' ',' ',' ',' ',' ',' ','|',
		'|',' ',' ',' ',' ',' ',' ','*',' ',' ',' ','*',' ',' ',' ',' ',' ',' ','*',' ','*',' ',' ',' ',' ','*',' ','*',' ',' ',' ','|',
		'|','*',' ','*',' ',' ',' ','*','*',' ','*',' ','*',' ','*',' ',' ',' ',' ','*',' ',' ','*',' ','*',' ','*',' ',' ',' ','*','|',
		'|',' ','*',' ',' ',' ','*',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',' ','*',' ',' ',' ',' ',' ',' ',' ','*',' ','*',' ','|',
		'|',' ',' ','*',' ',' ','*',' ',' ',' ',' ','*',' ',' ',' ','*',' ',' ',' ',' ','*',' ',' ',' ','*',' ',' ',' ',' ',' ',' ','|',
		'|','*',' ',' ',' ',' ',' ','*',' ','*','*',' ',' ','*',' ',' ','*','*',' ',' ',' ','*',' ','*',' ','*',' ','*',' ','*',' ','|',
		'|',' ','*',' ','*',' ','*',' ','*',' ','*',' ','*',' ',' ','*',' ',' ','*',' ',' ',' ',' ',' ',' ',' ','*',' ',' ','*',' ','|',
		'|',' ','*',' ',' ','*',' ',' ','*',' ',' ',' ',' ',' ','*',' ','*',' ',' ',' ','*',' ',' ',' ','*',' ',' ',' ','*',' ',' ','|',
		'|',' ','*','*',' ',' ',' ',' ','*',' ','*',' ',' ','*',' ',' ',' ','*','*','*',' ',' ','*',' ','*',' ','*',' ',' ','*',' ','|',
		'|',' ',' ',' ',' ',' ',' ','*',' ',' ',' ','*',' ',' ','*','*',' ',' ',' ',' ',' ','*',' ',' ','*','*',' ','*',' ',' ',' ','|',
		'|','*',' ','*',' ',' ','*',' ',' ',' ',' ',' ',' ',' ','*',' ',' ',' ','*',' ',' ',' ',' ',' ','*',' ',' ',' ',' ',' ',' ','|',
		'@','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','@',
	};
	char ca = 0;
	strmaze[n.i][n.ia] = 'P';
	char* cp = &strmaze[n.i][n.ia];
	while ('P' == strmaze[n.i = rand() % 30 + 1][n.ia = rand() % 30 + 1]) {
		;
	}
	strmaze[n.i][n.ia] = 'G';
	char ch = 0;
	cout << "欢迎你来玩这个\033[7m黑暗\033[0m迷宫，在这个迷宫中，“P”是你，“*”是墙，你不能走到这，空格是你可以走的地方，“w”上移，“a”左移，“s”下移，“d”右移，而\033[32;1m“G”\033[0m是\033[32;1m终点\033[0m，走到这能让你\033[32;1m胜利\033[0m，并且，\033[4m在这个迷宫中你的出生点与\033[32;1m“G”终点\033[0;4m是随机指定的\033[0m，\033[4m而你的可视范围是以你为中心点的3*3的方块\033[0m。其中，这迷宫游戏有\033[32;1m两个\033[31m模式\033[0m，\033[32;1m一个模式是简单模式\033[0m，以\033[32;1m这个模式开始游戏就会给你提供一些\033[4m增益\033[0m：如果\033[32;1m终点“G”\033[0m的X坐标与你的X坐标相等，或者\033[32;1m终点“G”\033[0m的Y坐标与你的Y坐标相等，那么你就会变\033[32m绿\033[0m，\033[31m另一个模式是困难模式，\033[4m没有任何的增益，全靠找。\033[0m这就是这迷宫的规则，你听明白了吗?" << endl << endl << "**************" << endl << "* \033[32;1m0.简单模式\033[0m *" << endl << "* \033[31m1.困难模式\033[0m *" << endl << "**************" << endl;
	cin >> ca;
	while ('0' != ca && '1' != ca) {
		cout << "\033[31;1m输入错误，请重新输入 ->\033[0m";
		rewind(stdin);
		cin >> ca;
	}
	system("cls");
	while ('G' == strmaze[n.i][n.ia]) {
		n.ix = (cp - &strmaze[0][0]) / 32;
		n.iy = (cp - &strmaze[0][0]) % 32;
		printnear(cp, ca, &n);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'w':
			1 != n.ix && '*' != *(cp - 32) && (cp -= 32, n.iwalk++);
			break;
		case 'a':
			1 != n.iy && '*' != *(cp - 1) && (cp--, n.iwalk++);
			break;
		case 's':
			30 != n.ix && '*' != *(cp + 32) && (cp += 32, n.iwalk++);
			break;
		case 'd':
			30 != n.iy && '*' != *(cp + 1) && (cp++, n.iwalk++);
			break;
		default:
			break;
		}
		*cp = 'P';
		system("cls");
	}
	system("color 0A");
	cout << "恭喜你，走了\033[3" << ('0' == ca ? "2m" : "3;1m") << n.iwalk << "\033[0;32;1m步就赢了" << endl;
	return 0;
}
*///“C++黑暗迷宫”(选自我的CSDN博客)^
/*
class m_int {
public:
	m_int(int inum) {
		i = inum;
	}
	int operator/(m_int mi) {
		return i / mi.i;
	}
	int i;
};
int main() {
	m_int mi = 114514;
	m_int mia = 666;
	cout << mi / mia << endl;
	return 0;
}
*///“重载除号运算符”^
/*
class m_int {
public:
	m_int(int inum) {
		i = inum;
	}
	int operator+(m_int mi) {
		return i + mi.i;
	}
	int i;
};
ostream& operator<<(ostream& cout, const m_int m_i) {
	return cout << m_i.i;
}
int main() {
	m_int mi = 114514;
	m_int mia = 666;
	cout << mi + mia << endl;
	return 0;
}
*///“重载左移运算符”^
/*
class m_int {
public:
	m_int(int inum) {
		i = inum;
	}
	int operator<(m_int mi) {
		return i < mi.i;
	}
	int i;
};
int main() {
	m_int mi = 0;
	m_int mia = 8;
	cout << (mi < mia) << endl;
	return 0;
}
*///“重载小于号运算符”^
/*
enum XY {
	X,
	Y
};
class Player{
private:
	int ix;
	int iy;
	int ij;
public:
	void left_move(char* cp, int iy) {

	}
	void right_move(char* cp, int iy) {

	}
	void jump() {

	}
	int& sgetxy(XY xymode) {
		return xymode ? iy : ix;
	}
	void upOrDown() {

	}
};
void printmap(const char strmap[11][11]) {
	int i = 0;
	int ia = 0;
	for (; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
int main() {
	char strmap[11][11] = {
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ','G',' ',' ',' ',' ',' ','*','*','*',' ',
		' ','*','*','*',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ','*','*','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ','*','*','*',' ',' ','*','*','*',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ','*','*','*',' ',' ',' ','*','*','*',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '
	};
	char* cp = &strmap[10][0];
	Player p;
	char ch = 0;
	int i = 0;
	//cout << "欢迎你来玩这个\033[33m门\033[0m迷宫，在这个迷宫中，“P”是你，“*”是墙，你不能走到这，空格是你可以走的地方，“w”使你上移，“a”使你左移，“s”使你下移，“d”使你右移，而\033[32;1m“G”\033[0m是\033[32;1m终点\033[0m，走到这能让你\033[32;1m胜利\033[0m，并且，\033[33m“0”\033[0m是\033[33m门\033[0m，按“\033[33mz\033[0m”键进入就可以走到\033[33m另外一扇门\033[0m的前面。这就是这迷宫的规则，你听明白了吗?" << endl << endl;
	//system("pause");
	system("cls");
	while ('G' == strmap[1][1]) {
		p.sgetxy(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxy(Y) = (cp - &strmap[0][0]) % 11;
		printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'a':
			p.sgetxy(Y) && '*' != *(cp - 1)&& (cp--);
			break;
		case 'd':
			10 != p.sgetxy(Y) && '*' != *(cp + 1) && (cp++);
			break;
		case 'w':

		default:
			break;
		}
		*cp = 'P';
		system("cls");
	}
	system("color 0A");
	cout << "恭喜你，你赢了" << endl;
	return 0;
}
*///“C++平台跳跃游戏测试版Alpha1.0”^
/*
enum XY {
	X,
	Y,
};
class Player{
private:
	int ix;
	int iy;
	int ij;
public:
	void jump(char* cp) {
		10 == ix || '*' == cp[11] && (ij = 3);
	}
	void left_move(char** cpp) {
		iy && '*' != *(*cpp-1) && ((*cpp)--);
	}
	void right_move(char** cpp) {
		10 != iy && '*' != *(*cpp+1) && ((*cpp)++);
	}
	int& sgetxy(XY xymode) {
		return xymode ? iy : ix;
	}
	void upOrDown(char** cp) {
		if (ij > 0 && ix && '*' != cp[0][-11]) {
			ij--, *cp -= 11;
		}
		else if (!ix || '*' == cp[0][-11]) {
			ij = 0, *cp += 11;
		}
		else if('*' != cp[0][11] || 10 != ix) {
			*cp += 11;
		}
	}
};
void printmap(const char strmap[11][11]) {
	int i = 0;
	int ia = 0;
	for (; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
int main() {
	char strmap[11][11] = {
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ','G',' ',' ',' ',' ',' ','*','*','*',' ',
		' ','*','*','*',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ','*','*','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ','*','*','*',' ',' ','*','*','*',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ','*','*','*',' ',' ',' ','*','*','*',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '
	};
	char* cp = &strmap[10][0];
	Player p;
	char ch = 0;
	int i = 0;
	//cout << "欢迎你来玩这个\033[33m门\033[0m迷宫，在这个迷宫中，“P”是你，“*”是墙，你不能走到这，空格是你可以走的地方，“w”使你上移，“a”使你左移，“s”使你下移，“d”使你右移，而\033[32;1m“G”\033[0m是\033[32;1m终点\033[0m，走到这能让你\033[32;1m胜利\033[0m，并且，\033[33m“0”\033[0m是\033[33m门\033[0m，按“\033[33mz\033[0m”键进入就可以走到\033[33m另外一扇门\033[0m的前面。这就是这迷宫的规则，你听明白了吗?" << endl << endl;
	//system("pause");
	system("cls");
	while ('G' == strmap[1][1]) {
		p.sgetxy(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxy(Y) = (cp - &strmap[0][0]) % 11;
		printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(cp);
			break;
		default:
			break;
		}
		*cp = (p.upOrDown(&cp),'P');
		system("cls");
	}
	system("color 0A");
	cout << "恭喜你，你赢了" << endl;
	return 0;
}
*///“C++平台跳跃游戏Bug1.0”^
/*
enum XY {
	X,
	Y,
};
class Player{
private:
	int ix;
	int iy;
	int ij;
public:
	Player() {
		ij = 0;
	}//防止ij未定义
	void jump(char** cpp) {
		(10 == ix || '*' == (*cpp)[11]) && (ij = 3);
	}
	void left_move(char** cpp) {
		iy && '*' != *(*cpp-1) && ((*cpp)--);
	}
	void right_move(char** cpp) {
		10 != iy && '*' != *(*cpp+1) && ((*cpp)++);
	}
	int& sgetxy(XY xymode) {
		return xymode ? iy : ix;
	}
	void upOrDown(char** cpp) {
		if (ij > 0 && ix && '*' != (*cpp)[-11]) {
			ij--, *cpp -= 11;
		}
		else if (!ix || '*' == (*cpp)[-11]) {
			ij = 0, *cpp += 11;
		}
		else if('*' != (*cpp)[11] && 10 != ix) {
			*cpp += 11;
		}
	}
};
void printmap(const char strmap[11][11]) {
	int i = 0;
	int ia = 0;
	for (; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
int main() {
	char strmap[11][11] = {
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ','G',' ',' ',' ',' ',' ','*','*','*',' ',
		' ','*','*','*',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ','*','*','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ','*','*','*',' ',' ','*','*','*',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ','*','*','*',' ',' ',' ','*','*','*',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '
	};
	char* cp = &strmap[10][0];
	Player p;
	char ch = 0;
	int i = 0;
	//cout << "欢迎你来玩这个\033[33m门\033[0m迷宫，在这个迷宫中，“P”是你，“*”是墙，你不能走到这，空格是你可以走的地方，“w”使你上移，“a”使你左移，“s”使你下移，“d”使你右移，而\033[32;1m“G”\033[0m是\033[32;1m终点\033[0m，走到这能让你\033[32;1m胜利\033[0m，并且，\033[33m“0”\033[0m是\033[33m门\033[0m，按“\033[33mz\033[0m”键进入就可以走到\033[33m另外一扇门\033[0m的前面。这就是这迷宫的规则，你听明白了吗?" << endl << endl;
	//system("pause");
	system("cls");
	while ('G' == strmap[1][1]) {
		p.sgetxy(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxy(Y) = (cp - &strmap[0][0]) % 11;
		printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		default:
			break;
		}
		p.upOrDown(&cp);
		*cp = 'P';
		system("cls");
	}
	system("color 0A");
	cout << "恭喜你，你赢了" << endl;
	return 0;
}
*///“C++平台跳跃游戏Beta1.0”^
/*
enum XY {
	X,
	Y,
};
class Player{
private:
	int ix;
	int iy;
	int ij;
public:
	Player() {
		ij = 0;
	}//初始化
	void jump(char** cpp) {
		(10 == ix || '*' == (*cpp)[11]) && (ij = 3);
	}
	void left_move(char** cpp) {
		iy && '*' != *(*cpp-1) && ((*cpp)--);
	}
	void right_move(char** cpp) {
		10 != iy && '*' != *(*cpp+1) && ((*cpp)++);
	}
	int& sgetxy(XY xymode) {
		return xymode ? iy : ix;
	}
	void upOrDown(char** cpp) {
		if (ij > 0 && ix && '*' != (*cpp)[-11]) {
			ij--, *cpp -= 11;
		}
		else if ('*' != (*cpp)[11] && (!ix || '*' == (*cpp)[-11])) {
			ij = 0, *cpp += 11;
		}
		else if('*' != (*cpp)[11] && 10 != ix) {
			*cpp += 11;
		}
	}
};
void printmap(const char strmap[11][11]) {
	int i = 0;
	int ia = 0;
	for (; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
int main() {
	char strmap[11][11] = {
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ','G',' ',' ',' ',' ',' ','*','*','*',' ',
		' ','*','*','*',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ','*','*','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ','*','*','*',' ',' ','*','*','*',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ','*','*','*',' ',' ',' ','*','*','*',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '
	};
	char* cp = &strmap[10][0];
	Player p;
	char ch = 0;
	int i = 0;
	//cout << "欢迎你来玩这个\033[33m门\033[0m迷宫，在这个迷宫中，“P”是你，“*”是墙，你不能走到这，空格是你可以走的地方，“w”使你上移，“a”使你左移，“s”使你下移，“d”使你右移，而\033[32;1m“G”\033[0m是\033[32;1m终点\033[0m，走到这能让你\033[32;1m胜利\033[0m，并且，\033[33m“0”\033[0m是\033[33m门\033[0m，按“\033[33mz\033[0m”键进入就可以走到\033[33m另外一扇门\033[0m的前面。这就是这迷宫的规则，你听明白了吗?" << endl << endl;
	//system("pause");
	system("cls");
	while ('G' == strmap[1][1]) {
		p.sgetxy(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxy(Y) = (cp - &strmap[0][0]) % 11;
		printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		default:
			break;
		}
		p.upOrDown(&cp);
		*cp = 'P';
		system("cls");
	}
	system("color 0A");
	cout << "恭喜你，你赢了" << endl;
	return 0;
}
*///“C++平台跳跃游戏临正1.0”^
/*
//cppMeiRi.cpp
#include <iostream>
#include "Player.h"
using namespace std;
void printmap(const char strmap[11][11], const int icoin) {
	int i = 0;
	int ia = 0;
	for (; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : '$' == strmap[i][ia] ? "33m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl << "\033[33" << (20 == icoin ? ";1" : "") << "m$ * " << icoin << "\033[0m" << endl;
}
int main() {
	char str[9] = "color 0";
	char strmap[11][11] = {
		' ',' ',' ',' ',' ',' ',' ',' ','$','$',' ',
		' ','G',' ',' ',' ','$',' ','*','*','*',' ',
		' ','*','*','*',' ',' ',' ',' ',' ',' ',' ',
		'$',' ',' ',' ','$',' ','$',' ',' ','$',' ',
		' ',' ','$',' ','*','*','*',' ','$',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ','*','*','*',' ',' ','*','*','*',' ',' ',
		' ',' ','$',' ','$',' ',' ',' ','$',' ',' ',
		' ',' ','*','*','*',' ','$',' ','*','*','*',
		' ',' ',' ',' ',' ',' ',' ',' ',' ','$','$',
		'P',' ','$','$','$',' ',' ',' ',' ','$','$'
	};
	char* cp = &strmap[10][0];
	Player p;
	char ch = 0;
	int icoin = 0;
	int coinarr[40] = { 0,8,0,9,1,5,3,0,3,4,3,6,3,9,4,2,4,8,7,2,7,4,7,8,8,6,9,9,9,10,10,2,10,3,10,4,10,9,10,10 };
	cout << "欢迎你来玩这个平台跳跃游戏，在这个游戏中，“P”是你，“*”是平台，你不能走到这，空格是\033[30;1m空气\033[0m，“w”使你跳，就像\033[31;1m马里奥\033[0m一样，“a”使你左移，“d”使你右移，而\033[32;1m“G”\033[0m是\033[32;1m终点\033[0m，走到这能让你\033[32;1m胜利\033[0m，并且，\033[33m“$”\033[0m是\033[33m金币\033[0m，得到\033[33m它\033[0m就会使你\033[33m获得\033[0m一个\033[33m金币\033[0m。这就是这游戏的规则，你听明白了吗?" << endl << endl;
	system("pause");
	system("cls");
	while ('G' == strmap[1][1]) {
		p.sgetxy(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxy(Y) = (cp - &strmap[0][0]) % 11;
		for (ch = 0; ch < 40; ch += 2) {
			p.sgetxy(X) == coinarr[ch] && p.sgetxy(Y) == coinarr[ch + 1] && (coinarr[ch] = -1, icoin++);
		}
		printmap(strmap, icoin);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		default:
			break;
		}
		p.upOrDown(&cp);
		*cp = 'P';
		system("cls");
	}
	20 == icoin && (str[7] = 'E'), 20 == icoin || (str[7] = '6');
	system(str);
	cout << "恭喜你，你赢了，获得了金币" << icoin << "枚" << endl;
	return 0;
}
//Player.h
#pragma once
#include <iostream>
using namespace std;
#define JUMPHIGH 3
enum XY {
	X,
	Y,
};
class Player {
private:
	int ix;
	int iy;
	int ij;
public:
	Player();
	void jump(char** cpp);
	void left_move(char** cpp);
	void right_move(char** cpp);
	int& sgetxy(XY xymode);
	void upOrDown(char** cpp);
};
//Player.cpp
#include <iostream>
#include "Player.h"
using namespace std;
Player::Player(){
	ij = 0;
}
void Player::jump(char** cpp) {
	(10 == ix || '*' == (*cpp)[11]) && (ij = JUMPHIGH);
}
void Player::left_move(char** cpp) {
	iy && '*' != *(*cpp - 1) && ((*cpp)--);
}
void Player::right_move(char** cpp) {
	10 != iy && '*' != *(*cpp + 1) && ((*cpp)++);
}
int& Player::sgetxy(XY xymode) {
	return xymode ? iy : ix;
}
void Player::upOrDown(char** cpp) {
	if (ij > 0 && ix && '*' != (*cpp)[-11]) {
		ij--, * cpp -= 11;
	}
	else if ('*' != (*cpp)[11] && (!ix || '*' == (*cpp)[-11])) {
		ij = 0, * cpp += 11;
	}
	else if ('*' != (*cpp)[11] && 10 != ix) {
		*cpp += 11;
	}
}
*///“C++平台跳跃游戏”(选自我的CSDN博客)^
/*
int main() {
	std::cout << "Hello, world! - ::" << std::endl;
	return 0;
}
*///“::”^
/*
//trigger.h
#pragma once
#include <iostream>
using namespace std;
class trigger {
private:
	int MISX;
	int MISY;
	int MIEX;
	int MIEY;
	int Mtrig;
	bool MBt;
	static bool MSB;
	static bool MSBa;
	static bool MSBb;
public:
	trigger(int istartx, int istarty, int iendx, int iendy, int trig) :MISY(istarty), MIEX(iendx), MIEY(iendy), MISX(istartx), Mtrig(trig), MBt(false) {
		MSB = false;
		MSBa = false;
		MSBb = false;
	}
	void check(int ix, int iy, char strmap[11][11], char* cp = NULL);
};
//trigger.cpp
#include <iostream>
#include "trigger.h"
using namespace std;
void trigger::check(int ix, int iy, char strmap[11][11], char* cp = NULL) {
	if (MISX <= ix && ix <= MIEX && MISY <= iy && iy <= MIEY && Mtrig - 4 ? (!MBt) : 1) {
		switch (MBt = true, Mtrig) {
		case 0:
			break;
		default:
			break;
		}
	}
}
*///“触发器类1”^
/*
//Game.cpp
#include <iostream>
#include "Player.h"
#include "trigger.h"
using namespace std;
void printmap(const char strmap[22][22]) {
	int i = 0;
	int ia = 0;
	for (; i < 22; i++) {
		for (ia = 0; ia < 22; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : 'X' == strmap[i][ia] ? "31;1m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
int main() {
	char str[9] = "color 0";
	char strmap[22][22] = {
		'G',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','t',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','t',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ','X','X','X',' ',' ',' ',' ',' ',' ',' ','t',' ',' ',' ',' ',' ',
		' ','t','t','t',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','t',' ',' ',' ',' ','#',
		' ','*','*','*',' ','t',' ',' ',' ','t',' ',' ',' ',' ',' ',' ','t',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ','*','X','*',' ',' ',' ',' ',' ',' ',' ','t',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','t',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ','t','*','*','*','t',' ',' ',' ',' ',' ',' ','t',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','t','t','t',' ',' ','t',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ','t',' ','t',' ',' ','t','t','t',' ',' ','t',' ',' ',' ','S',' ',
		'X','X','X','X','X','X','X','X','X','X','X','*','*','*','X','X','X','X','X','X','*',' ',
		' ','t',' ','t',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',' ','S',
		'*','*','*','*','*','*','*','*','*',' ',' ',' ',' ',' ',' ',' ','t','t','*',' ',' ','*',
		' ','t','X',' ',' ',' ',' ','t','t','*','X','*',' ',' ',' ','t',' ','*',' ',' ',' ',' ',
		'G','t',' ',' ',' ','X',' ','t','t',' ',' ','t','*',' ','t',' ',' ','*',' ',' ',' ',' ',
		'*','*','*','*','*','*','*','t','t',' ',' ','t',' ',' ','t',' ',' ','*','t','t',' ',' ',
		' ',' ',' ',' ',' ','t',' ','*',' ',' ','X','t',' ',' ',' ',' ',' ','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ','t',' ',' ','*','*','*','*','*','t',' ','t','t','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ','*',' ',' ',' ',' ','X','X','X',' ',' ',' ',' ',' ',' ','*',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','X','t',' ',' ','*','*','*','*',' ',' ',' ',
		' ',' ',' ','t',' ',' ',' ',' ',' ','X',' ',' ','t','X',' ','*',' ',' ',' ',' ',' ',' ',
		'P','X','X','*','X','X','X',' ','X','X','X',' ','X','X','X','*','X','X','X','X','X','X',
	};
	char* cp = &strmap[21][0];
	Player p;
	char ch = 0;
	trigger t[22] = { trigger(20,3,20,3,0), trigger(16,5,16,6,1),trigger(19,12,20,12,2),trigger(17,13,17,13,3),trigger(17,15,17,16,3),trigger(14,14,14,15,3),trigger(13,16,13,17,3),trigger(15,18,15,19,3),trigger(11,20,11,21,4),trigger(3,21,3,21,5),trigger(0,16,9,16,6),trigger(8,11,10,12,7),trigger(4,5,7,9,8),trigger(9,6,9,8,9),trigger(3,1,3,3,10),trigger(11,1,11,1,11),trigger(11,3,11,3,12),trigger(13,1,14,1,13),trigger(13,7,15,8,14),trigger(15,11,17,11,15),trigger(15,11,17,11,16),trigger(21,13,21,13,17)};
	//cout << "欢迎你来玩这个平台跳跃游戏，在这个游戏中，“P”是你，“*”是平台，你不能走到这，空格是\033[30;1m空气\033[0m，“w”使你跳，就像\033[31;1m马里奥\033[0m一样，“a”使你左移，“d”使你右移，而\033[32;1m“G”\033[0m是\033[32;1m终点\033[0m，走到这能让你\033[32;1m胜利\033[0m，并且，\033[33m“$”\033[0m是\033[33m金币\033[0m，得到\033[33m它\033[0m就会使你\033[33m获得\033[0m一个\033[33m金币\033[0m。这就是这游戏的规则，你听明白了吗?" << endl << endl;
	//system("pause");
	system("cls");
	while ('G' == strmap[0][0]) {
		p.sgetxy(X) = (cp - &strmap[0][0]) / 22;
		p.sgetxy(Y) = (cp - &strmap[0][0]) % 22;
		printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			break;
		case 'r':
			break;
		default:
			break;
		}
		p.upOrDown(&cp);
		*cp = 'P';
		system("cls");
	}
	system("color 0A");
	cout << "恭喜你，你赢了" << endl;
	return 0;
}
//trigger.h
#pragma once
#include <iostream>
using namespace std;
class trigger {
private:
	int MISX;
	int MISY;
	int MIEX;
	int MIEY;
	int Mtrig;
	bool MBt;
	static bool MSB;
	static bool MSBa;
	static bool MSBb;
public:
	trigger(int istartx, int istarty, int iendx, int iendy, int trig) :MISY(istarty), MIEX(iendx), MIEY(iendy), MISX(istartx), Mtrig(trig), MBt(false) {
		MSB = false;
		MSBa = false;
		MSBb = false;
	}
	void check(int ix, int iy, char(*strmap)[11][11], char* cp = NULL);
};
//trigger.cpp
#include <iostream>
#include "trigger.h"
using namespace std;
void trigger::check(int ix, int iy, char (*strmap)[11][11], char* cp = NULL) {
	int i = 0;
	if (MISX <= ix && ix <= MIEX && MISY <= iy && iy <= MIEY && Mtrig - 4 ? (!MBt) : 1) {
		switch (MBt = true, Mtrig) {
		case 0:
			(*strmap)[21][3] = 'X';
			break;
		case 1:
			for (i = 16; i < 21; i++) {
				(*strmap)[i][6] = 'X';
			}
			break;
		case 2:
			for (i = 18; i < 22; i++) {
				if ('X' == (*strmap)[i][13]) {
					(*strmap)[i][13] = ' ';
				}
				else {
					(*strmap)[i][13] = 'X';
				}
			}
			break;
		case 3:
			for (i = MISX; i <= MIEX; i++) {
				for (int ia = MISY; ia <= MIEY; ia++) {
					(*strmap)[i][ia] = 'X';
				}
			}
			break;
		case 4:
			break;
		case 5:
			break;
		case 6:
			break;
		case 7:
			break;
		case 8:
			break;
		case 9:
			break;
		case 10:
			break;
		case 11:
			break;
		case 12:
			break;
		case 13:
			break;
		case 14:
			break;
		case 15:
			break;
		case 16:
			break;
		case 17:
			(*strmap)[21][13] = 'X';
			break;
		default:
			break;
		}
	}
}
*///“触发器类2”^
/*
//Player.cpp
#include <iostream>
#include <algorithm>
#include "trigger.h"
#include "Player.h"
using namespace std;
Player::Player(){
	ij = 2;
	ijh = 0;
	blr = 1;
}
bool trigger::MSB = false;
void Player::printmap(const char strmap[22][22]) {
	int i = 0;
	int ia = 0;
	for (; i < 22; i++) {
		for (ia = 0; ia < 22; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : 'X' == strmap[i][ia] ? "31;1m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "----------------------@" << endl;
}
void Player::Djump(char** cpp) {
	switch (ij) {
	case 2:
		((21 == ix || '*' == (*cpp)[22] || '#' == (*cpp)[22]) && (ij = 1, ijh = JUMPHIGH), (21 != ix && '*' != (*cpp)[22] && '#' != (*cpp)[22]) && (ij = 0, ijh = JUMPHIGH));
		break;
	case 1:
		((21 == ix || '*' == (*cpp)[22] || '#' == (*cpp)[22]) && (ij = 2), (21 != ix && '*' != (*cpp)[22] && '#' != (*cpp)[22]) && (ij = 0, ijh = JUMPHIGH));
		break;
	default:
		rejump(cpp);
		((21 == ix || '*' == (*cpp)[22] || '#' == (*cpp)[22]) && (ij = 1, ijh = JUMPHIGH), (21 != ix && '*' != (*cpp)[22] && '#' != (*cpp)[22]) && (ij = 0, ijh = JUMPHIGH));
		break;
	}
}
void Player::left_move(char** cpp) {
	(iy && '*' != *(*cpp - 1) && '#' != *(*cpp - 1) && ((*cpp)--));
	blr = false;
}
void Player::right_move(char** cpp) {
	21 != iy && '*' != *(*cpp + 1) && '#' != *(*cpp + 1) && ((*cpp)++);
	blr = true;
}
int& Player::sgetxy(XY xymode) {
	return xymode ? iy : ix;
}
void Player::upOrDown(char** cpp) {
	if (ijh > 0 && ix && '*' != (*cpp)[-22] && '#' != (*cpp)[-22]) {
		ijh--, *cpp -= 22;
	}
	else if ('*' != (*cpp)[22] && '#' != (*cpp)[22] && (!ix || '*' == (*cpp)[-22] || '#' == (*cpp)[-22])) {
		ijh = 0, *cpp += 22;
	}
	else if ('*' != (*cpp)[22] && '#' != (*cpp)[22] && 21 != ix) {
		*cpp += 22;
	}
}
void Player::gameover(char** cpp,const char strmap[22][22]) {
	char ch = 0;
	system("cls");
	printmap(strmap); 
	cout << "\033[31;1m游戏结束 请按r键重新开始\033[0m" << endl;
	while (ch - 'r') {
		cin >> ch;
		rewind(stdin);
		system("cls");
		if (ch - 'r') {
			printmap(strmap);
			cout << "\033[31;1m游戏结束 请按r键重新开始\033[0m" << endl;
		}
	}
	reset(cpp);
}
void Player::reset(char** cpp) {

}
void Player::rejump(char** cpp) {
	(21 == ix || '*' == (*cpp)[22]) && (ij = 2);
}
void Player::shoot(int& i, char** cpp) {
	if ((!i) && (iy && blr || 21 != iy && (!blr))) {
		v.push_back({*cpp, blr, iy});
		i = 3;
	}
}
void Player::shootmove() {
	vector<trir>::iterator ite = v.end();
	for (vector<trir>::iterator it = v.begin();ite!=it;it++) {
		(' ' == *it->cp || '@' == *it->cp) && (*it->cp = ' ');
		'#' == *it->cp && (MSB = true);
		if ('*' == *it->cp || '#' == *it->cp || (!it->iy && (!it->b)) || (21 == it->iy && it->b)) {
			vector<trir>::iterator ita = it++;
			ite--;
			v.erase(ita);
		}
		if (!v.size() || ite <= it) {
			break;
		}
		it->cp -= 1 - it->b * 2;
		it->iy -= 1 - it->b * 2;
		(' ' == *it->cp || '@' == *it->cp) && (*it->cp = '@');
	}
}
*///射弹^
/*
//Player.cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include "trigger.h"
#include "Player.h"
using namespace std;
Player::Player(){
	ij = 2;
	ijh = 0;
	blr = 1;
}
bool MSB = false;
bool MSBa = false;
bool MSBb = false;
bool MSBc = false;
bool trigger::MSv = false;
void Player::printmap(const char strmap[22][22]) {
	int i = 0;
	int ia = 0;
	for (; i < 22; i++) {
		for (ia = 0; ia < 22; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : 'X' == strmap[i][ia] ? "31;1m" : '#' == strmap[i][ia] ? trigger::MSB ? "32;1m" : "31;1m" : 'S' == strmap[i][ia] ? ((!trigger::MSv) || 21 == ia) ? "33m" : "33;1m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "----------------------@" << endl;
}
void Player::Djump(char** cpp) {
	switch (ij) {
	case 2:
		((21 == ix || '*' == (*cpp)[22] || '#' == (*cpp)[22]) && (ij = 1, ijh = JUMPHIGH), (21 != ix && '*' != (*cpp)[22] && '#' != (*cpp)[22]) && (ij = 0, ijh = JUMPHIGH));
		break;
	case 1:
		((21 == ix || '*' == (*cpp)[22] || '#' == (*cpp)[22]) && (ij = 2), (21 != ix && '*' != (*cpp)[22] && '#' != (*cpp)[22]) && (ij = 0, ijh = JUMPHIGH));
		break;
	default:
		rejump(cpp);
		((21 == ix || '*' == (*cpp)[22] || '#' == (*cpp)[22]) && (ij = 1, ijh = JUMPHIGH), (21 != ix && '*' != (*cpp)[22] && '#' != (*cpp)[22]) && (ij = 0));
		break;
	}
}
void Player::left_move(char** cpp) {
	(iy && '*' != *(*cpp - 1) && '#' != *(*cpp - 1) && ((*cpp)--));
	blr = false;
}
void Player::right_move(char** cpp) {
	21 != iy && '*' != *(*cpp + 1) && '#' != *(*cpp + 1) && ((*cpp)++);
	blr = true;
}
int& Player::sgetxy(XY xymode) {
	return xymode ? iy : ix;
}
void Player::upOrDown(char** cpp) {
	if (ijh > 0 && ix && '*' != (*cpp)[-22] && '#' != (*cpp)[-22]) {
		ijh--, *cpp -= 22;
	}
	else if ('*' != (*cpp)[22] && '#' != (*cpp)[22] && (!ix || '*' == (*cpp)[-22] || '#' == (*cpp)[-22])) {
		ijh = 0, *cpp += 22;
	}
	else if ('*' != (*cpp)[22] && '#' != (*cpp)[22] && 21 != ix) {
		*cpp += 22;
	}
}
void Player::gameover(char** cpp, char (*strmap)[22][22], const char (*strmapr)[22][22], trigger(*tarr)[23]) {
	char ch = 0;
	system("cls");
	printmap(*strmap); 
	cout << "\033[31;1m游戏结束 请按r键重新开始\033[0m" << endl;
	while (ch - 'r') {
		cin >> ch;
		rewind(stdin);
		system("cls");
		if (ch - 'r') {
			printmap(*strmap);
			cout << "\033[31;1m游戏结束 请按r键重新开始\033[0m" << endl;
		}
	}
	reset(cpp, strmap, strmapr, tarr);
}
void Player::reset(char** cpp, char(*strmap)[22][22], const char(*strmapr)[22][22], trigger(*tarr)[23]) {
	trigger::MSv && (*cpp = &((*strmap)[9][20]), ix = 9, iy = 20), trigger::MSv || (*cpp = &((*strmap)[21][0]), ix = 21, iy = 0);
	MSB = false;
	MSBa = false;
	MSBb = false;
	MSBc = false;
	int i = 0;
	memcpy(*strmap, *strmapr, sizeof(*strmapr));
	for (; i < 23; i++) {
		(*tarr)[i].MBt = false;
	}
	rejump(cpp);
}
void Player::rejump(char** cpp) {
	(21 == ix || '*' == (*cpp)[22]) && (ij = 2);
}
void Player::shoot(int& i, char** cpp) {
	if ((!i) && (iy && blr || 21 != iy && (!blr))) {
		v.push_back({*cpp, blr, iy});
		i = 3;
	}
}
void Player::shootmove(const char(*strmap)[22][22]) {
	vector<trir>::iterator ite = v.end();
	for (vector<trir>::iterator it = v.begin();ite!=it;it++) {
		(' ' == *it->cp || '@' == *it->cp) && (*it->cp = ' ');
		'#' == *it->cp && (trigger::MSB = true);
		&((*strmap)[9][20]) == it->cp && (trigger::MSv = true);
		if ('*' == *it->cp || '#' == *it->cp || (!it->iy && (!it->b)) || (21 == it->iy && it->b)) {
			vector<trir>::iterator ita = it++;
			ite--;
			v.erase(ita);
		}
		if (!v.size() || ite <= it) {
			break;
		}
		it->cp -= 1 - it->b * 2;
		it->iy -= 1 - it->b * 2;
		(' ' == *it->cp || '@' == *it->cp) && (*it->cp = '@');
	}
}
*///存档^
/*
//Game.cpp
#include <iostream>
#include <cstring>
#include <fstream>
#include "Player.h"
#include "trigger.h"
using namespace std;
void deadset(int (*deadarr)[3], fstream& fs) {
	int i = 0;
	for (; i < 3; i++) {
		fs >> (*deadarr)[i];
		fs.flush();
	}
}
void printstart() {
	cout << "*****    * * *   ***   *   *  *   *   ***      ***    ***     *****   ***     *****  *   *  *****   \033[32;1m* *  ***    * *\033[0m" << endl;
	cout << "  *      * * *  *   *  **  *  **  *  *   *    *      *   *      *    *   *      *    *   *  *     \033[32;1m * *  *      * *\033[0m " << endl;
	cout << "  *      * * *  *****  * * *  * * *  *****    *  **  *   *      *    *   *      *    *****  *****       \033[32;1m* ***\033[0m      " << endl;
	cout << "  *       * *   *   *  *  **  *  **  *   *    *   *  *   *      *    *   *      *    *   *  *           \033[32;1m*   *\033[0m      " << endl;
	cout << "*****     * *   *   *  *   *  *   *  *   *     ***    ***       *     ***       *    *   *  *****        \033[32;1m***\033[0m       " << endl;
}
int main() {
	char strmap[22][22] = {
		'G',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ','X','X','X',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ','*','X','*',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ','*','*','*',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','S',' ',
		'X','X','X','X','X','X','X','X','X','X','X','*','*','*','X','X','X','X','X','X','*',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',' ','S',
		'*','*','*','*','*','*','*','*','*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',' ',' ','*',
		' ',' ','X',' ',' ',' ',' ',' ',' ','*','X','*',' ',' ',' ',' ',' ','*',' ',' ',' ',' ',
		'G',' ',' ',' ',' ','X',' ',' ',' ',' ',' ',' ','*',' ',' ',' ',' ','*',' ',' ',' ',' ',
		'*','*','*','*','*','*','*',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ','*',' ',' ','X',' ',' ',' ',' ',' ',' ','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ','*','*','*','*','*',' ',' ',' ',' ','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','X','X',' ',' ',' ',' ',' ',' ',' ','*',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','X',' ',' ',' ','*','*','*','*',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ','X',' ',' ',' ','X',' ','*',' ',' ',' ',' ',' ',' ',
		' ','X','X','*','X','X','X',' ','X','X','X',' ','X','X','X','*','X','X','X','X','X','X',
	};
	char strmapr[22][22] = { 0 };
	memcpy(strmapr, strmap, sizeof strmap);
	Player p;
	char ch = 0;
	int itrap = -1;
	int ishoot = 0;
	int ibsv = 0;
	fstream fs("s.txt", ios::in);
	fs.flush();
	if ((!fs.is_open()) || fs.eof()) {
		fs.close();
		fs.open("s.txt", ios::out);
		fs << "0 0 0 0";
		fs.close();
		fs.open("s.txt", ios::in);
	}
	bool barr[3] = { 0 };
	fs >> ibsv;
	for (ch = 0; ch < 3; ch++) {
		barr[ch] = (ibsv & (1 << ch));
	}
	trigger t[23] = { trigger(20,3,20,3,0), trigger(16,5,16,6,1),trigger(19,12,20,12,2),trigger(17,13,17,13,3),trigger(17,15,17,16,3),trigger(14,14,14,15,3),trigger(13,16,13,17,3),trigger(15,18,15,19,3),trigger(11,20,11,21,4),trigger(3,21,3,21,5),trigger(0,16,9,16,6),trigger(8,11,9,13,7),trigger(4,5,7,9,8),trigger(9,6,9,8,9),trigger(3,1,3,3,10),trigger(11,1,11,1,11),trigger(11,3,11,3,12),trigger(13,1,14,1,13),trigger(13,7,15,8,14),trigger(15,11,17,11,15),trigger(16,12,17,12,16),trigger(21,13,21,13,17),trigger(11,8,11,8,18) };
	printstart();
	cout << endl << endl << endl << endl << endl << endl << endl << "\t\t\t\t\t  ";
	system("pause");
	system("cls");
	printstart();
	cout << endl << "              \033[31;1m********\033[0m                          \033[33m********\033[0m                              \033[32;1m********\033[0m" << endl;
	cout << "             \033[31;1m* SAVE 1 *\033[0m                        \033[33m* SAVE 2 *\033[0m                            \033[32;1m* SAVE 3 *\033[0m" << endl;
	cout << "              \033[31;1m********\033[0m                          \033[33m********\033[0m                              \033[32;1m********\033[0m" << endl << endl;
	cout << "a左走    d右走    w二段跳，空中一段    z\033[33m存档\033[0m/射弹    r重开    \033[31;1m“X”死\033[0m   “*”墙    \033[31;1m“#”按钮\033[0m，\033[32;1m射就触发机关\033[0m    \033[33m“S”存档\033[0m    \033[32;1m“G”终点\033[0m    1~3选择要玩的存档    d删存档" << endl << endl << endl;
	cin >> ch;
	while (rewind(stdin), /*'d' != ch &&*/ (ch < '1' || ch > '3')) {
		cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		cin >> ch;
	}
	int barri = (--ch -= '0');
	system("cls");
	char* cp = (t[0].saveset(barr[barri]) ? &strmap[9][20] : &strmap[21][0]);
	int deadarr[3] = { 0 };
	deadset(&deadarr, fs);
	*cp = 'P';
	fs << (char)(ibsv + '0');
	fs.flush();
	while ('G' == strmap[0][0]) {
		' ' == strmap[9][20] && (strmap[9][20] = 'S');
		' ' == strmap[11][21] && (strmap[11][21] = 'S');
		p.sgetxy(X) = (cp - &strmap[0][0]) / 22;
		p.sgetxy(Y) = (cp - &strmap[0][0]) % 22;
		p.printmap(strmap, deadarr[barri]);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.Djump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
			break;
		case 'r':
			p.reset(&cp, &strmap, &strmapr, &t, deadarr[barri]);
			break;
		default:
			break;
		}
		for (int i = 0; i < 23; i++) {
			t[i].check(p.sgetxy(X), p.sgetxy(Y), &strmap, &strmapr, p, itrap, &cp, ch, &t, deadarr[barri]);
		}
		itrap > 0 && itrap--, !itrap && (strmap[14][5] = ' ', strmap[15][5] = 'X');
		p.upOrDown(&cp);
		p.shootmove(&strmap, barri, ibsv, fs, &deadarr);
		p.rejump(&cp);
		if ('X' == *cp) {
			p.gameover(&cp, &strmap, &strmapr, &t, deadarr[barri]);
		}
		*cp = 'P';
		ishoot > 0 && ishoot--;
		system("cls");
	}
	system("color 0A");
	cout << "恭喜你，你赢了，似了" << deadarr[barri] << "次" << endl;
	fs.close();
	return 0;
}
*///“似亡”^
/*
//Game.cpp
#include <iostream>
#include <cstring>
#include <fstream>
#include "Player.h"
#include "trigger.h"
using namespace std;
void deadset(int (*deadarr)[3], fstream& fs) {
	int i = 0;
	for (; i < 3; i++) {
		fs >> (*deadarr)[i];
		fs.flush();
	}
}
void printstart() {
	cout << "*****    * * *   ***   *   *  *   *   ***      ***    ***     *****   ***     *****  *   *  *****   \033[32;1m* *  ***    * *\033[0m" << endl;
	cout << "  *      * * *  *   *  **  *  **  *  *   *    *      *   *      *    *   *      *    *   *  *     \033[32;1m * *  *      * *\033[0m " << endl;
	cout << "  *      * * *  *****  * * *  * * *  *****    *  **  *   *      *    *   *      *    *****  *****       \033[32;1m* ***\033[0m      " << endl;
	cout << "  *       * *   *   *  *  **  *  **  *   *    *   *  *   *      *    *   *      *    *   *  *           \033[32;1m*   *\033[0m      " << endl;
	cout << "*****     * *   *   *  *   *  *   *  *   *     ***    ***       *     ***       *    *   *  *****        \033[32;1m***\033[0m       " << endl;
}
int main() {
	char strmap[22][22] = {
		'G',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ','X','X','X',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ','*','X','*',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ','*','*','*',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','S',' ',
		'X','X','X','X','X','X','X','X','X','X','X','*','*','*','X','X','X','X','X','X','*',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',' ','S',
		'*','*','*','*','*','*','*','*','*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',' ',' ','*',
		' ',' ','X',' ',' ',' ',' ',' ',' ','*','X','*',' ',' ',' ',' ',' ','*',' ',' ',' ',' ',
		'G',' ',' ',' ',' ','X',' ',' ',' ',' ',' ',' ','*',' ',' ',' ',' ','*',' ',' ',' ',' ',
		'*','*','*','*','*','*','*',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ','*',' ',' ','X',' ',' ',' ',' ',' ',' ','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ','*','*','*','*','*',' ',' ',' ',' ','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','X','X',' ',' ',' ',' ',' ',' ',' ','*',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','X',' ',' ',' ','*','*','*','*',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ','X',' ',' ',' ','X',' ','*',' ',' ',' ',' ',' ',' ',
		' ','X','X','*','X','X','X',' ','X','X','X',' ','X','X','X','*','X','X','X','X','X','X',
	};
	char strmapr[22][22] = { 0 };
	memcpy(strmapr, strmap, sizeof strmap);
	Player p;
	char ch = 0;
	int itrap = -1;
	int ishoot = 0;
	int ibsv = 0;
	fstream fs("s.txt", ios::in);
	fs.flush();
	if ((!fs.is_open()) || fs.eof()) {
		fs.close();
		fs.open("s.txt", ios::out);
		fs << "0 0 0 0";
		fs.close();
		fs.open("s.txt", ios::in);
	}
	bool barr[3] = { 0 };
	fs >> ibsv;
	for (ch = 0; ch < 3; ch++) {
		barr[ch] = (ibsv & (1 << ch));
	}
	trigger t[23] = { trigger(20,3,20,3,0), trigger(16,5,16,6,1),trigger(19,12,20,12,2),trigger(17,13,17,13,3),trigger(17,15,17,16,3),trigger(14,14,14,15,3),trigger(13,16,13,17,3),trigger(15,18,15,19,3),trigger(11,20,11,21,4),trigger(3,21,3,21,5),trigger(0,16,9,16,6),trigger(8,11,9,13,7),trigger(4,5,7,9,8),trigger(9,6,9,8,9),trigger(3,1,3,3,10),trigger(11,1,11,1,11),trigger(11,3,11,3,12),trigger(13,1,14,1,13),trigger(13,7,15,8,14),trigger(15,11,17,11,15),trigger(16,12,17,12,16),trigger(21,13,21,13,17),trigger(11,8,11,8,18) };
	printstart();
	cout << endl << endl << endl << endl << endl << endl << endl << "\t\t\t\t\t  ";
	system("pause");
	system("cls");
	printstart();
	cout << endl << "              \033[31;1m********\033[0m                          \033[33m********\033[0m                              \033[32;1m********\033[0m" << endl;
	cout << "             \033[31;1m* SAVE 1 *\033[0m                        \033[33m* SAVE 2 *\033[0m                            \033[32;1m* SAVE 3 *\033[0m" << endl;
	cout << "              \033[31;1m********\033[0m                          \033[33m********\033[0m                              \033[32;1m********\033[0m" << endl << endl;
	cout << "游戏内：a左走    d右走    w二段跳，空中一段    z\033[33m存档\033[0m/射弹    r重开    \033[31;1m“X”死\033[0m   “*”墙    \033[31;1m“#”按钮\033[0m，\033[32;1m射就触发机关\033[0m    \033[33m“S”存档\033[0m    \033[32;1m“G”终点\033[0m" << endl <<  "开始界面：1~3选择要玩的存档    d删存档" << endl << endl << endl;
	cin >> ch;
	int deadarr[3] = { 0 };
	deadset(&deadarr, fs);
	while (ch < '1' || ch > '3') {
		while (rewind(stdin), 'd' != ch && (ch < '1' || ch > '3')) {
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
			cin >> ch;
		}
		cout << "\033[31;1m请输入要删除的存档编号(输入错误就不删除存档)\033[0m" << endl << endl;
		cin >> ch;
		if (rewind(stdin), ch < '1' || ch > '3') {
			cout << "\033[31;1m输入错误，不删除存档\033[0m" << endl << endl;
			cin >> ch;
			continue;
		}
		int index = ch - 1 - '0';
		(ibsv & (1 << index)) && (ibsv -= (1 << index));
		fs.close();
		fs.open("s.txt", ios::trunc | ios::out);
		deadarr[index] = 0;
		fs << ibsv;
		for (int i = 0; i < 3; i++) {
			fs << " " << deadarr[i];
		}
		cout << "\033[32m删除成功!\033[0m" << endl << endl;
		cin >> ch;
	}
	int barri = (--ch -= '0');
	system("cls");
	char* cp = (t[0].saveset(barr[barri]) ? &strmap[9][20] : &strmap[21][0]);
	*cp = 'P';
	fs << (char)(ibsv + '0');
	fs.flush();
	while ('G' == strmap[0][0]) {
		' ' == strmap[9][20] && (strmap[9][20] = 'S');
		' ' == strmap[11][21] && (strmap[11][21] = 'S');
		p.sgetxy(X) = (cp - &strmap[0][0]) / 22;
		p.sgetxy(Y) = (cp - &strmap[0][0]) % 22;
		p.printmap(strmap, deadarr[barri]);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.Djump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
			break;
		case 'r':
			p.reset(&cp, &strmap, &strmapr, &t, deadarr[barri]);
			break;
		default:
			break;
		}
		for (int i = 0; i < 23; i++) {
			t[i].check(p.sgetxy(X), p.sgetxy(Y), &strmap, &strmapr, p, itrap, &cp, ch, &t, deadarr[barri]);
		}
		itrap > 0 && itrap--, !itrap && (strmap[14][5] = ' ', strmap[15][5] = 'X');
		p.upOrDown(&cp);
		p.shootmove(&strmap, barri, ibsv);
		p.rejump(&cp);
		if ('X' == *cp) {
			p.gameover(&cp, &strmap, &strmapr, &t, deadarr[barri]);
		}
		*cp = 'P';
		ishoot > 0 && ishoot--;
		system("cls");
		fs.open("s.txt", ios::trunc | ios::out);
		fs << (char)(ibsv + '0');
		for (int i = 0; i < 3; i++) {
			fs << " " << deadarr[i];
		}
		fs.close();
	}
	system("color 0A");
	cout << "恭喜你，你赢了，似了" << deadarr[barri] << "次" << endl;
	fs.close();
	return 0;
}
*///“删档”^
/*
//Cmp.h
#pragma once
#include <iostream>
#include <vector>
#include "Player.h"
using namespace std;
class cmp {
public:
	bool operator()(trir t, trir ta);
};
//Cmp.cpp
#include <iostream>
#include <vector>
#include "Cmp.h"
#include "Player.h"
using namespace std;
bool cmp::operator()(trir t, trir ta) {
	return t.iy < ta.iy;
}
*///“函数对象”
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1
#include <iostream>
#include <cstring>
#include <fstream>
#include <cstdio>
#include "Player.h"
#include "trigger.h"
using namespace std;
void deadset(int (*deadarr)[3], fstream& fs) {
	int i = 0;
	for (; i < 3; i++) {
		fs >> (*deadarr)[i];
		fs.flush();
	}
}
void printstart() {
	cout << "*****    * * *   ***   *   *  *   *   ***      ***    ***     *****   ***     *****  *   *  *****   \033[32;1m* *  ***    * *\033[0m" << endl;
	cout << "  *      * * *  *   *  **  *  **  *  *   *    *      *   *      *    *   *      *    *   *  *     \033[32;1m * *  *      * *\033[0m " << endl;
	cout << "  *      * * *  *****  * * *  * * *  *****    *  **  *   *      *    *   *      *    *****  *****       \033[32;1m* ***\033[0m      " << endl;
	cout << "  *       * *   *   *  *  **  *  **  *   *    *   *  *   *      *    *   *      *    *   *  *           \033[32;1m*   *\033[0m      " << endl;
	cout << "*****     * *   *   *  *   *  *   *  *   *     ***    ***       *     ***       *    *   *  *****        \033[32;1m***\033[0m       " << endl;
}
int main() {
	system("title I WANNA GO TO THE \"G\"");
	char strmap[22][22] = {
		'G',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ','X','X','X',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ','*','X','*',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ','*','*','*',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','S',' ',
		'X','X','X','X','X','X','X','X','X','X','X','*','*','*','X','X','X','X','X','X','*',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',' ','S',
		'*','*','*','*','*','*','*','*','*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',' ',' ','*',
		' ',' ','X',' ',' ',' ',' ',' ',' ','*','X','*',' ',' ',' ',' ',' ','*',' ',' ',' ',' ',
		'G',' ',' ',' ',' ','X',' ',' ',' ',' ',' ',' ','*',' ',' ',' ',' ','*',' ',' ',' ',' ',
		'*','*','*','*','*','*','*',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ','*',' ',' ','X',' ',' ',' ',' ',' ',' ','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ','*','*','*','*','*',' ',' ',' ',' ','*',' ',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','X','X',' ',' ',' ',' ',' ',' ',' ','*',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','X',' ',' ',' ','*','*','*','*',' ',' ',' ',
		' ',' ',' ',' ',' ',' ',' ',' ',' ','X',' ',' ',' ','X',' ','*',' ',' ',' ',' ',' ',' ',
		' ','X','X','*','X','X','X',' ','X','X','X',' ','X','X','X','*','X','X','X','X','X','X',
	};
	char strmapr[22][22] = { 0 };
	memcpy(strmapr, strmap, sizeof strmap);
	Player p;
	char ch = 0;
	int itrap = -1;
	int ishoot = 0;
	int ibsv = 0;
	fstream fs("s.txt", ios::in);
	fs.flush();
	if ((!fs.is_open()) || fs.eof()) {
		fs.close();
		fs.open("s.txt", ios::out);
		fs << "0 0 0 0";
		fs.close();
		fs.open("s.txt", ios::in);
	}
	bool barr[3] = { 0 };
	fs >> ibsv;
	for (ch = 0; ch < 3; ch++) {
		barr[ch] = (ibsv & (1 << ch));
	}
	trigger t[23] = { trigger(20,3,20,3,0), trigger(16,5,16,6,1),trigger(19,12,20,12,2),trigger(17,13,17,13,3),trigger(17,15,17,16,3),trigger(14,14,14,15,3),trigger(13,16,13,17,3),trigger(15,18,15,19,3),trigger(11,20,11,21,4),trigger(3,21,3,21,5),trigger(0,16,9,16,6),trigger(8,11,9,13,7),trigger(4,5,7,9,8),trigger(9,6,9,8,9),trigger(3,1,3,3,10),trigger(11,1,11,1,11),trigger(11,3,11,3,12),trigger(13,1,14,1,13),trigger(13,7,15,8,14),trigger(15,11,17,11,15),trigger(16,12,17,12,16),trigger(21,13,21,13,17),trigger(11,8,11,8,18) };
	printstart();
	cout << endl << endl << endl << endl << endl << endl << endl << "\t\t\t\t\t  ";
	system("pause");
	system("cls");
	printstart();
	cout << endl << "              \033[31;1m********\033[0m                          \033[33m********\033[0m                              \033[32;1m********\033[0m" << endl;
	cout << "             \033[31;1m* SAVE 1 *\033[0m                        \033[33m* SAVE 2 *\033[0m                            \033[32;1m* SAVE 3 *\033[0m" << endl;
	cout << "              \033[31;1m********\033[0m                          \033[33m********\033[0m                              \033[32;1m********\033[0m" << endl << endl;
	cout << "游戏内：a左走    d右走    w二段跳，空中一段    z\033[33m存档\033[0m/射弹    r重开    \033[31;1m“X”死\033[0m   “*”墙    \033[31;1m“#”按钮\033[0m，\033[32;1m射就触发机关\033[0m    \033[33m“S”存档\033[0m    \033[32;1m“G”终点\033[0m" << endl <<  "开始界面：1~3选择要玩的存档    d删存档" << endl << endl << endl;
	cin >> ch;
	int deadarr[3] = { 0 };
	deadset(&deadarr, fs);
	while (ch < '1' || ch > '3') {
		while (rewind(stdin), (ch < '1' || ch > '3') && 'd' != ch) {
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
			cin >> ch;
			if (ch >= '1' && ch <= '3') {
				goto g;
			}
		}
		cout << "\033[31;1m请输入要删除的存档编号(输入错误就不删除存档)\033[0m" << endl << endl;
		cin >> ch;
		if (rewind(stdin), ch < '1' || ch > '3') {
			cout << "\033[31;1m输入错误，不删除存档\033[0m" << endl << endl;
			cin >> ch;
			continue;
		}
		int index = ch - 1 - '0';
		(ibsv & (1 << index)) && (ibsv -= (1 << index));
		fs.close();
		fs.open("s.txt", ios::trunc | ios::out);
		deadarr[index] = 0;
		fs << ibsv;
		for (int i = 0; i < 3; i++) {
			fs << " " << deadarr[i];
		}
		fs.flush();
		cout << "\033[32m删除成功!\033[0m" << endl << endl;
		cin >> ch;
	}
	g:
	int barri = (--ch -= '0');
	system("cls");
	char* cp = (t[0].saveset(barr[barri]) ? &strmap[9][20] : &strmap[21][0]);
	*cp = 'P';
	fs << (char)(ibsv + '0');
	fs.close();
	while ('G' == strmap[0][0]) {
		char str[100] = "title I WANNA GO TO THE \"G\" : 似亡 * ";
		char stra[100] = "";
		sprintf(stra, "%d", deadarr[barri]);
		strcat(str, stra);
		system(str);
		' ' == strmap[9][20] && (strmap[9][20] = 'S');
		' ' == strmap[11][21] && (strmap[11][21] = 'S');
		p.sgetxy(X) = (cp - &strmap[0][0]) / 22;
		p.sgetxy(Y) = (cp - &strmap[0][0]) % 22;
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.Djump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
			break;
		case 'r':
			p.reset(&cp, &strmap, &strmapr, &t, deadarr[barri]);
			break;
		default:
			break;
		}
		for (int i = 0; i < 23; i++) {
			t[i].check(p.sgetxy(X), p.sgetxy(Y), &strmap, &strmapr, p, itrap, &cp, ch, &t, deadarr[barri]);
		}
		itrap > 0 && itrap--, !itrap && (strmap[14][5] = ' ', strmap[15][5] = 'X');
		p.upOrDown(&cp);
		p.shootmove(&strmap, barri, ibsv);
		p.rejump(&cp);
		if ('X' == *cp) {
			p.gameover(&cp, &strmap, &strmapr, &t, deadarr[barri]);
		}
		*cp = 'P';
		ishoot > 0 && ishoot--;
		system("cls");
		fs.open("s.txt", ios::trunc | ios::out);
		fs << (char)(ibsv + '0');
		for (int i = 0; i < 3; i++) {
			sprintf(str, "%d", deadarr[i]);
			fs << " " << str;
		}
		fs.close();
	}
	system("color 0A");
	cout << "恭喜你，你赢了，似了" << deadarr[barri] << "次" << endl;
	fs.close();
	return 0;
}
//Cmp.h
#pragma once
#include <iostream>
#include <vector>
#include "Player.h"
using namespace std;
class cmp {
public:
	bool operator()(trir t, trir ta);
};
//Cmp.cpp
#include <iostream>
#include <vector>
#include "Cmp.h"
#include "Player.h"
using namespace std;
bool cmp::operator()(trir t, trir ta) {
	return t.iy < ta.iy;
}
//Player.h
#pragma once
#include <iostream>
#include <vector>
#include "trigger.h"
using namespace std;
#define JUMPHIGH 3
enum XY {
	X,
	Y,
};
struct trir {
	char* cp;
	bool b;
	int iy;
};
class Player {
private:
	int ix;
	int iy;
	int ijh;
	int ij;
	bool blr;
	vector<trir> v;
public:
	friend class trigger;
	Player();
	void printmap(const char strmap[22][22]);
	void Djump(char** cpp);
	void left_move(char** cpp);
	void right_move(char** cpp);
	int& sgetxy(XY xymode);
	void upOrDown(char** cpp);
	void gameover(char** cpp, char(*strmap)[22][22], const char(*strmapr)[22][22], trigger(*tarr)[23], int& idead);
	void reset(char** cpp, char(*strmap)[22][22], const char(*strmapr)[22][22], trigger(*tarr)[23], int& idead);
	void rejump(char** cp);
	void shoot(int& i, char** cpp);
	void shootmove(const char (*strmap)[22][22], int barri, int& ibsv);
};
//Player.cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <fstream>
#include "trigger.h"
#include "Player.h"
#include "Cmp.h"
using namespace std;
Player::Player(){
	ij = 2;
	ijh = 0;
	blr = 1;
}
bool MSB = false;
bool MSBa = false;
bool MSBb = false;
bool MSBc = false;
bool MSv = false;
void Player::printmap(const char strmap[22][22]) {
	int i = 0;
	int ia = 0;
	for (; i < 22; i++) {
		for (ia = 0; ia < 22; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : 'X' == strmap[i][ia] ? "31;1m" : '#' == strmap[i][ia] ? trigger::MSB ? "32;1m" : "31;1m" : 'S' == strmap[i][ia] ? ((!trigger::MSv) || 21 == ia) ? "33m" : "33;1m" : '@' == strmap[i][ia] ? "33m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "----------------------@" << endl;
}
void Player::Djump(char** cpp) {
	switch (ij) {
	case 2:
		((21 == ix || '*' == (*cpp)[22] || '#' == (*cpp)[22]) && (ij = 1, ijh = JUMPHIGH), (21 != ix && '*' != (*cpp)[22] && '#' != (*cpp)[22]) && (ij = 0, ijh = JUMPHIGH));
		break;
	case 1:
		((21 == ix || '*' == (*cpp)[22] || '#' == (*cpp)[22]) && (ij = 2), (21 != ix && '*' != (*cpp)[22] && '#' != (*cpp)[22]) && (ij = 0, ijh = JUMPHIGH));
		break;
	default:
		rejump(cpp);
		((21 == ix || '*' == (*cpp)[22] || '#' == (*cpp)[22]) && (ij = 1, ijh = JUMPHIGH), (21 != ix && '*' != (*cpp)[22] && '#' != (*cpp)[22]) && (ij = 0));
		break;
	}
}
void Player::left_move(char** cpp) {
	(iy && '*' != *(*cpp - 1) && '#' != *(*cpp - 1) && ((*cpp)--));
	blr = false;
}
void Player::right_move(char** cpp) {
	21 != iy && '*' != *(*cpp + 1) && '#' != *(*cpp + 1) && ((*cpp)++);
	blr = true;
}
int& Player::sgetxy(XY xymode) {
	return xymode ? iy : ix;
}
void Player::upOrDown(char** cpp) {
	if (ijh > 0 && ix && '*' != (*cpp)[-22] && '#' != (*cpp)[-22]) {
		ijh--, *cpp -= 22;
	}
	else if ('*' != (*cpp)[22] && '#' != (*cpp)[22] && (!ix || '*' == (*cpp)[-22] || '#' == (*cpp)[-22])) {
		ijh = 0, *cpp += 22;
	}
	else if ('*' != (*cpp)[22] && '#' != (*cpp)[22] && 21 != ix) {
		*cpp += 22;
	}
}
void Player::gameover(char** cpp, char (*strmap)[22][22], const char (*strmapr)[22][22], trigger(*tarr)[23], int& idead) {
	char ch = 0;
	system("cls");
	' ' == (*strmap)[9][20] && ((*strmap)[9][20] = 'S');
	printmap(*strmap);
	cout << "\033[31;1m游戏结束 请按r键重新开始\033[0m" << endl;
	while (ch - 'r') {
		cin >> ch;
		rewind(stdin);
		system("cls");
		if (ch - 'r') {
			printmap(*strmap);
			cout << "\033[31;1m游戏结束 请按r键重新开始\033[0m" << endl;
		}
	}
	reset(cpp, strmap, strmapr, tarr, idead);
}
void Player::reset(char** cpp, char(*strmap)[22][22], const char(*strmapr)[22][22], trigger(*tarr)[23], int& idead) {
	idead++;
	trigger::MSv && (*cpp = &((*strmap)[9][20]), ix = 9, iy = 20), trigger::MSv || (*cpp = &((*strmap)[21][0]), ix = 21, iy = 0);
	trigger::MSB = false;
	MSBa = false;
	MSBb = false;
	MSBc = false;
	blr = true;
	int i = 0;
	memcpy(*strmap, *strmapr, sizeof(*strmapr));
	for (; i < 23; i++) {
		(*tarr)[i].MBt = false;
	}
	v.clear();
	rejump(cpp);
}
void Player::rejump(char** cpp) {
	(21 == ix || '*' == (*cpp)[22]) && (ij = 2);
}
void Player::shoot(int& i, char** cpp) {
	if ((!i) && (iy && blr || 21 != iy && (!blr))) {
		v.push_back({*cpp, blr, iy});
		i = 3;
	}
}
void Player::shootmove(const char(*strmap)[22][22], int barri, int& ibsv) {
	for (vector<trir>::iterator it = v.begin();v.end()!=it;it++) {
		(' ' == *it->cp || '@' == *it->cp) && (*it->cp = ' ');
		'#' == *it->cp && (trigger::MSB = true);
		if (&((*strmap)[9][20]) == it->cp) {
			trigger::MSv = true;
			(!(ibsv & (1 << barri))) && (ibsv += (1 << barri));
		}
		if ('*' == *it->cp || '#' == *it->cp || (!it->iy && (!it->b)) || (21 == it->iy && it->b)) {
			it->iy = -1;
		}
		if (0 <= it->iy) {
			it->cp -= (1 - it->b * 2);
			it->iy -= (1 - it->b * 2);
			(' ' == *it->cp || '@' == *it->cp) && (*it->cp = '@');
		}
	}
	sort(v.begin(), v.end(), cmp());
	while ((!v.empty()) && 0 > v.begin()->iy) {
		v.erase(v.begin());
	}
}
//trigger.h
#pragma once
#include <iostream>
#include "Player.h"
using namespace std;
class trigger {
private:
	int MISX;
	int MISY;
	int MIEX;
	int MIEY;
	int Mtrig;
	bool MBt;
	static bool MSB;
	static bool MSBa;
	static bool MSBb;
	static bool MSBc;
	static bool MSv;
public:
	friend class Player;
	trigger(int istartx, int istarty, int iendx, int iendy, int trig) :MISY(istarty), MIEX(iendx), MIEY(iendy), MISX(istartx), Mtrig(trig), MBt(false) {}
	void check(int ix, int iy, char(*strmap)[22][22], const char(*strmapr)[22][22], Player& p, int& ii, char** cpp, char ch, trigger(*tarr)[23], int& idead);
	bool saveset(bool b);
};
//trigger.cpp
#include <iostream>
#include "trigger.h"
#include <string>
#include "Player.h"
using namespace std;
bool trigger::MSB = false;
bool trigger::MSBa = false;
bool trigger::MSBb = false;
bool trigger::MSBc = false;
bool trigger::MSv = false;
void trigger::check(int ix, int iy, char (*strmap)[22][22], const char (*strmapr)[22][22],Player& p, int& ii, char** cpp, char ch, trigger(*tarr)[23], int& idead) {
	int i = 0;
	if (MISX <= ix && ix <= MIEX && MISY <= iy && iy <= MIEY && (Mtrig - 4 && Mtrig - 8 && Mtrig - 16 && Mtrig - 18 ? (!MBt) : 1)) {
		switch (MBt = true, Mtrig) {
		case 0:
			(*strmap)[21][3] = 'X';
			p.gameover(cpp, strmap, strmapr, tarr, idead);
			break;
		case 1:
			for (i = 16; i < 21; i++) {
				(*strmap)[i][6] = 'X';
			}
			break;
		case 2:
			for (i = 18; i < 22; i++) {
				if ('X' == (*strmap)[i][13]) {
					(*strmap)[i][13] = ' ';
				}
				else {
					(*strmap)[i][13] = 'X';
				}
			}
			break;
		case 3:
			for (i = MISX; i <= MIEX; i++) {
				for (int ia = MISY; ia <= MIEY; ia++) {
					(*strmap)[i][ia] = 'X';
				}
			}
			p.gameover(cpp, strmap, strmapr, tarr, idead);
			break;
		case 4:
			if ('z' == ch) { 
				(*strmap)[13][19] = 'L';
				(*strmap)[13][20] = 'O';
				(*strmap)[13][21] = 'L';
				p.gameover(cpp, strmap, strmapr, tarr, idead);
			}
			break;
		case 5:
			break;
		case 6:
			if (!MSB) {
				for (i = 0; i < 10; i++) {
					(*strmap)[i][15] = 'X';
				}
			}
			break;
		case 7:
			for (i = 8; i < 10; i++) {
				(*strmap)[i][10] = '*';
				(*strmap)[i][14] = '*';
			}
			for (; i < 15; i++) {
				(*strmap)[7][i] = '*';
			}
			break;
		case 8:
			((!MSBa) && '*' == (*cpp)[22]) && ((*cpp)[22] = 'X');
			break;
		case 9:
			MSBa = true;
			for (i = 6; i < 9; i++) {
				(*strmap)[10][i] = '*';
			}
			break;
		case 10:
			for (i = 1; i < 4; i++) {
				(*strmap)[4][i] = '*';
			}
			break;
		case 11:
		{ 
			string str = "LOL LOL"; 
			char* cpa = &((*strmap)[11][2]);
			char* cpb = &(str[0]);
			for (i = 0; i < 7; i++, cpa++, cpb++) {
				*cpa = *cpb;
			}
			MSBb = true;
		}
		break;
		case 12:
			(*strmap)[11][0] = 'G';
			(*strmap)[14][0] = ' ';
			break;
		case 13:
			(*strmap)[11][0] = 'G';
			(*strmap)[13][0] = ' ';
			(*strmap)[13][5] = 'X';
			(*strmap)[13][2] = ' ';
			(*strmap)[15][5] = '*';
			for (i = 16; i < 21; i++) {
				(*strmap)[i][0] = 'L';
				(*strmap)[i][1] = 'O';
				(*strmap)[i][2] = 'L';
			}
			break;
		case 14:
			ii = 10;
			break;
		case 15:
			MSBc = true;
			for (i = 10; i < 13; i++) {
				(*strmap)[14][i] = 'X';
			}
			(*strmap)[13][10] = '*';
			for (i = 0; i < 11; i++) {
				(*strmap)[10][i] = '*';
			}
			if (*cpp == &((*strmap)[14][12])) {
				p.gameover(cpp, strmap, strmapr, tarr, idead);
			}
			break;
		case 16:
			if (MSBc) {
				(*strmap)[14][10] = ' ';
				(*strmap)[14][11] = ' ';
				'*' == (*cpp)[11] && ((*cpp)[11] = 'X');
			}
			break;
		case 17:
			(*strmap)[21][13] = 'X';
			break;
		case 18:
			if (MSBb) {
				*cpp = &((*strmap)[11][7]);
				(*strmap)[11][8] = '*';
				MSBb = false;
			}
			break;
		default:
			break;
		}
	}
}
bool trigger::saveset(bool b) {
	MSv = b;
	return MSv;
}
*///“C++版iwanna完成”
/*
int main() {
	char str[100] = "123";
	cout << atoi(str)+1 << endl;
	return 0;
}
*///“atoi函数”^
/*
int main() {
	char str[100] = "123999999";
	cout << atol(str)+1 << endl;
	return 0;
}
*///“atol函数”^
/*
//Game.cpp
#include <iostream>
#include "Player.h"
using namespace std;
int main() {
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	Player p;
	char ch = 0;
	//system("pause");
	//system("cls");
	char* cp = &strmap[9][0];
	*cp = 'P';
	while (1 || 'G' == strmap[0][0]) {
		p.sgetxy(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxy(Y) = (cp - &strmap[0][0]) % 11;
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot();
		default:
			break;
		}
		p.upOrDown(&cp);
		*cp = 'P';
		system("cls");
	}
	system("color 0A");
	cout << "恭喜你，你赢了" << endl;
	return 0;
}
//Player.h
#pragma once
#include <iostream>
#include <vector>
#include "trigger.h"
using namespace std;
#define JUMPHIGH 3
enum XYH {
	X,
	Y,
	HEAL
};
struct trir {
	char* cp;
	bool b;
	int iy;
};
class Player {
private:
	int ix;
	int iy;
	int ijh;
	int iheal;
	bool blr;
	vector<trir> v;
public:
	Player();
	void printmap(const char strmap[11][11]);
	void jump(char** cpp);
	void left_move(char** cpp);
	void right_move(char** cpp);
	int& sgetxyh(XYH xyhmode);
	void upOrDown(char** cpp);
	void gameover();
	void reset();
	void shoot();
	void shootmove();
};
//Player.cpp
#include <iostream>
#include "Player.h"
using namespace std;
Player::Player(){
	ijh = 0;
	blr = 1;
}
void Player::printmap(const char strmap[11][11]) {
	int i = 0;
	int ia = 0;
	for (; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : 'v' == strmap[i][ia] ? "36m" : '&' == strmap[i][ia] || 'o' == strmap[i][ia] || 'O' == strmap[i][ia] || 'X' == strmap[i][ia] ? "31;1m" : '+' == strmap[i][ia] ? "33m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
void Player::jump(char** cpp) {
	10 == ix || '*' == (*cpp)[11] && (ijh = JUMPHIGH);
}
void Player::left_move(char** cpp) {
	(iy && '*' != *(*cpp - 1) && ((*cpp)--));
	blr = false;
}
void Player::right_move(char** cpp) {
	10 != iy && '*' != *(*cpp + 1) && ((*cpp)++);
	blr = true;
}
int& Player::sgetxyh(XYH xyhmode) {
	switch (xyhmode) {
	case X:
		return ix;
	case Y:
		return iy;
	default:
		return iheal;
	}
}
void Player::upOrDown(char** cpp) {
	if (ijh > 0 && ix && '*' != (*cpp)[-11]) {
		ijh--, *cpp -= 11;
	}
	else if ('*' != (*cpp)[11] && !ix || '*' == (*cpp)[-11]) {
		ijh = 0, *cpp += 11;
	}
	else if ('*' != (*cpp)[11] && 10 != ix) {
		*cpp += 11;
	}
}
void Player::gameover() {

}
void Player::reset() {

}
void Player::shoot() {

}
void Player::shootmove() {

}
*///“C++打小怪游戏始版”
/*
//moster.h
#pragma once
#include <iostream>
using namespace std;
class moster {
protected:
	char* mcp;
	int m_iheal;
public:
	virtual void mosterdo() = 0;
};
*///“纯虚函数”^
/*
//M^.h
#pragma once
#include <iostream>
#include "moster.h"
using namespace std;
class MUD : public moster {
private:
	bool mblr;
	bool mbud;
public:
	MUD(bool b, bool ba);
	void mosterdo();
};
//M^.cpp
#include <iostream>
using namespace std;
#include "m^.h"
MUD::MUD(bool b, bool ba) {
	mblr = b;
	mbud = ba;
}
void MUD::mosterdo() {
	' ' == **m_cpp && (mbud && (**m_cpp = 'v'), mbud && (**m_cpp = '^'));//使见
	'*' == (*m_cpp)[-1] && (mblr = 1), '*' == (*m_cpp)[1] && (mblr = 0);//撞墙换方向
	m_cpp -= (1 - 2 * mblr);//左右移
	'*' == (*m_cpp)[11] && (mbud = 0), '*' == (*m_cpp)[-11] && (mbud = 1);//碰地会反转
	m_cpp -= 11 * (1 - 2 * mbud);//上下落
}//撞墙换方向，碰地会反落
*///“M^”完成^
/*
//MO.cpp
#include <iostream>
#include "MO.h"
using namespace std;
MO::MO(WASD wasd, map<char*, WASD>m) {
	m_wasd = wasd;
	m_m = m;
}
void MO::mosterdo() {
	if (!m_m.empty()) {
		int arr[4] = { -11,-1,11,1 };
		for (map<char*, WASD>::iterator it = m_m.begin(); m_m.end() != it; it++) {
			*m_cpp == it->first && (m_wasd = it->second);
		}
		*m_cpp += (arr[m_wasd]);
	}
	else {
		if ()
	}
}//遇向则转，看路前行（1），或追玩者（2）
//MO.h
#pragma once
#include <iostream>
#include <map>
#include "moster.h"
using namespace std;
enum WASD {
	W,
	A,
	S,
	D
};
class MO : public moster {
private:
	WASD m_wasd;
	map<char*, WASD>m_m;//[strmap point, wasd]...
public:
	MO(WASD wasd, map<char*, WASD>m);
	void mosterdo();
};
*///“MO”第一部分完成^
/*
//MO.cpp
#include <iostream>
#include "MO.h"
#define NNEG(A, B) ((A) < (B) ? 1 : (A) > (B) ? -1 : 0)
using namespace std;
pair<int, int> s_m_pxy;
void MO::exset(pair<int, int>& pxy, int ix, int iy) {
	pxy.first = ix;
	pxy.second = iy;
}
void MO::mosterdo() {
	if (!m_m.empty()) {
		int arr[8] = { -11,-1,11,1 };
		for (map<char*, WASD>::iterator it = m_m.begin(); m_m.end() != it; it++) {
			*m_cpp == it->first && (m_wasd = it->second);
		}
		switch (*m_cpp += (arr[m_wasd]), m_wasd) {
		case W:
			m_pxy.second--;
			break;
		case A:
			m_pxy.first--;
			break;
		case S:
			m_pxy.second++;
			break;
		case D:
			m_pxy.first++;
			break;
		default:
			break;
		}
	}
	else {
		*m_cpp += NNEG(m_pxy.first, s_m_pxy.first);
		*m_cpp += 11 * NNEG(m_pxy.second, s_m_pxy.second);
		m_pxy.first += NNEG(m_pxy.first, s_m_pxy.first);
		m_pxy.second -= NNEG(m_pxy.second, s_m_pxy.second);
	}
}//遇向则转，看路前行（1），或追玩者（2）
void MO::set_s_pxy(int ix, int iy) {
	s_m_pxy = { ix, iy };
}
*///“MO”第二部分完成^
/*
//moster.cpp#include <iostream>
#include "moster.h"
using namespace std;
void moster::set(vector<trir> v) {
	m_v = v;
}
void moster::hude() {
	for (vector<trir>::iterator it; m_v.end() != it; it++) {
		*m_cpp == it->cp && m_iheal--;
	}//检测扣血
	m_iheal || 1;//检测死亡(1 = 未做)
}
*///“怪物扣血”^
/*
//mosters.h
#pragma once
#include <iostream>
using namespace std;
#include "moster.h"
#include "m_o.h"
#include "m&.h"
#include "m^.h"
#include "mO.h"
#include "m+.h"
#include "mX.h"
*///“头文件包含”
/*
//mosters.h
#pragma once
#include <iostream>
using namespace std;
#include "moster.h"
#include "m_o.h"
#include "m&.h"
#include "m^.h"
#include "mO.h"
#include "m+.h"
#include "mX.h"
*///“头文件包含”^
/*
//M_o.cpp
#include <iostream>
#include <ctime>
#include <cstdlib>
#include "M_o.h"
using namespace std;
void M_o::near() {
	int arr[8] = { -12, -11, -10, -1, 1, -10, -11, -12 };
	int i = 0;
	for (; i < 8; i++) {
		if ('*' == (*m_cpp)[arr[i]]) {
			m_iheal = -1;
		}
	}
}
void M_o::mosterdo() {
	**m_cpp = ' ';
    switch (rand() % 8) {//随便移动
	case 0:
		'*' != *m_cpp[-12] && ((*m_cpp) -= 12);
		break;
	case 1:
		'*' != *m_cpp[-11] && ((*m_cpp) -= 11);
		break;
	case 2:
		'*' != *m_cpp[-10] && ((*m_cpp) -= 10);
		break;
	case 3:
		'*' != *m_cpp[-1] && ((*m_cpp)--);
		break;
	case 4:
		'*' != *m_cpp[1] && ((*m_cpp)++);
		break;
	case 5:
		'*' != *m_cpp[11] && ((*m_cpp) += 11);
		break;
	case 6:
		'*' != *m_cpp[12] && ((*m_cpp) += 12);
		break;
	case 7:
		'*' != *m_cpp[13] && ((*m_cpp) += 13);
		break;
	default:
		break;
	}
    **m_cpp = 'o';
}//随便移动，有墙不动
*///“M_o”完成构造^
/*
//M+.cpp
#include <iostream>
using namespace std;
#include "m+.h"
#include "M_o.h"
void Mplus::mosterdo() {
	**m_cpp = '+';
}
void summon(vector<pair<int, vector<moster*>>>& vpm, int i) {
	M_o o;
	vpm[i].second.push_back(&o);
}
//M+.h
#pragma once
#include <iostream>
#include "moster.h"
#include <vector>
using namespace std;
class Mplus : public moster {
public:
	void summon(vector<pair<int, vector<moster*>>>& vpm, int i);//生成
	void mosterdo();
};
*///“M+”完成构造^
/*
//MX.cpp
#include <iostream>
using namespace std;
#include "mX.h"
void MX::mosterdo() {
	vector<trir>::iterator it = m_v->begin();
	for (; m_v->end() != it; it++) {
		if (*m_cpp == it->cp) {
			break;
		}
	}
	if (*m_cpp == m_cp || m_v->end() != it) {
		do {
			**m_cpp = chs;//还原
			*m_cpp = &((*m_strmap)[rand() % 9 + 1][rand() % 9 + 1]);
			chs = **m_cpp;//记砖
		} while ('*' == (*m_cpp)[-1] && '*' == (*m_cpp)[1]);
	}
	**m_cpp = 'X';//使见
}//被玩家碰到传，受伤传(两旁有砖不传)，并见
//MX.h
#pragma once
#include <iostream>
#include "moster.h"
using namespace std;
class MX : public moster {
private:
	char*& m_cp;//玩家的地点，不用xy坐标
	char(*m_strmap)[11][11];
	char chs;
public:
	MX(char*& cp, char(*strmap)[11][11]) : m_cp(cp), m_strmap(strmap), chs(**m_cpp) {};
	void mosterdo();
};
*///所有怪物已完成构造^
/*
//Game.cpp
#include <iostream>
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
using namespace std;
void MDoAndHunt(moster* mp) {
	mp->hunt();
	mp->mosterdo();
}
void del(moster* mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	int i = 0;
	Player p;
	char* cp = &strmap[9][0];
	map<char*, WASD>m;
	vector<moster*>mpv = { new Mand(), new Mand(), new Mand(), new M_o(), new MUD(), new MO(), new MX(), new Mplus()};//mpv里一共要有的怪物们
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[3] = { &strmap[5][1], &strmap[5][9], &strmap[3][4]};
	//随机设置地牢布置与怪物布置
	for (; ch < 10; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		switch (ch) {
		case 0:
			for (vism[ch].str = "&&&"; i < 3; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp[i]->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 1:
			//未完成

			break;
		case 2:
			//未完成

			break;
		case 3:
			//未完成

			break;
		case 4:
			//未完成

			break;
		case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
	p.sgetxyhs(HEAL) = 3;//设置默认生命值
	int ishoot = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && bb && 'P' != strmap[9][10]) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && &strmap[9][1] == cp) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 0:
			{
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
			}
				break;
			case 1:
				//未完成

				break;
			case 2:
				//未完成

				break;
			case 3:
				//未完成

				break;
			case 4:
				//未完成

				break;
			case 5:
				//未完成

				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

				break;
			default:
				break;
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcpp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		p.shootmove(&strmap);
		ishoot > 0 && ishoot--;
		//怪物做
		if (b) {
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MDoAndHunt);
		}
		//有怪物使你扣血
		' ' == *cp || p.sgetxyhs(HEAL)--, ' ' == *cp && (*cp = 'P');
		//没血使怪物死亡
		sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
		while (vism.front().vmp.front()->getheal() < 1) {
			if (-1 == vism.front().vmp.front()->getheal()) {
				int ir = 0;
				//转换成其他怪物
				switch (ir = rand() % 4) {
				case 0:
					mpv.push_back(new Mand());
					break;
				case 1:
					mpv.push_back(new MO());
					break;
				case 2:
					mpv.push_back(new MX());
					break;
				case 3:
					mpv.push_back(new MUD());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv.back());
				char* cpa = NULL;
				int mx = 0;
				int my = 0;
				while (' ' == *cpa) {
					cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
				}
				switch (ir) {
				case 0:
					vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
					break;
				case 1:
					vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
					break;
				case 2:
					vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, mx, my);//怪物“O”
					break;
				case 3:
					vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, &cp, &strmap);//怪物“X”
					break;
				default:
					break;
				}
			}
			vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
		}
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty()) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“地牢与怪物的布置”^
/*
//M&.cpp
#include <iostream>
using namespace std;
#include "m&.h"
Mand::Mand() {
	this->set();
}
//vector<trir>* = NULL, char** = NULL, char** = NULL, pair<int, int>* = NULL, int = 0, int = 0, int = 3, bool = 0, bool = 0
void Mand::set(vector<trir>* v, char** cpp, int iheal, char**, char(*)[11][11], int, int, bool b, bool) {
	m_v = v;
	m_cpp = cpp;
	m_iheal = iheal;
	mblr = b;
}
void Mand::mosterdo() {
	**m_cpp = ' ';
	if (!mblr && '*' == (*m_cpp)[-1]) {
		mblr = 1;
	}
	else if (mblr && '*' == (*m_cpp)[1]) {
		mblr = 0;
	}//撞墙换方向
	(*m_cpp) -= (1 - 2 * mblr);//左右移
	'*' != (*m_cpp)[11] && ((*m_cpp) += 11);//下落
	**m_cpp = '&';//使见
}//撞墙换方向，会自然下落
*///“‘M&’正式死亡”^
/*
//Game.cpp
#include <iostream>
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
using namespace std;
//#define DEBUG
void MDoAndHunt(moster* mp) {
	mp->hunt();
	mp->mosterdo();
}
void del(moster* mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	int i = 0;
	Player p;
	char* cp = &strmap[9][0];
	map<char*, WASD>m;
	vector<moster*>mpv = { new Mand(), new Mand(), new Mand(), new M_o(), new MUD(), new MO(), new MX(), new Mplus()};//mpv里一共要有的怪物们
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[3] = { &strmap[5][1], &strmap[5][9], &strmap[3][4]};
	//随机设置地牢布置与怪物布置
	for (; ch < 10; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		switch (ch) {
		case 0:
			for (vism[ch].str = "&&&"; i < 3; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp[i]->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 1:
			//未完成

			break;
		case 2:
			//未完成

			break;
		case 3:
			//未完成

			break;
		case 4:
			//未完成

			break;
		case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && bb && 'P' != strmap[9][10]) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && &strmap[9][1] == cp) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 0:
			{
				for (ch = 2; ch < 5; ch++) {
#ifndef DEBUG
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
#else
					strmap[7][ch] = '*';
					strmap[7][ch + 3] = '*';
					strmap[7][ch + 6] = '*';
					strmap[4][ch + 1] = '*';
#endif
				}
			}
				break;
			case 1:
				//未完成

				break;
			case 2:
				//未完成

				break;
			case 3:
				//未完成

				break;
			case 4:
				//未完成

				break;
			case 5:
				//未完成

				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

				break;
			default:
				break;
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcpp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		ishoot > 0 && ishoot--;
		p.shootmove(&strmap, 1);//子弹删
		//怪物动
		if (b && ' ' != strmap[9][10]) {
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MDoAndHunt);
		}
		//有怪物使你扣血
		' ' == *cp || cout << (p.sgetxyhs(HEAL)--, "\a"), ' ' == *cp && (*cp = 'P');
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism[ch].vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					while (' ' == *cpa) {
						cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
					}
					switch (ir) {
					case 0:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个空格，那么设怪物所在的位置为空格
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		p.shootmove(&strmap, 0);
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“启用DEBUG功能”^
/*
//Game.cpp
#include <iostream>
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
using namespace std;
#define DEBUG
void MDoAndHunt(moster* mp) {
	mp->hunt();
	mp->mosterdo();
}
void del(moster* mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	int i = 0;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char*, WASD>m;
	vector<moster*>mpv = { new Mand(), new Mand(), new Mand(), new M_o(), new MUD(), new MO(), new MX(), new Mplus()};//mpv里一共要有的怪物们
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[3] = { &strmap[5][1], &strmap[5][9], &strmap[3][4]};
	//随机设置地牢布置与怪物布置
	for (; ch < 10; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		switch (ch) {
		case 0:
			for (vism[ch].str = "&&&"; i < 3; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp[i]->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 1:
			//未完成

			break;
		case 2:
			//未完成

			break;
		case 3:
			//未完成

			break;
		case 4:
			//未完成

			break;
		case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && &strmap[9][1] == cp) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 0:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 1:
				//未完成

				break;
			case 2:
				//未完成

				break;
			case 3:
				//未完成

				break;
			case 4:
				//未完成

				break;
			case 5:
				//未完成

				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

				break;
			default:
				break;
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		ishoot > 0 && ishoot--;
		p.shootmove(&strmap, 1);//子弹删
		//有怪物使你扣血
		' ' == *cp || cout << (p.sgetxyhs(HEAL)--, "\a"), ' ' == *cp && (*cp = 'P');
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism[ch].vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					while (' ' == *cpa) {
						cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
					}
					switch (ir) {
					case 0:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		//怪物动
		if (b && ' ' != strmap[9][10]) {
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MDoAndHunt);
		}
		p.shootmove(&strmap, 0);
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“地牢部分已完善”^
/*
//Game.cpp
#include <iostream>
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
using namespace std;
#define DEBUG
void MDoAndHunt(moster* mp) {
	mp->hunt();
	mp->mosterdo();
}
void del(moster* mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	int i = 0;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char*, WASD>m;
	vector<moster*>mpv = {new MUD(), new MUD(), new Mand(), new Mand(), new Mand()};//mpv里一共要有的怪物们
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[5] = { &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][9], &strmap[9][1]};
	//随机设置地牢布置与怪物布置
	for (; ch < 10; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 1:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp[3 - (itemp - i)]->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 0:
			for (itemp = i + 2, vism[ch].str = "^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp[2 - (itemp - i)]->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			//未完成

			break;
		case 3:
			//未完成

			break;
		case 4:
			//未完成

			break;
		case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && &strmap[9][1] == cp) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 1:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 0:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
				//未完成

				break;
			case 3:
				//未完成

				break;
			case 4:
				//未完成

				break;
			case 5:
				//未完成

				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

				break;
			default:
				break;
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		ishoot > 0 && ishoot--;
		p.shootmove(&strmap, 1);//子弹删
		//有怪物使你扣血
		' ' == *cp || cout << (p.sgetxyhs(HEAL)--, "\a"), ' ' == *cp && (*cp = 'P');
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism[ch].vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					while (' ' == *cpa) {
						cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
					}
					switch (ir) {
					case 0:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		//怪物动
		if (b && ' ' != strmap[9][10]) {
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MDoAndHunt);
		}
		p.shootmove(&strmap, 0);
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“M^”测试^
/*
//Game.cpp
#include <iostream>
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
using namespace std;
#define DEBUG
void MDoAndHunt(moster* mp) {
	mp->hunt();
	mp->mosterdo();
}
void del(moster* mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	int i = 0;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char*, WASD>m;
	vector<moster*>mpv = {new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), };//mpv里一共要有的怪物们
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[7] = { &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], };//请注意先后顺序，否则会出bug
	//随机设置地牢布置与怪物布置
	for (; ch < 10; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 0:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp[3 - (itemp - i)]->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp[4 - (itemp - i)]->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			//未完成

			break;
		case 3:
			//未完成

			break;
		case 4:
			//未完成

			break;
		case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && &strmap[9][1] == cp) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 0:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 1:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
				//未完成

				break;
			case 3:
				//未完成

				break;
			case 4:
				//未完成

				break;
			case 5:
				//未完成

				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

				break;
			default:
				break;
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		ishoot > 0 && ishoot--;
		p.shootmove(&strmap, 1);//子弹删
		//有怪物使你扣血
		' ' == *cp || cout << (p.sgetxyhs(HEAL)--, "\a"), ' ' == *cp && (*cp = 'P');
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism[ch].vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					while (' ' == *cpa) {
						cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
					}
					switch (ir) {
					case 0:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		//怪物动
		if (b && '*' == strmap[9][10]) {
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MDoAndHunt);
		}
		p.shootmove(&strmap, 0);
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“M^”测试已完成^
/*
//Game.cpp
#include <iostream>
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
using namespace std;
#define DEBUG
void MDoAndHunt(moster* mp) {
	mp->hunt();
	mp->mosterdo();
}
void MShow(moster* mp) {
	*mp->getcp() = mp->getm();
}
void del(moster* mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	int i = 0;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char*, WASD>m;
	vector<moster*>mpv = {new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), };//mpv里一共要有的怪物们
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[7] = { &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], };//请注意先后顺序，否则会出bug
	//随机设置地牢布置与怪物布置
	for (; ch < 10; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 0:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp[3 - (itemp - i)]->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp[4 - (itemp - i)]->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			//未完成

			break;
		case 3:
			//未完成

			break;
		case 4:
			//未完成

			break;
		case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && &strmap[9][1] == cp) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 0:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 1:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
				//未完成

				break;
			case 3:
				//未完成

				break;
			case 4:
				//未完成

				break;
			case 5:
				//未完成

				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

				break;
			default:
				break;
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		ishoot > 0 && ishoot--;
		p.shootmove(&strmap, 1);//子弹删
		//有怪物使你扣血
		' ' == *cp || cout << (p.sgetxyhs(HEAL)--, "\a"), ' ' == *cp && (*cp = 'P');
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism[ch].vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					while (' ' == *cpa) {
						cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
					}
					switch (ir) {
					case 0:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		//怪物动
		if (b && '*' == strmap[9][10]) {
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MDoAndHunt);
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		p.shootmove(&strmap, 0);
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“已解决显示不完全bug”^
/*
//Game.cpp
#include <iostream>
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
using namespace std;
#define DEBUG
void MDoAndHunt(moster* mp) {
	mp->hunt();
	mp->mosterdo();
}
void MShow(moster* mp) {
	*mp->getcp() = mp->getm();
}
void del(moster* mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	int i = 0;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char*, WASD>m;
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[7] = { &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], };//请注意先后顺序，否则会出bug
	vector<moster*>mpv = { new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), };//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		int ia = rand() % 10;
		ia += ia / 2;
		switch (ch) {
		case 0:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 10:
			//未完成

			break;
		case 3:
			//未完成

			break;
		case 4:
			//未完成

			break;
		case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 2:
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = {rand() % 2, rand() % 2};
				pair<int, int>pxy = {rand() % 9 + 1, rand() % 9 + 1};
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 2) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				//case 2:

					//break;
				//case 3:

					//break;
				default:

					break;
				}
			}
			break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && &strmap[9][1] == cp) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 0:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 1:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			//case 2:
				//未完成

				break;
			case 3:
				//未完成

				break;
			case 4:
				//未完成

				break;
			case 5:
				//未完成

				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 2:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			default:
				break;
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		ishoot > 0 && ishoot--;
		p.shootmove(&strmap, 1);//子弹删
		//有怪物使你扣血
		' ' == *cp || cout << (p.sgetxyhs(HEAL)--, "\a"), ' ' == *cp && (*cp = 'P');
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism[ch].vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					while (' ' == *cpa) {
						cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
					}
					switch (ir) {
					case 0:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		//怪物动
		if (b && '*' == strmap[9][10]) {
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MDoAndHunt);
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		p.shootmove(&strmap, 0);
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“随机怪地牢已完成”^
/*
//Game.cpp
#include <iostream>
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
using namespace std;
#define DEBUG
void MDoAndHunt(moster* mp) {
	mp->hunt();
	mp->mosterdo();
}
void MShow(moster* mp) {
	*mp->getcp() = mp->getm();
}
void del(moster* mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	int i = 0;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char*, WASD>m;
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[11] = { &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9],&strmap[8][5],&strmap[5][2],&strmap[2][4],&strmap[4][7]};//请注意先后顺序，否则会出bug
	vector<moster*>mpv = { new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), new MX(), new MX(), new MX(), new MX(), };//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 0:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, &cp, &strmap);
			}
			break;
		//case 3:
			//未完成

			break;
		case 4:
			//未完成

			break;
		case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 3:
		{
			int ia = rand() % 10;
			ia += ia / 2;
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, &cp, &strmap);
					break;
				//case 3:

				//break;
				default:

					break;
				}
			}
		}
			break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && &strmap[9][1] == cp) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 0:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 1:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,7 };//8,5 5,2 2,4 4,7
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
				break;
			case 3:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 4:
				//未完成

				break;
			case 5:
				//未完成

				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:
				
				break;
			default:
				break;
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		ishoot > 0 && ishoot--;
		p.shootmove(&strmap, 1);//子弹删
		//有怪物使你扣血
		' ' == *cp || cout << (p.sgetxyhs(HEAL)--, "\a"), ' ' == *cp && (*cp = 'P');
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism[ch].vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					while (' ' == *cpa) {
						cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
					}
					switch (ir) {
					case 0:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		//怪物动
		if (b && '*' == strmap[9][10]) {
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MDoAndHunt);
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		p.shootmove(&strmap, 0);
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“MX”房已构造完成^
/*
//Game.cpp
#include <iostream>
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
using namespace std;
#define DEBUG
void MDoAndHunt(moster*& mp) {
	mp->hunt();
	mp->mosterdo();
}
void MShow(moster*& mp) {
	*mp->getcp() = mp->getm();
}
void del(moster*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	int i = 0;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char*, WASD>m;
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	vector<char*>strcp = { &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9],&strmap[8][5],&strmap[5][2],&strmap[2][4],&strmap[4][7]};//请注意先后顺序，否则会出bug
	vector<moster*>mpv = { new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), new MX(), new MX(), new MX(), new MX(), };//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 0:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, &cp, &strmap);
			}
			break;
		//case 3:
			//未完成

			break;
		case 4:
			//未完成

			break;
		case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 3:
		{
			int ia = rand() % 10;
			ia += ia / 2;
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp.push_back(&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, &cp, &strmap);
					break;
				//case 3:

				//break;
				default:

					break;
				}
			}
		}
			break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && &strmap[9][1] == cp) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 0:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 1:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,7 };//8,5 5,2 2,4 4,7
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
				break;
			case 3:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 4:
				//未完成

				break;
			case 5:
				//未完成

				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:
				
				break;
			default:
				break;
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		ishoot > 0 && ishoot--;
		p.shootmove(&strmap, 1);//子弹删
		//有怪物使你扣血
		' ' == *cp || cout << (p.sgetxyhs(HEAL)--, "\a"), ' ' == *cp && (*cp = 'P');
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism[ch].vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					while (' ' == *cpa) {
						cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
					}
					switch (ir) {
					case 0:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		//怪物动
		if (b && '*' == strmap[9][10]) {
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MDoAndHunt);
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		p.shootmove(&strmap, 0);
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“有BUG，勿扰”^
/*
#include <iostream>
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
using namespace std;
#define DEBUG
void MDoAndHunt(moster*& mp) {
	mp->hunt();
	mp->mosterdo();
}
void MShow(moster*& mp) {
	*mp->getcp() = mp->getm();
}
void del(moster*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char*, WASD>m;
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[26] = { &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9],&strmap[8][5],&strmap[5][2],&strmap[2][4],&strmap[4][7] };//请注意先后顺序，否则会出bug
	vector<moster*>mpv = { new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), new MX(), new MX(), new MX(), new MX(), };//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 0:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, &cp, &strmap);
			}
			break;
		//case 3:
			//未完成

			break;
		case 4:
			//未完成

			break;
		case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 3:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, &cp, &strmap);
					break;
				//case 3:

				//break;
				default:

					break;
				}
			}
		}
			break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && &strmap[9][1] == cp) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 0:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 1:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,7 };//8,5 5,2 2,4 4,7
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
				break;
			case 3:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 4:
				//未完成

				break;
			case 5:
				//未完成

				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:
				
				break;
			default:
				break;
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		*cp = ' ';
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		p.shootmove(&strmap, 1);//子弹删
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism[ch].vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					while (' ' == *cpa) {
						cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
					}
					switch (ir) {
					case 0:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		//怪物动
		if (b && '*' == strmap[9][10]) {
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MDoAndHunt);
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		p.shootmove(&strmap, 0);
		' ' == *cp || cout << (p.sgetxyhs(HEAL)--, "\a"), ' ' == *cp && (*cp = 'P');
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“已无明显BUG”^
/*
//MX.cpp
#include <iostream>
#include <cstring>
using namespace std;
#include "mX.h"
void MX::set(vector<trir>* v, char** cpp, int iheal, char** pcpp, char(*strmap)[11][11], int, int, bool, bool) {
	m_v = v;//vector<trir>* = NULL, char** = NULL, char** = NULL, pair<int, int>* = NULL, char(*)[11][11] = NULL,int = 0, int = 0, int = 3, bool = 0, bool = 0
	m_cpp = cpp;
	m_pcpp = pcpp;
	m_strmap = strmap;
	m_iheal = iheal;
	setb = 1;
}
void MX::exset(char strmapr[11][11]) {
	memcpy(m_strmapr, strmapr, sizeof m_strmapr);
}
MX::MX() {
	set();
}
void MX::mosterdo() {
	vector<trir>::iterator it = m_v->begin();
	if (setb) {
		pxy = { (*m_cpp - &(*m_strmap)[0][0]) / 11, (*m_cpp - &(*m_strmap)[0][0]) % 11 };
		m_cc = m_strmapr[pxy.first][setb = 0, pxy.second];
	}
	for (; m_v->end() != it; it++) {
		if (*m_cpp == it->cp) {
			break;
		}
	}
	if (*m_cpp == *m_pcpp || m_v->end() != it) {
		char* tempcp = *m_cpp;
		do {
			m_v->end() != it && (**m_cpp = ' ');
			*m_cpp = &m_strmapr[pxy.first = rand() % 9 + 1][pxy.second = rand() % 9 + 1];
		} while (*m_cpp == &(*m_strmap)[9][1] || '*' == (*m_cpp)[-1] && '*' == (*m_cpp)[1]);
		*tempcp = m_cc;
		'X' != m_strmapr[pxy.first][pxy.second] && (m_cc = m_strmapr[pxy.first][pxy.second]);
	}
	//**m_cpp = 'X';//使见
}//被玩家碰到传，受伤传(两旁有砖不传)，并见
char MX::getm() {
	return 'X';
}
*///“‘MX’保留BUG已解决”^
/*
//Game.cpp
#include <iostream>
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
using namespace std;
#define DEBUG
void MDoAndHunt(moster*& mp) {
	mp->hunt();
	mp->mosterdo();
}
void MShow(moster*& mp) {
	*mp->getcp() = mp->getm();
}
void del(moster*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char*, WASD>m;
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[26] = { &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9] };//请注意先后顺序，否则会出bug
	vector<moster*>mpv = { new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), };//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 2:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 0:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, &cp, &strmap);
			}
			break;
		//case 3:
			//未完成

			break;
		case 4:
			//未完成

			break;
		case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 3:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, &cp, &strmap);
					break;
				//case 3:

				//break;
				default:

					break;
				}
			}
		}
			break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 2:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 1:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 0:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
				break;
			case 3:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 4:
				//未完成

				break;
			case 5:
				//未完成

				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:
				
				break;
			default:
				break;
			}
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		ishoot > 0 && ishoot--;
		p.shootmove(&strmap, 1);//子弹删
		if (b && '*' == strmap[9][10]) {//怪物动
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MDoAndHunt);
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism[ch].vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					while (' ' == *cpa) {
						cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
					}
					switch (ir) {
					case 0:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		p.shootmove(&strmap, 0);
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“MX”房已完成^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#define DEBUG
#define POINT(P) (&(P))
void MDoAndHunt(moster*& mp) {
	mp->hunt();
	mp->mosterdo();
}
void MShow(moster*& mp) {
	*mp->getcp() = mp->getm();
}
void del(moster*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	//for (WASD w = W; E != w; ++w) {
	//	switch (w) {
	//	case W:
	//		for (i = 1; i < 4; i++) {
	//			//m.insert({ &strmap[10 - i][i], W});
	//		}
	//		break;
	//	case A:
	//		for (i = 7; i < 10; i++) {
	//			//m.insert({ &strmap[i][i], A });
	//		}
	//		break;
	//	case S:
	//		for (i = 1; i < 4; i++) {
	//			//m.insert({ &strmap[i][10 - i], S });
	//		}
	//		break;
	//	case D:
	//		for (i = 0; i < 3; i++) {
	//			//m.insert({ &strmap[i][i], D });
	//		}
	//		break;
	//	default:
	//		break;
	//	}
	//}
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[29] = { &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9] };//请注意先后顺序，否则会出bug
	vector<moster*>mpv = { new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), };//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 3:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 0:
			for (itemp = i + 3, vism[ch].str = "OOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				//vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL);
			}
			break;
			//case 4:
				//未完成

			break;
		case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 4:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				//case 3:

					//break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 3:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 2:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 1:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 4:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 5:
				//未完成

				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		ishoot > 0 && ishoot--;
		p.shootmove(&strmap, 1);//子弹删
		if (b && '*' == strmap[9][10]) {//怪物动
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MDoAndHunt);
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism[ch].vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					while (' ' == *cpa) {
						cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
					}
					switch (ir) {
					case 0:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		p.shootmove(&strmap, 0);
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“又有BUG，勿扰”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#define DEBUG
void MDoAndHunt(moster*& mp) {
	mp->hunt();
	mp->mosterdo();
}
void MShow(moster*& mp) {
	*mp->getcp() = mp->getm();
}
void del(moster*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m.insert({ cpp++, W });
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, A });
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m.insert({ cpp++, S });
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, D });
			}
			break;
		default:
			break;
		}
	}
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[30] = { &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9]};//请注意先后顺序，否则会出bug
	vector<moster*>mpv = { new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), };//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 3:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 0:
			for (itemp = i + 4, vism[ch].str = "OOOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m, NULL, NULL, itemp - i, itemp - i);
			}
			break;
			//case 4:
				//未完成

			break;
		case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 4:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 3:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 2:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 1:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 4:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 5:
				//未完成

				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		p.shootmove(&strmap, 1);//子弹删
		if (b && '*' == strmap[9][10]) {//怪物动
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MDoAndHunt);
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism[ch].vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					while (' ' == *cpa) {
						cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
					}
					switch (ir) {
					case 0:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		p.shootmove(&strmap, 0);
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“MO房构造完成”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#define DEBUG
void MShow(moster*& mp) {
	*mp->getcp() = mp->getm();
}
void del(moster*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m.insert({ cpp++, W });
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, A });
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m.insert({ cpp++, S });
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, D });
			}
			break;
		default:
			break;
		}
	}
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[31] = { &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9]};//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new Mplus(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(),};//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 4:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 3:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "OOOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m, NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 0:
			//BOSS,会改
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
		//case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 5:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 4:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 3:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 5:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 0:
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (b && '*' == strmap[9][10]) {//怪物动
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				if ((!bosswait || bosswait--) && '+' == (*it)->getm()) {
					((Mplus*)*it)->summon(vism.front().vmp, p.sgetxyhs(), &strcp[0]);//**会变**
					bosswait = 5;
				}
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		p.shootmove(&strmap, 1);//子弹动
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism[ch].vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					while (' ' == *cpa) {
						cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
					}
					switch (ir) {
					case 0:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		p.shootmove(&strmap, 0);//子弹删
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“BOSS房的地牢样式已完成”^
/*
//MO.cpp
#include <iostream>
using namespace std;
#include "MO.h"
#define NNEG(A, B) ((A) < (B) ? 1 : (A) > (B) ? -1 : 0)
pair<int, int> MO::s_m_pxy = {0, 0};
MO::MO() {
	this->set();
}
void MO::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*m, char**, char(*)[11][11], int ix, int iy, bool, bool) {
	m_v = v;//vector<trir>* = NULL, char** = NULL, pair<int, int>* = NULL, int = 0, int = 0, int = 3, bool = 0, bool = 0
	m_cpp = cpp;
	m_iheal = iheal;
	m_pxy.first = ix;
	m_pxy.second = iy;
	if (m) { 
		m_m = *m;
	}
}
void MO::mosterdo() {
	**m_cpp = ' ';
	if (!m_m.empty()) {
		int arr[4] = { -11,-1,11,1 };
		for (map<char**, WASD>::iterator it = m_m.begin(); m_m.end() != it; it++) {
			E != it->second && *m_cpp == *it->first && (m_wasd = it->second);
		}
		switch (*m_cpp += (arr[m_wasd]), m_wasd) {
		case W:
			m_pxy.second--;
			break;
		case A:
			m_pxy.first--;
			break;
		case S:
			m_pxy.second++;
			break;
		case D:
			m_pxy.first++;
			break;
		default:
			break;
		}
	}
	else {
		'*' != *(*m_cpp + NNEG(m_pxy.first, s_m_pxy.first)) && (m_pxy.first += NNEG(m_pxy.first, s_m_pxy.first));
		'*' != *(*m_cpp + 11 * NNEG(m_pxy.first, s_m_pxy.first)) && (m_pxy.second -= NNEG(m_pxy.second, s_m_pxy.second));
		'*' != *(*m_cpp + NNEG(m_pxy.first, s_m_pxy.first)) && (*m_cpp += NNEG(m_pxy.first, s_m_pxy.first));//根据怪物的xy坐标和玩家的xy坐标
		'*' != *(*m_cpp + 11 * NNEG(m_pxy.first, s_m_pxy.first)) && (*m_cpp += 11 * NNEG(m_pxy.second, s_m_pxy.second));
	}
}//遇向则转，看路前行（1），或追玩者（2）
void MO::set_s_pxy(int ix, int iy) {
	s_m_pxy = { ix, iy };
}
char MO::getm() {
	return 'O';
}
*///“MO”怪的机制已更改^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#define DEBUG
void MShow(moster*& mp) {
	*mp->getcp() = mp->getm();
}
void del(moster*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	M_o o;
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m.insert({ cpp++, W });
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, A });
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m.insert({ cpp++, S });
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, D });
			}
			break;
		default:
			break;
		}
	}
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[31] = { &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9]};//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new Mplus(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(),};//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 4:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 3:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "OOOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m, NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 0:
			//BOSS,会改
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
		//case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 5:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 4:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 3:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 5:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 0:
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (b && '*' == strmap[9][10]) {//怪物动
			if ((!bosswait || bosswait--) && '+' == vism.front/* <- 会改(back) */().vmp.front()->getm()) {
				char* setcp = &strmap[5][5];
				vism.front().vmp.push_back(&o);
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 5;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		p.shootmove(&strmap, 1);//子弹动
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism[ch].vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					while (' ' == *cpa) {
						cpa = &strmap[mx = rand() % 9 + 1][my = rand() % 9 + 1];
					}
					switch (ir) {
					case 0:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism[ch].vmp.front()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		p.shootmove(&strmap, 0);//子弹删
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
//M_o.cpp
#include <iostream>
#include <ctime>
#include <cstdlib>
#include "M_o.h"
using namespace std;
void M_o::near() {
	int arr[8] = { -12, -11, -10, -1, 1, -10, -11, -12 };
	int i = 0;
	for (; i < 8; i++) {
		if ('*' == (*m_cpp)[arr[i]]) {
			m_iheal = -1;
		}
	}
}
void M_o::mosterdo() {
	**m_cpp = ' ';
	switch (rand() % 8) {//随便移动
	case 0:
		'*' != (*m_cpp)[-12] && ((*m_cpp) -= 12);
		break;
	case 1:
		'*' != (*m_cpp)[-11] && ((*m_cpp) -= 11);
		break;
	case 2:
		'*' != (*m_cpp)[-10] && ((*m_cpp) -= 10);
		break;
	case 3:
		'*' != (*m_cpp)[-1] && ((*m_cpp)--);
		break;
	case 4:
		'*' != (*m_cpp)[1] && ((*m_cpp)++);
		break;
	case 5:
		'*' != (*m_cpp)[11] && ((*m_cpp) += 11);
		break;
	case 6:
		'*' != (*m_cpp)[12] && ((*m_cpp) += 12);
		break;
	case 7:
		'*' != (*m_cpp)[13] && ((*m_cpp) += 13);
		break;
	default:
		break;
	}
	//**m_cpp = 'o';
	near();
}//随便移动，有墙不动
char M_o::getm() {
	return 'o';
}
*///“M+”已成功生出第一个“M_o”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#define DEBUG
void MShow(moster*& mp) {
	*mp->getcp() = mp->getm();
}
void del(moster*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	M_o o;
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m.insert({ cpp++, W });
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, A });
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m.insert({ cpp++, S });
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, D });
			}
			break;
		default:
			break;
		}
	}
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[31] = { &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9]};//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new Mplus(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(),};//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 4:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 3:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "OOOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m, NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 0:
			//BOSS,会改
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
		//case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 5:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 4:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 3:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 5:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 0:
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (b && '*' == strmap[9][10]) {//怪物动
			if ((!bosswait || bosswait--) && '+' == vism.front/* <- 会改(back) */().vmp.front()->getm()) {
				char* setcp = &strmap[5][5];
				vism.front().vmp.push_back(&o);
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 5;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		p.shootmove(&strmap, 1);//子弹动
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (cpa = vism.front().vmp.front()->getcp() + arr[rand() % 8], ' ' != *cpa) {}
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		p.shootmove(&strmap, 0);//子弹删
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“M_o”已变成其他怪物^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#define DEBUG
void MShow(moster*& mp) {
	*mp->getcp() = mp->getm();
}
void del(moster*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	M_o o;
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m.insert({ cpp++, W });
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, A });
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m.insert({ cpp++, S });
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, D });
			}
			break;
		default:
			break;
		}
	}
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[31] = { &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9]};//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new Mplus(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(),};//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 4:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 3:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "OOOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m, NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 0:
			//BOSS,会改
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
		//case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 5:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 4:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 3:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 5:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 0:
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			for (;/*完善后有判断*/'+' != (*vfvp)->getm(); vfvp++){}
			if (!bosswait || (bosswait--, 0)) {
				char* setcp = &strmap[5][5];
				vism.front().vmp.push_back(&o);
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 10;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		p.shootmove(&strmap, 1);//子弹动
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MO());
						break;
					case 2:
						mpv.push_back(new MX());
						break;
					case 3:
						mpv.push_back(new MUD());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (cpa = vism.front().vmp.front()->getcp() + arr[rand() % 8], ' ' != *cpa) {}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm();
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmap);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		p.shootmove(&strmap, 0);//子弹删
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	return 0;
}
*///“M_o的改变机制已改变”^
/*
//M^.cpp
#include <iostream>
using namespace std;
#include "m^.h"
MUD::MUD() {
	this->set();
}
void MUD::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*, char**, char(*)[11][11], int, int, bool b, bool ba) {
	m_v = v;//vector<trir>* = NULL, char** = NULL, char** = NULL, pair<int, int>* = NULL, int = 0, int = 0, int = 3, bool = 0, bool = 0
	m_cpp = cpp;
	m_iheal = iheal;
	mblr = b;
	mbud = ba;
}
void MUD::mosterdo() {
	**m_cpp = ' ';
	if (!mblr && '*' == (*m_cpp)[-1]) {
		mblr = 1;
	}
	else if(mblr && '*' == (*m_cpp)[1]){
		mblr = 0;
	}//撞墙换方向
	'*' != (*m_cpp)[-(1 - 2 * mblr)] && (*m_cpp -= (1 - 2 * mblr));//左右移
	if (mbud && '*' == (*m_cpp)[-11]) {
		mbud = 0;
	}
	else if (!mbud && '*' == (*m_cpp)[11]) {
		mbud = 1;
	}//碰地会反转
	'*' != (*m_cpp)[-(11 * (1 - 2 * mbud))] && (*m_cpp += 11 * (1 - 2 * mbud));//上下落
	//mbud || (**m_cpp = 'v'), mbud && (**m_cpp = '^');//使见
}//撞墙换方向，碰地会反落
char MUD::getm() {
	if (mbud) {
		return '^';
	}
	else {
		return 'v';
	}
}
*///“M^”的移动机制已改变^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#define DEBUG
void MShow(moster*& mp) {
	*mp->getcp() = mp->getm();
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vo.reserve(99999);
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m.insert({ cpp++, W });
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, A });
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m.insert({ cpp++, S });
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, D });
			}
			break;
		default:
			break;
		}
	}
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[31] = { &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9]};//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new Mplus(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(),};//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 4:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 3:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "OOOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m, NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 0:
			//BOSS,会改
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
		//case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 5:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 4:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 3:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 5:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 0:
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (cpa = vism.front().vmp.front()->getcp() + arr[rand() % 8], ' ' != *cpa) {}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm();
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmap);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				if (it == vism.front().vmp.end()) {
					*vism.front().vmp.front()->getcp() = ' ';
				}
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			for (;/*完善后有判断*/'+' != (*vfvp)->getm(); vfvp++){}
			if (!bosswait || (bosswait--, 0)) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 1;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it; it++) {
				(*it)->hunt(); 
				(*it)->mosterdo();
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		p.shootmove(&strmap, 0);//子弹删
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///已成功显示出两个及以上的“M_o”^
/*
//M_o.cpp
#include <iostream>
#include <ctime>
#include <cstdlib>
#include "M_o.h"
using namespace std;
void M_o::near() {
	int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
	int i = 0;
	for (; i < 8; i++) {
		if ('*' == (*m_cpp)[arr[i]]) {
			m_iheal = -1;
			break;
		}
	}
}
void M_o::mosterdo() {
	**m_cpp = ' ';
	int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
	int ir = 0;
	(near(), '*') != (*m_cpp)[arr[ir = rand() % 8]] && ((*m_cpp) -= arr[ir]);
}//随便移动，有墙不动
char M_o::getm() {
	return 'o';
}
*///“M_o”的移动机制已做优化^
/*
//M_o.cpp
#include <iostream>
#include <ctime>
#include "M_o.h"
using namespace std;
void M_o::near() {
	int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
	int i = 0;
	for (; i < 8; i++) {
		if ('*' == (*m_cpp)[arr[i]]) {
			m_iheal = -1;
			break;
		}
	}
}
void M_o::mosterdo() {
	int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
	int ir = 0;
	(near(), '*') != (&(**m_cpp = ' '))[arr[ir = rand() % 8]] && ((*m_cpp) -= arr[ir]);
}//随便移动，有墙不动
char M_o::getm() {
	return 'o';
}
*///“主要问题：各怪物之间的cpp非常同步”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#define DEBUG
void MShow(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vo.reserve(99999);
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m.insert({ cpp++, W });
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, A });
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m.insert({ cpp++, S });
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, D });
			}
			break;
		default:
			break;
		}
	}
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[31] = { &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9]};//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new Mplus(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(),};//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 4:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 3:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "OOOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m, NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 0:
			//BOSS,会改
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
		//case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 5:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 4:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 3:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 5:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 0:
				/*
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				*/
				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (cpa = vism.front().vmp.front()->getcp() + arr[rand() % 8], ' ' != *cpa) {}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm();
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmap);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				it != vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' == *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			for (;/*完善后有判断*/'+' != (*vfvp)->getm(); vfvp++){}
			if (!bosswait || (bosswait--, 0)) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 10;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it; it++) {
				(*it)->hunt(); 
				(*it)->mosterdo();
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		p.shootmove(&strmap, 0);//子弹删
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“可能解决了破墙bug”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#define DEBUG
void MShow(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vo.reserve(99999);
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m.insert({ cpp++, W });
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, A });
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m.insert({ cpp++, S });
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, D });
			}
			break;
		default:
			break;
		}
	}
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[31] = { &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9]};//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new Mplus(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(),};//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 4:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 3:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "OOOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m, NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 0:
			//BOSS,会改
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
		//case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 5:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 4:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 3:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 5:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 0:
				/*
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				*/
				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm();
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmap);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				it != vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' == *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			for (;/*完善后有判断*/'+' != (*vfvp)->getm(); vfvp++){}
			if (!bosswait || (bosswait--, 0)) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 10;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it; it++) {
				(*it)->hunt(); 
				(*it)->mosterdo();
//#ifdef DEBUG
//				if (5 == vism.front().vmp.size())
//				cout << (((M_o*)vism.front().vmp.front())->i == ((M_o*)(*vism.front().vmp.begin() + 1))->i);
//#endif
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		p.shootmove(&strmap, 0);//子弹删
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“防越界以出bug”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#define DEBUG
void MShow(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vo.reserve(99999);
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m.insert({ cpp++, W });
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, A });
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m.insert({ cpp++, S });
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, D });
			}
			break;
		default:
			break;
		}
	}
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[31] = { &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9]};//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new Mplus(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(),};//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 4:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 3:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "OOOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m, NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 0:
			//BOSS,会改
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
		//case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 5:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 4:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 3:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 5:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 0:
				/*
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				*/
				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm();
#ifdef DEBUG
				cout << (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11 << " "
				<< (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11 << " " << (int)vism.front().vmp.front()->getcp();
#endif
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmap);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			for (;/*完善后有判断*/'+' != (*vfvp)->getm(); vfvp++){}
			if (!bosswait || (bosswait--, 0)) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 0;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it; it++) {
				(*it)->hunt(); 
				(*it)->mosterdo();
//#ifdef DEBUG
//				if (5 == vism.front().vmp.size())
//				cout << (((M_o*)vism.front().vmp.front())->i == ((M_o*)(*vism.front().vmp.begin() + 1))->i);
//#endif
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		p.shootmove(&strmap, 0);//子弹删
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“破墙bug已完全修复”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#define DEBUG
void MShow(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vo.reserve(99999);
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m.insert({ cpp++, W });
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, A });
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m.insert({ cpp++, S });
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, D });
			}
			break;
		default:
			break;
		}
	}
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[31] = { &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9]};//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new Mplus(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(),};//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 4:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 3:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "OOOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m, NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 0:
			//BOSS,会改
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 1);
			break;
		//case 5:
			//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 5:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 99999;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 4:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 3:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 5:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 0:
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm();
#ifdef DEBUG
				cout << (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11 << " "
				<< (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11 << " " << (int)vism.front().vmp.front()->getcp();
#endif
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmap);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()){
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (!bosswait || (bosswait--, 0)) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 999;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it; it++) {
				(*it)->hunt(); 
				(*it)->mosterdo();
//#ifdef DEBUG
//				if (5 == vism.front().vmp.size())
//				cout << (((M_o*)vism.front().vmp.front())->i == ((M_o*)(*vism.front().vmp.begin() + 1))->i);
//#endif
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		p.shootmove(&strmap, 0);//子弹删
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“M+”正式被玩家击败^
/*
//M_o.cpp
#include <iostream>
#include <ctime>
#include "M_o.h"
using namespace std;
void M_o::near() {
	int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
	int i = 0;
	for (; i < 8; i++) {
		if ('*' == (*m_cpp)[arr[i]]) {
			m_iheal = -1;
			break;
		}
	}
}
void M_o::mosterdo() {
	int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
	int ir = 0;
	'*' != **m_cpp && (**m_cpp = ' ');
	tempcp = (near(), *m_cpp);
	m_cpp = NULL;
	'*' != tempcp[arr[ir = rand() % 8]] && (tempcp -= arr[ir]);//bug点：一级指针会“带动”二级指针
	m_cpp = &tempcp;
}//随便移动，有墙不动
char M_o::getm() {
	return 'o';
}
*///“M_o”指针非常同步bug已修复^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#define DEBUG
void MShow(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vo.reserve(99999);
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m.insert({ cpp++, W });
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, A });
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m.insert({ cpp++, S });
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, D });
			}
			break;
		default:
			break;
		}
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[31] = { &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9] };//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new Mplus(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), };//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 4:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 3:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "OOOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m, NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 0:
			//BOSS,会改
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
			//case 5:
				//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 5:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 4:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 3:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 5:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 0:
				/*
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				*/
				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				vism.front().vmp.erase(vism.front().vmp.begin());//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (!bosswait || (bosswait--, 0)) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 3;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“再次完全解决破墙bug”^
/*
//MO.cpp
#include <iostream>
using namespace std;
#include "MO.h"
#define NNEG(A, B) ((A) < (B) ? 1 : (A) > (B) ? -1 : 0)
pair<int, int> MO::s_m_pxy = {0, 0};
MO::MO() {
	this->set();
}
void MO::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*m, char**, char(*)[11][11], int ix, int iy, bool, bool) {
	m_v = v;//vector<trir>* = NULL, char** = NULL, pair<int, int>* = NULL, int = 0, int = 0, int = 3, bool = 0, bool = 0
	m_cpp = cpp;
	m_iheal = iheal;
	m_pxy.first = ix;
	m_pxy.second = iy;
	if (m) { 
		m_m = *m;
	}
}
void MO::mosterdo() {
	'*' != **m_cpp && (**m_cpp = ' ');
	tempcp = *m_cpp;
	m_cpp = NULL;
	if (!m_m.empty()) {
		int arr[4] = { -11, -1, 11, 1 };
		for (map<char**, WASD>::iterator it = m_m.begin(); m_m.end() != it; it++) {
			E != it->second && tempcp == *it->first && (m_wasd = it->second);
		}
		//int* iparr[2] = { &m_pxy.first, &m_pxy.second };
		switch (tempcp += (arr[m_wasd]), m_wasd) {
		case W:
			m_pxy.second--;
			break;
		case A:
			m_pxy.first--;
			break;
		case S:
			m_pxy.second++;
			break;
		case D:
			m_pxy.first++;
			break;
		default:
			break;
		}
	}
	else {
		'*' != *(tempcp + 11 * NNEG(m_pxy.first, s_m_pxy.first)) && (m_pxy.first += NNEG(m_pxy.first, s_m_pxy.first));
		'*' != *(tempcp + NNEG(m_pxy.second, s_m_pxy.second)) && (m_pxy.second += NNEG(m_pxy.second, s_m_pxy.second));
		'*' != *(tempcp + 11 * NNEG(m_pxy.first, s_m_pxy.first)) && (tempcp += 11 * NNEG(m_pxy.first, s_m_pxy.first));//根据怪物的xy坐标和玩家的xy坐标来移动
		'*' != *(tempcp + NNEG(m_pxy.second, s_m_pxy.second)) && (tempcp += NNEG(m_pxy.second, s_m_pxy.second));
	}
	m_cpp = &tempcp;
}//遇向则转，看路前行（1），或追玩者（2）
void MO::set_s_pxy(int ix, int iy) {
	s_m_pxy = { ix, iy };
}
char MO::getm() {
	return 'O';
}
//M&.cpp
#include <iostream>
using namespace std;
#include "m&.h"
Mand::Mand() {
	this->set();
}
//vector<trir>* = NULL, char** = NULL, char** = NULL, pair<int, int>* = NULL, int = 0, int = 0, int = 3, bool = 0, bool = 0
void Mand::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*, char**, char(*)[11][11], int, int, bool b, bool) {
	m_v = v;
	m_cpp = cpp;
	m_iheal = iheal;
	mblr = b;
}
void Mand::mosterdo() {
	'*' != **m_cpp && (**m_cpp = ' ');
	if (!mblr && '*' == (*m_cpp)[-1]) {
		mblr = 1;
	}
	else if (mblr && '*' == (*m_cpp)[1]) {
		mblr = 0;
	}//撞墙换方向
	tempcp = *m_cpp;
	m_cpp = NULL;
	'*' != tempcp[-(1 - 2 * mblr)] && (tempcp -= (1 - 2 * mblr));//左右移
	'*' != tempcp[11] && (tempcp += 11);//下落
	m_cpp = &tempcp;
	//后面Mshow使见
}//撞墙换方向，会自然下落
char Mand::getm() {
	return '&';
}
//M^.cpp
#include <iostream>
using namespace std;
#include "m^.h"
MUD::MUD() {
	this->set();
}
void MUD::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*, char**, char(*)[11][11], int, int, bool b, bool ba) {
	m_v = v;//vector<trir>* = NULL, char** = NULL, char** = NULL, pair<int, int>* = NULL, int = 0, int = 0, int = 3, bool = 0, bool = 0
	m_cpp = cpp;
	m_iheal = iheal;
	mblr = b;
	mbud = ba;
}
void MUD::mosterdo() {
	'*' != **m_cpp && (**m_cpp = ' ');
	if (!mblr && '*' == (*m_cpp)[-1]) {
		mblr = 1;
	}
	else if(mblr && '*' == (*m_cpp)[1]){
		mblr = 0;
	}//撞墙换方向
	tempcp = *m_cpp;
	m_cpp = NULL;
	'*' != tempcp[-(1 - 2 * mblr)] && (tempcp -= (1 - 2 * mblr));//左右移
	if (mbud && '*' == tempcp[-11]) {
		mbud = 0;
	}
	else if (!mbud && '*' == tempcp[11]) {
		mbud = 1;
	}//碰地会反转
	'*' != tempcp[-(11 * (1 - 2 * mbud))] && (tempcp -= 11 * (1 - 2 * mbud));//上下落
	m_cpp = &tempcp;
	//后面Mshow函数使见
}//撞墙换方向，碰地会反落
char MUD::getm() {
	if (mbud) {
		return '^';
	}
	else {
		return 'v';
	}
}
//...
*///“更多种怪物已不同步地同时移动”^
/*
//M^.cpp
#include <iostream>
using namespace std;
#include "m^.h"
MUD::MUD() {
	this->set();
}
void MUD::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*, char**, char(*)[11][11], int, int, bool b, bool ba) {
	m_v = v;//vector<trir>* = NULL, char** = NULL, char** = NULL, pair<int, int>* = NULL, int = 0, int = 0, int = 3, bool = 0, bool = 0
	m_cpp = cpp;
	m_iheal = iheal;
	mblr = b;
	mbud = ba;
}
void MUD::mosterdo() {
	'*' != **m_cpp && (**m_cpp = ' ');
	if (!mblr && '*' == (*m_cpp)[-1]) {
		mblr = 1;
	}
	else if(mblr && '*' == (*m_cpp)[1]){
		mblr = 0;
	}//撞墙换方向
	tempcp = *m_cpp;
	m_cpp = NULL;
	'*' != tempcp[-(1 - 2 * mblr)] && (tempcp -= (1 - 2 * mblr));//左右移
	if (mbud && '*' == tempcp[11]) {
		mbud = 0;
	}
	else if (!mbud && '*' == tempcp[-11]) {
		mbud = 1;
	}//碰地会反转
	'*' != tempcp[-(11 * (1 - 2 * mbud))] && (tempcp -= 11 * (1 - 2 * mbud));//上下落
	m_cpp = &tempcp;
	//后面Mshow函数使见
}//撞墙换方向，碰地会反落
char MUD::getm() {
	if (mbud) {
		return 'v';
	}
	else {
		return '^';
	}
}
*///“‘M^’的显示bug已修复”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#define DEBUG
void MShow(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vo.reserve(99999);
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m.insert({ cpp++, W });
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, A });
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m.insert({ cpp++, S });
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, D });
			}
			break;
		default:
			break;
		}
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[31] = { &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9] };//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new Mplus(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), };//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 4:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 3:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "OOOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m, NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 0:
			//BOSS,会改
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
			//case 5:
				//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 5:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 4:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 3:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 5:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 0:
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		else if (!bb && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			//未完成
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		p.printmap(strmap);
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“M+”房机制已构造完成^
/*
//MO.h
#pragma once
#include <iostream>
using namespace std;
#include <map>
#include "Player.h"
#include "moster.h"
class MO : public moster {
private:
	WASD m_wasd;
	map<char**, WASD>m_m;//[strmap point, wasd]...
	pair<int, int> m_pxy;//MOSTER xy坐标
	static pair<int, int> s_m_pxy;//PLAYER xy坐标
	int imove;
public:
	void set(vector<trir>* v = NULL, char** cpp = NULL, int iheal = 3, map<char**, WASD>* m = NULL, char** = NULL, char(*)[11][11] = NULL, int ix = 0, int iy = 0, bool = 0, bool = 0);
	MO();
	void set_s_pxy(int ix, int iy);
	void mosterdo();
	char getm();
};
//MO.cpp
#include <iostream>
using namespace std;
#include "MO.h"
#define NNEG(A, B) ((A) < (B) ? 1 : (A) > (B) ? -1 : 0)
pair<int, int> MO::s_m_pxy = {0, 0};
MO::MO() {
	this->set();
}
void MO::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*m, char**, char(*)[11][11], int ix, int iy, bool, bool) {
	m_v = v;//vector<trir>* = NULL, char** = NULL, pair<int, int>* = NULL, int = 0, int = 0, int = 3, bool = 0, bool = 0
	m_cpp = cpp;
	m_iheal = iheal;
	m_pxy.first = ix;
	m_pxy.second = iy;
	imove = false;
	if (m) { 
		m_m = *m;
	}
}
void MO::mosterdo() {
	'*' != **m_cpp && (**m_cpp = ' ');
	tempcp = *m_cpp;
	m_cpp = NULL;
	if (!m_m.empty()) {
		int arr[4] = { -11, -1, 11, 1 };
		for (map<char**, WASD>::iterator it = m_m.begin(); m_m.end() != it; it++) {
			E != it->second && tempcp == *it->first && (m_wasd = it->second);
		}
		//int* iparr[2] = { &m_pxy.first, &m_pxy.second };
		switch (tempcp += (arr[m_wasd]), m_wasd) {
		case W:
			m_pxy.second--;
			break;
		case A:
			m_pxy.first--;
			break;
		case S:
			m_pxy.second++;
			break;
		case D:
			m_pxy.first++;
			break;
		default:
			break;
		}
	}
	else {
		2 == imove % 3 && ('*' != *(tempcp + 11 * NNEG(m_pxy.first, s_m_pxy.first)) && (tempcp += 11 * NNEG(m_pxy.first, s_m_pxy.first), m_pxy.first += NNEG(m_pxy.first, s_m_pxy.first)));//根据怪物的xy坐标和玩家的xy坐标来移动
		2 == imove++ % 3 && ('*' != *(tempcp + NNEG(m_pxy.second, s_m_pxy.second)) && (tempcp += NNEG(m_pxy.second, s_m_pxy.second), m_pxy.second += NNEG(m_pxy.second, s_m_pxy.second)));
	}
	m_cpp = &tempcp;
}//遇向则转，看路前行（1），或追玩者（2）
void MO::set_s_pxy(int ix, int iy) {
	s_m_pxy = { ix, iy };
}
char MO::getm() {
	return 'O';
}
*///“MO”的追踪机制已更改^
/*
//M_o.cpp
#include <iostream>
using namespace std;
#include "MO.h"
#define NNEG(A, B) ((A) < (B) ? 1 : (A) > (B) ? -1 : 0)
#define M_oWAIT 1
pair<int, int> MO::s_m_pxy = {0, 0};
MO::MO() {
	this->set();
}
void MO::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*m, char**, char(*)[11][11], int ix, int iy, bool, bool) {
	m_v = v;//vector<trir>* = NULL, char** = NULL, pair<int, int>* = NULL, int = 0, int = 0, int = 3, bool = 0, bool = 0
	m_cpp = cpp;
	m_iheal = iheal;
	m_pxy.first = ix;
	m_pxy.second = iy;
	imove = 0;
	if (m) { 
		m_m = *m;
	}
}
void MO::mosterdo() {
	'*' != **m_cpp && (**m_cpp = ' ');
	tempcp = *m_cpp;
	m_cpp = NULL;
	if (!m_m.empty()) {
		int arr[4] = { -11, -1, 11, 1 };
		for (map<char**, WASD>::iterator it = m_m.begin(); m_m.end() != it; it++) {
			E != it->second && tempcp == *it->first && (m_wasd = it->second);
		}
		//int* iparr[2] = { &m_pxy.first, &m_pxy.second };
		switch (tempcp += (arr[m_wasd]), m_wasd) {
		case W:
			m_pxy.second--;
			break;
		case A:
			m_pxy.first--;
			break;
		case S:
			m_pxy.second++;
			break;
		case D:
			m_pxy.first++;
			break;
		default:
			break;
		}
	}
	else {
		M_oWAIT == imove % (M_oWAIT + 1) && ('*' != *(tempcp + 11 * NNEG(m_pxy.first, s_m_pxy.first)) && (tempcp += 11 * NNEG(m_pxy.first, s_m_pxy.first), m_pxy.first += NNEG(m_pxy.first, s_m_pxy.first)));//根据怪物的xy坐标和玩家的xy坐标来移动
		M_oWAIT == imove++ % (M_oWAIT + 1) && ('*' != *(tempcp + NNEG(m_pxy.second, s_m_pxy.second)) && (tempcp += NNEG(m_pxy.second, s_m_pxy.second), m_pxy.second += NNEG(m_pxy.second, s_m_pxy.second)));
	}
	m_cpp = &tempcp;
}//遇向则转，看路前行（1），或追玩者（2）
void MO::set_s_pxy(int ix, int iy) {
	s_m_pxy = { ix, iy };
}
char MO::getm() {
	return 'O';
}
*///“定义M_oWAIT宏”^
/*
//Player.cpp
#include <iostream>
#include "Player.h"
#include "cmp.h"
#include <algorithm>
using namespace std;
Player::Player(){
	ijh = 0;
	blr = 1;
	hlwait = 1;
}
void Player::printmap(const char strmap[11][11], const bool bwait) {
	int i = 0;
	int ia = 0;
	cout << "\033[" << (!bwait || 2 < iheal ? "32;1m" : 2 == iheal ? "33m" : "31;1m") << "P * " << iheal << "\033[0m" << endl << endl << endl;
	for (cout << "-----------@" << endl; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : 'v' == strmap[i][ia] ? "36m" : '&' == strmap[i][ia] || '^' == strmap[i][ia] || 'o' == strmap[i][ia] || 'O' == strmap[i][ia] || 'X' == strmap[i][ia] ? "31;1m" : '+' == strmap[i][ia] ? "33m" : '@' == strmap[i][ia] ? "33m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
void Player::jump(char** cpp) {
	10 == ix || '*' == (*cpp)[11] && (ijh = JUMPHIGH);
}
void Player::left_move(char** cpp) {
	(iy && '*' != *(*cpp - 1) && ((*cpp)--));
	blr = false;
}
void Player::right_move(char** cpp) {
	10 != iy && '*' != *(*cpp + 1) && ((*cpp)++);
	blr = true;
}
int& Player::sgetxyhs(XYHS xyhsmode) {
	switch (xyhsmode) {
	case X:
		return ix;
		break;
	case Y:
		return iy;
		break;
	case HEAL:
		return iheal;
		break;
	default:
		break;
	}
}
vector<trir>* Player::sgetxyhs() {
	return &v;
}
void Player::upOrDown(char** cpp) {
	if (ijh > 0 && ix && '*' != (*cpp)[-11]) {
		ijh--, *cpp -= 11;
	}
	else if ('*' != (*cpp)[11] && (!ix || '*' == (*cpp)[-11])) {
		ijh = 0, *cpp += 11;
	}
	else if ('*' != (*cpp)[11] && 10 != ix) {
		*cpp += 11;
	}
	if (ijh > 0 && '*' == (*cpp)[11]) {
		ijh = 0;
	}
}
void Player::shoot(int& i, char** cpp) {
	if ((!i) && (iy && blr || 21 != iy && (!blr))) {
		v.push_back({ *cpp, iy, blr, 0 });
		i = 3;
	}
}
void Player::shootmove(const char(*strmap)[11][11], bool bmode) {
	if (bmode) {
		for (vector<trir>::iterator it = v.begin(); v.end() != it; it++) {
			(' ' == *it->cp || '@' == *it->cp) && (*it->cp = ' ');
			if (it->bk || (!it->iy && (!it->b)) || (21 == it->iy && it->b)) {
				it->iy = -1;//子弹的销毁
			}
			if (0 <= it->iy) {
				it->cp -= (1 - it->b * 2);
				it->iy -= (1 - it->b * 2);
				(' ' == *it->cp || '@' == *it->cp) && (*it->cp = '@');
			}
		}
	}
	else {
		sort(v.begin(), v.end(), cmp());
		while ((!v.empty()) && 0 > v.begin()->iy) {
			v.erase(v.begin());
		}
	}
}
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#define DEBUG
void MShow(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vo.reserve(99999);
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m.insert({ cpp++, W });
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, A });
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m.insert({ cpp++, S });
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, D });
			}
			break;
		default:
			break;
		}
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[31] = { &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9] };//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new Mplus(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), };//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 4:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 3:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "OOOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m, NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 0:
			//BOSS,会改
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
			//case 5:
				//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 5:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			switch (vism.front().id) {
			case 4:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 3:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 5:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 0:
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		else if (!bb && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			//未完成
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		p.printmap(strmap, ba);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = (ba ? ba = !ba, 2 : rand() % 4)) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			1 != vism.size() && (!(rand() % 4) && (3 != p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0) || (!(rand() % 2)) && (3 != p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0));//恢复血量
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“回血功能与显血功能实现”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include "draw.h"
#define DEBUG
void MShow(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	vo.reserve(99999);
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m;
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m.insert({ cpp++, W });
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, A });
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m.insert({ cpp++, S });
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m.insert({ cpp++, D });
			}
			break;
		default:
			break;
		}
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[31] = { &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9] };//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new Mplus(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), };//mpv里一共要有的怪物们
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {
		case 4:
			for (itemp = i + 3, vism[ch].str = "&&&"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 3:
			for (itemp = i + 4, vism[ch].str = "^v^v"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 2:
			for (itemp = i + 4, vism[ch].str = "XXXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 1:
			for (itemp = i + 4, vism[ch].str = "OOOO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m, NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 0:
			//BOSS,会改
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
			//case 5:
				//未完成

			break;
		case 6:
			//未完成

			break;
		case 7:
			//未完成

			break;
		case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 5:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:

					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
	vism.push_back(ism);
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			vism.front().cp = &(vism.front().str[0]);
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 4:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 3:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 2:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 5:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 0:
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			case 6:
				//未完成

				break;
			case 7:
				//未完成

				break;
			case 8:
				//未完成

				break;
			case 9:
				//未完成

			case 10:

				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; *(vism.front().cp); ch++, vism.front().cp++) {
				*vism.front().vmp[ch]->getcp() = *vism.front().cp;
			}
		}
		else if (!bb && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			//未完成
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); vmd[5 - vism.size()].back().iwalk + 1; it++) {
			for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
				*drawcp = '#';
			}
		}
		p.printmap(strmap, ba);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = (ba ? ba = !ba, 2 : rand() % 4)) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			1 != vism.size() && (!(rand() % 4) && (3 != p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0) || (!(rand() % 2)) && (3 != p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0));//恢复血量
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“战前显示功能已做好”^
/*
//WASD.cpp
#include <iostream>
using namespace std;
#include "WASD.h"
WASD& operator++(WASD& w) {
	WASD warr[5] = { W,A,S,D,E };
	w < E && (w = warr[w + 1]);
	return w;
}
*///“重载用于枚举WASD的前置++已优化”^
/*
//Player.cpp
#include <iostream>
#include "Player.h"
#include "cmp.h"
#include <algorithm>
using namespace std;
Player::Player(){
	ijh = 0;
	blr = 1;
	hlwait = 1;
}
void Player::printmap(const char strmap[11][11], const bool bwait) {
	int i = 0;
	int ia = 0;
	cout << "\033[" << (!bwait || 2 < iheal ? "32;1m" : 2 == iheal ? "33m" : "31;1m") << "P * " << iheal << "\033[0m" << endl << endl << endl;
	for (cout << "-----------@" << endl; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : 'v' == strmap[i][ia] ? "36m" : '&' == strmap[i][ia] || '^' == strmap[i][ia] || 'o' == strmap[i][ia] || 'O' == strmap[i][ia] || 'X' == strmap[i][ia] ? "31;1m" : '+' == strmap[i][ia] || '#' == strmap[i][ia] ? "33m" : '@' == strmap[i][ia] ? "33m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
void Player::jump(char** cpp) {
	10 == ix || '*' == (*cpp)[11] && (ijh = JUMPHIGH);
}
void Player::left_move(char** cpp) {
	(iy && '*' != *(*cpp - 1) && ((*cpp)--));
	blr = false;
}
void Player::right_move(char** cpp) {
	10 != iy && '*' != *(*cpp + 1) && ((*cpp)++);
	blr = true;
}
int& Player::sgetxyhs(XYHS xyhsmode) {
	switch (xyhsmode) {
	case X:
		return ix;
		break;
	case Y:
		return iy;
		break;
	case HEAL:
		return iheal;
		break;
	default:
		break;
	}
}
vector<trir>* Player::sgetxyhs() {
	return &v;
}
void Player::upOrDown(char** cpp) {
	if (ijh > 0 && ix && '*' != (*cpp)[-11]) {
		ijh--, *cpp -= 11;
	}
	else if ('*' != (*cpp)[11] && (!ix || '*' == (*cpp)[-11])) {
		ijh = 0, *cpp += 11;
	}
	else if ('*' != (*cpp)[11] && 10 != ix) {
		*cpp += 11;
	}
	if (ijh > 0 && '*' == (*cpp)[11]) {
		ijh = 0;
	}
}
void Player::shoot(int& i, char** cpp) {
	if ((!i) && (iy && blr || 21 != iy && (!blr))) {
		v.push_back({ *cpp, iy, blr, 0 });
		i = 3;
	}
}
void Player::shootmove(const char(*strmap)[11][11], bool bmode) {
	if (bmode) {
		for (vector<trir>::iterator it = v.begin(); v.end() != it; it++) {
			(' ' == *it->cp || '@' == *it->cp) && (*it->cp = ' ');
			if ('*' == *it->cp || it->bk || (!it->iy && (!it->b)) || (21 == it->iy && it->b)) {
				it->iy = -1;//子弹的销毁
			}
			if (0 <= it->iy) {
				it->cp -= (1 - it->b * 2);
				it->iy -= (1 - it->b * 2);
				(' ' == *it->cp || '@' == *it->cp) && (*it->cp = '@');
			}
		}
	}
	else {
		sort(v.begin(), v.end(), cmp());
		while ((!v.empty()) && 0 > v.begin()->iy) {
			v.erase(v.begin());
		}
	}
}
*///“修复子弹穿墙的bug”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include "draw.h"
#define DEBUG
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	vo.reserve(99999);
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[16] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[100] = { &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[2][2], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[5][5]};//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new MUD(), new MUD(), new MUD(), new MUD(), new MUD(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), new MX(), new MX(), new MX(), new MX(), new MO(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), new Mplus()};//mpv里一共要有的怪物们(非常重要，容易报错)
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 6:
			for (itemp = i + 3; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 5:
			for (itemp = i + 4/*, vism[ch].str = "^v^v"*/; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 4:
			for (itemp = i + 4; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 3:
			for (itemp = i + 4; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 7:
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
		case 2:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
				}
				else {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, 5, 5);
				}
				
			}
			break;
		case 1:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 0:
			for (itemp = i + 5; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		//case 8:
			//未完成

			break;
		case 9:
			//未完成

			break;
		case 8:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
	vism.push_back(ism);
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 7:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 6:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 5:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 8:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 3:
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			case 2:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				strmap[8][5] = '*';
				strmap[6][3] = '*';
				strmap[6][7] = '*';
				strmap[4][5] = '*';
				break;
			case 1:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
				break;
			case 0:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
			case 10:

				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		else if (!bb && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			//未完成
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
			for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
				*drawcp = '#';
			}
		}
		p.printmap(strmap, ba);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = (ba ? ba = !ba, 2 : rand() % 4)) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			1 != vism.size() && (!(rand() % 4) && (3 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0) || (!(rand() % 2)) && (3 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0));//恢复血量
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“解决过关之后异常加血的bug”^
/*
//isvp.h
#pragma once
#include <iostream>
using namespace std;
#include <vector>
#include <string>
#include "moster.h"
struct isv {
	string str;//判断
	vector<moster*> vmp;
	int id;
};
*///“isv结构体的成员变量已改变”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include "draw.h"
#define DEBUG
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };
	vo.reserve(99999);
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[100] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[2][2], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[5][5]};//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new MO(), new Mand(), new Mand(), new MUD(), new MUD(), new MO(), new MX(), new MX(), new MO(), new MO(), new MO(), new MO(), new MO(), new MO(), new MO(), new MUD(), new MUD(), new MUD(), new MUD(), new MUD(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), new MX(), new MX(), new MX(), new MX(), new MO(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), new Mplus()};//mpv里一共要有的怪物们(非常重要，容易报错)
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 9:
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
				}
				else {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, 5, 5);
				}
				
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 10:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
	vism.push_back(ism);
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 9:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 8:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 7:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 10:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 5:
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				strmap[8][5] = '*';
				strmap[6][3] = '*';
				strmap[6][7] = '*';
				strmap[4][5] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
			case 1:
				strmap[2][8] = '*';
				break;
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		else if (!bb && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			//未完成
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
			for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
				*drawcp = '#';
			}
		}
		p.printmap(strmap, ba);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = (ba ? ba = !ba, 2 : rand() % 4)) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (b = 0, ch = 1; ch < 10; ch++) {
				for (i = 1; i < 10; i++) {
					strmap[ch][i] = ' ';
				}
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			1 != vism.size() && (!(rand() % 4) && (3 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0) || (!(rand() % 2)) && (3 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0));//恢复血量
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“所有地牢都已构造完毕”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
#define DEBUG
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };
	vo.reserve(99999);
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[100] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[2][2], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[5][5]};//请注意先后顺序，否则会出bug
	/*会改*/vector<moster*>mpv = { new MO(), new Mand(), new Mand(), new MUD(), new MUD(), new MO(), new MX(), new MX(), new MO(), new MO(), new MO(), new MO(), new MO(), new MO(), new MO(), new MUD(), new MUD(), new MUD(), new MUD(), new MUD(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), new MX(), new MX(), new MX(), new MX(), new MO(), new MO(), new MO(), new MO(), new MO(), new MX(), new MX(), new MX(), new MX(), new Mand(), new Mand(), new Mand(), new MUD(), new MUD(), new MUD(), new MUD(), new Mplus()};//mpv里一共要有的怪物们(非常重要，容易报错)
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 9:
			vism[ch].str = "+";
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
				}
				else {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, 5, 5);
				}
				
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 10:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	//random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除不重要的东西
	}
	vism.push_back(ism);
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 9:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 8:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 7:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			break;
			case 10:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 5:
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				strmap[8][5] = '*';
				strmap[6][3] = '*';
				strmap[6][7] = '*';
				strmap[4][5] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
			case 1:
				strmap[2][8] = '*';
				break;
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		else if (!bb && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			//未完成
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
			for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
				*drawcp = '#';
			}
		}
		p.printmap(strmap, ba);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = (ba ? ba = !ba, 2 : rand() % 4)) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if ('P' == strmap[9][10]) {
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i);
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11);
			Sleep(100);
			system("cls");
			1 != vism.size() && (!(rand() % 4) && (3 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0) || (!(rand() % 2)) && (3 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0));//恢复血量
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C'), bb || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“滚动卷轴式切换地图已完成”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
#define DEBUG
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };
	vo.reserve(99999);
	int i = 0;
	int ia = rand() % 11;
	ia += ia / 2;
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[50] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[2][2], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[5][5]};
	vector<moster*>mpv;//mpv里一共要有的怪物们
	mpv.reserve(10000);
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 12], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 18], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 18], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 23], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 23], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 27], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 4, NULL, NULL, NULL, 0, 0, i % 2, (i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 38], 3, NULL, NULL, NULL, 0, 0, i % 2);
			}
			break;
			vism[ch].vmp.push_back(mpv[i]);
			vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i++], 10);
			break;
		case 9:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				strcp[i] = (&strmap[pxy.first][pxy.second]);
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[i], 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);
	vism.back().id = 10;
	vism.back().vmp.push_back(new Mplus());
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				strmap[8][5] = '*';
				strmap[6][3] = '*';
				strmap[6][7] = '*';
				strmap[4][5] = '*';
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
			for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
				*drawcp = '#';
			}
		}
		p.printmap(strmap, ba);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = (ba ? ba = !ba, 2 : rand() % 4)) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			strmap[9][0] = ' ';
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i);
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11);
			Sleep(100);
			system("cls");
			1 != vism.size() && (!(rand() % 4) && (3 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0) || (!(rand() % 2)) && (3 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0));//恢复血量
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C') || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“地牢已随机化”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
#define DEBUG
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			tempir += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[2][2], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[5][5], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[5][1], &strmap[5][9], &strmap[3][4], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[5][5]};
	vector<moster*>mpv;//mpv里一共要有的怪物们
	mpv.reserve(10000);
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 13], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 19], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 19], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 24], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 24], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 28], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 32], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 36], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 39], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
			vism[ch].vmp.push_back(mpv[i]);
			
			break;
		case 9:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				char* tempcp = &strmap[pxy.first][pxy.second];
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &tempcp, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &tempcp, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &tempcp, 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &tempcp, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[46], 10);
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				strmap[8][5] = '*';
				strmap[6][3] = '*';
				strmap[6][7] = '*';
				strmap[4][5] = '*';
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
			for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
				*drawcp = '#';
			}
		}
		p.printmap(strmap, ba);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = (ba ? ba = !ba, 2 : rand() % 4)) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			strmap[9][0] = ' ';
			b = 0;
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i);
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11);
			Sleep(100);
			system("cls");
			1 != vism.size() && (!(rand() % 4) && (3 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0) || (!(rand() % 2)) && (3 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0));//恢复血量
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C') || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“地图生成bug已修复”^
/*
//Game.cpp
#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
#define DEBUG
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};
	vector<moster*>mpv;//mpv里一共要有的怪物们
	mpv.reserve(10000);
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				char* tempcp = &strmap[pxy.first][pxy.second];
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &tempcp, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &tempcp, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &tempcp, 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &tempcp, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[45], 10);
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				strmap[8][5] = '*';
				strmap[6][3] = '*';
				strmap[6][7] = '*';
				strmap[4][5] = '*';
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
			for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
				*drawcp = '#';
			}
		}
		p.printmap(strmap, ba);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = (ba ? ba = !ba, 2 : rand() % 4)) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			strmap[9][0] = ' ';
			b = 0;
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i);
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11);
			Sleep(100);
			system("cls");
			1 != vism.size() && (!(rand() % 4) && (3 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0) || (!(rand() % 2)) && (3 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0));//恢复血量
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C') || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“怪物生成坐标错误bug已修复”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
#define DEBUG
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
void start(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};
	vector<moster*>mpv;//mpv里一共要有的怪物们
	mpv.reserve(10000);
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				char* tempcp = &strmap[pxy.first][pxy.second];
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &tempcp, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &tempcp, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &tempcp, 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), &tempcp, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[45], 10);
#ifdef DEBUG
	p.sgetxyhs(HEAL) = 999;//设置默认生命值
#else 
	p.sgetxyhs(HEAL) = 3;
#endif
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	//system("pause");
	//system("cls");
	char str[9] = "color 0";
	//开始界面
	for (i = 0; i < 15; i++) {
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 10; i++) {
		char tempstr[9] = "color 0";
		char tempstra[10][2] = {"C", "E", "A", "9", "D", "9", "A", "E", "C", "7"};
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		Sleep(100);
	}
	Sleep(500);
	cout << endl << endl << endl;
	cout << "           \033[33m@---------------------------@" << endl;
	cout << "           |     \033[32;1m1. 开始    \033[0;31;1m0. 退出    \033[0;33m|" << endl;
	cout << "           @---------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while (ch < '0' || ch > '1') {
		cin >> ch;
		ch < '0' || ch > '1' && cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
	}
	if ('0' == ch) {
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				strmap[8][5] = '*';
				strmap[6][3] = '*';
				strmap[6][7] = '*';
				strmap[4][5] = '*';
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
			for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
				*drawcp = '#';
			}
		}
		p.printmap(strmap, ba);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = (ba ? ba = !ba, 2 : rand() % 4)) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			strmap[9][0] = ' ';
			b = 0;
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i);
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11);
			Sleep(100);
			system("cls");
			1 != vism.size() && (!(rand() % 4) && (3 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0) || (!(rand() % 2)) && (3 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0));//恢复血量
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C') || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“开始界面已完成”^
/*
//要展示的文件太多，请见“https://gitee.com/i-a-h/cpp/tree/master/%E6%89%93%E5%B0%8F%E6%80%AA%E6%B8%B8%E6%88%8F”
*///“打小怪游戏已完成”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
void start(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};
	vector<moster*>mpv;//mpv里一共要有的怪物们
	mpv.reserve(10000);
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				char** tempcpp = tempcparr;
				*tempcpp = &strmap[pxy.first][pxy.second];
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[45], 10);
	p.sgetxyhs(HEAL) = 8;
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	//开始界面
	for (i = 0; i < 15; i++) {
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 10; i++) {
		char tempstr[9] = "color 0";
		char tempstra[10][2] = {"C", "E", "A", "9", "D", "9", "A", "E", "C", "7"};
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		Sleep(100);
	}
	Sleep(500);
	cout << endl << endl << endl;
	cout << "           \033[33m@---------------------------@" << endl;
	cout << "           |     \033[32;1m1. 开始    \033[0;31;1m0. 退出    \033[0;33m|" << endl;
	cout << "           @---------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while (ch < '0' || ch > '1') {
		cin >> ch;
		ch < '0' || ch > '1' && cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
	}
	if ('0' == ch) {
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				strmap[8][5] = '*';
				strmap[6][3] = '*';
				strmap[6][7] = '*';
				strmap[4][5] = '*';
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
			for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
				*drawcp = '#';
			}
		}
		p.printmap(strmap, ba);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = (ba ? ba = !ba, 2 : rand() % 4)) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			strmap[9][0] = ' ';
			b = 0;
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i);
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11);
			Sleep(100);
			system("cls");
			1 != vism.size() && (!(rand() % 4) && (8 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0) || (!(rand() % 2)) && (8 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0));//恢复血量
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C') || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“血量调整到8血”^
/*
//Player.cpp
#include <iostream>
#include "Player.h"
#include "cmp.h"
#include <algorithm>
using namespace std;
Player::Player(){
	ijh = 0;
	blr = 1;
	hlwait = 1;
}
void Player::printmap(const char strmap[11][11], const bool bwait) {
	int i = 0;
	int ia = 0;
	cout << "\033[" << (!bwait || 5 < iheal ? "32;1m" : 2 < iheal ? "33m" : "31;1m") << "P * " << iheal << "\033[0m" << endl << endl << endl;
	for (cout << "-----------@" << endl; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : 'v' == strmap[i][ia] ? "36m" : '&' == strmap[i][ia] || '^' == strmap[i][ia] || 'o' == strmap[i][ia] || 'O' == strmap[i][ia] || 'X' == strmap[i][ia] ? "31;1m" : '+' == strmap[i][ia] || '#' == strmap[i][ia] ? "33m" : '@' == strmap[i][ia] ? "33m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
void Player::printmap(char(*strmap)[11][11], const bool bwait, const int ir) {
	int i = 0;
	int ia = 0;
	cout << "\033[" << (!bwait || 2 < iheal ? "32;1m" : 2 == iheal ? "33m" : "31;1m") << "P * " << iheal << "\033[0m" << endl << endl << endl;
	for (cout << "-----------@" << endl; i < 11; i++) {
		for (ia = ir; 11 > ia - ir; ia++) {
			cout << (*strmap)[i][ia % 11];
			21 > ia && ia >= 12 && i && 10 != i && ((*strmap)[i][ia % 11] = ' ');
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
void Player::jump(char** cpp) {
	10 == ix || '*' == (*cpp)[11] && (ijh = JUMPHIGH);
}
void Player::left_move(char** cpp) {
	(iy && '*' != *(*cpp - 1) && ((*cpp)--));
	blr = false;
}
void Player::right_move(char** cpp) {
	10 != iy && '*' != *(*cpp + 1) && ((*cpp)++);
	blr = true;
}
int& Player::sgetxyhs(XYHS xyhsmode) {
	switch (xyhsmode) {
	case X:
		return ix;
		break;
	case Y:
		return iy;
		break;
	case HEAL:
		return iheal;
		break;
	default:
		break;
	}
}
vector<trir>* Player::sgetxyhs() {
	return &v;
}
void Player::upOrDown(char** cpp) {
	if (ijh > 0 && ix && '*' != (*cpp)[-11]) {
		ijh--, *cpp -= 11;
	}
	else if ('*' != (*cpp)[11] && (!ix || '*' == (*cpp)[-11])) {
		ijh = 0, *cpp += 11;
	}
	else if ('*' != (*cpp)[11] && 10 != ix) {
		*cpp += 11;
	}
	if (ijh > 0 && '*' == (*cpp)[11]) {
		ijh = 0;
	}
}
void Player::shoot(int& i, char** cpp) {
	if ((!i) && (iy && blr || 21 != iy && (!blr))) {
		v.push_back({ *cpp, iy, blr, 0 });
		i = 3;
	}
}
void Player::shootmove(const char(*strmap)[11][11], bool bmode) {
	if (bmode) {
		for (vector<trir>::iterator it = v.begin(); v.end() != it; it++) {
			(' ' == *it->cp || '@' == *it->cp) && (*it->cp = ' ');
			if ('*' == *it->cp || it->bk || (!it->iy && (!it->b)) || (21 == it->iy && it->b)) {
				it->iy = -1;//子弹的销毁
			}
			if (0 <= it->iy) {
				it->cp -= (1 - it->b * 2);
				it->iy -= (1 - it->b * 2);
				(' ' == *it->cp || '@' == *it->cp) && (*it->cp = '@');
			}
		}
	}
	else {
		sort(v.begin(), v.end(), cmp());
		while ((!v.empty()) && 0 > v.begin()->iy) {
			v.erase(v.begin());
		}
	}
}
*///“血量显示机制已更改”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
void start(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *         * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	char ch = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};
	vector<moster*>mpv;//mpv里一共要有的怪物们
	mpv.reserve(10000);
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				char** tempcpp = tempcparr;
				*tempcpp = &strmap[pxy.first][pxy.second];
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[45], 10);
	p.sgetxyhs(HEAL) = 8;
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;
	//开始界面
	for (i = 0; i < 15; i++) {
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 10; i++) {
		char tempstr[9] = "color 0";
		char tempstra[10][2] = {"C", "E", "A", "9", "D", "9", "A", "E", "C", "7"};
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		Sleep(100);
	}
	Sleep(500);
	cout << endl << endl << endl;
	cout << "           \033[33m@---------------------------------------------@" << endl;
	cout << "           |                                             |" << endl;
	cout << "           |     \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m |" << endl;
	cout << "           |                                             |" << endl;
	cout << "           |     3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m |" << endl;
	cout << "           |                                             |" << endl;
	cout << "           |     \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m           |" << endl;
	cout << "           |                                             |" << endl;
	cout << "           @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {
		cin >> ch;
		if ('1' == ch) {
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				strmap[8][5] = '*';
				strmap[6][3] = '*';
				strmap[6][7] = '*';
				strmap[4][5] = '*';
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
			for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
				*drawcp = '#';
			}
		}
		p.printmap(strmap, ba);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = (ba ? ba = !ba, 2 : rand() % 4)) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a"), (' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			strmap[9][0] = ' ';
			b = 0;
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i);
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11);
			Sleep(100);
			system("cls");
			1 != vism.size() && (!(rand() % 4) && (8 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0) || (!(rand() % 2)) && (8 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0));//恢复血量
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
	}
	bb && (str[7] = 'C') || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“开始菜单功能已全部完成”^
/*
//Player.h
#pragma once
#include <iostream>
using namespace std;
#include <vector>
#define JUMPHIGH 3
#ifndef oncea
#define oncea
enum XYHS {
	X,
	Y,
	HEAL,
};
struct trir {
	char* cp;
	int iy;
	bool b;//0< 1>
	bool bk;//是否杀过怪物
};
class Player {
private:
	int ix;
	int iy;
	int ijh;
	int iheal;
	bool blr;
	bool hlwait;
	vector<trir> v;
public:
	Player();
	void printmap(const char strmap[11][11], const bool bwait, const int iunmd);
	void printmap(char(*strmap)[11][11], const bool bwait, const int ir, const int iunmd);
	void jump(char** cpp);
	void left_move(char** cpp);
	void right_move(char** cpp);
	int& sgetxyhs(XYHS xyhsmode);
	vector<trir>* sgetxyhs();
	void upOrDown(char** cpp);
	void shoot(int& i, char** cpp);
	void shootmove(const char(*strmap)[11][11], bool bmode);
};
#endif
//Player.cpp
#include <iostream>
#include "Player.h"
#include "cmp.h"
#include <algorithm>
using namespace std;
Player::Player(){
	ijh = 0;
	blr = 1;
	hlwait = 1;
}
void Player::printmap(const char strmap[11][11], const bool bwait, const int iunmd) {
	int i = 0;
	int ia = 0;
	cout << "\033[" << (!bwait || 5 < iheal ? "32;1m" : 2 < iheal ? "33m" : "31;1m") << "P * " << iheal << "\033[0m" << endl << endl << endl;
	for (cout << "-----------@" << endl; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : 'v' == strmap[i][ia] ? "36m" : '&' == strmap[i][ia] || '^' == strmap[i][ia] || 'o' == strmap[i][ia] || 'O' == strmap[i][ia] || 'X' == strmap[i][ia] ? "31;1m" : '+' == strmap[i][ia] || '#' == strmap[i][ia] ? "33m" : '@' == strmap[i][ia] ? "33m" : 'P' == strmap[i][ia] && iunmd ? "30;1m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
void Player::printmap(char(*strmap)[11][11], const bool bwait, const int ir, const int iunmd) {
	int i = 0;
	int ia = 0;
	cout << "\033[" << (!bwait || 5 < iheal ? "32;1m" : 2 < iheal ? "33m" : "31;1m") << "P * " << iheal << "\033[0m" << endl << endl << endl;
	for (cout << "-----------@" << endl; i < 11; i++) {
		for (ia = ir; 11 > ia - ir; ia++) {
			cout << "\033[" << ('P' == (*strmap)[i][ia % 11] && iunmd ? "40;1m" : "0m") << (*strmap)[i][ia % 11] << "\033[0m";
			21 > ia && ia >= 12 && i && 10 != i && ((*strmap)[i][ia % 11] = ' ');
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
void Player::jump(char** cpp) {
	10 == ix || '*' == (*cpp)[11] && (ijh = JUMPHIGH);
}
void Player::left_move(char** cpp) {
	(iy && '*' != *(*cpp - 1) && ((*cpp)--));
	blr = false;
}
void Player::right_move(char** cpp) {
	10 != iy && '*' != *(*cpp + 1) && ((*cpp)++);
	blr = true;
}
int& Player::sgetxyhs(XYHS xyhsmode) {
	switch (xyhsmode) {
	case X:
		return ix;
		break;
	case Y:
		return iy;
		break;
	case HEAL:
		return iheal;
		break;
	default:
		break;
	}
}
vector<trir>* Player::sgetxyhs() {
	return &v;
}
void Player::upOrDown(char** cpp) {
	if (ijh > 0 && ix && '*' != (*cpp)[-11]) {
		ijh--, *cpp -= 11;
	}
	else if ('*' != (*cpp)[11] && (!ix || '*' == (*cpp)[-11])) {
		ijh = 0, *cpp += 11;
	}
	else if ('*' != (*cpp)[11] && 10 != ix) {
		*cpp += 11;
	}
	if (ijh > 0 && '*' == (*cpp)[11]) {
		ijh = 0;
	}
}
void Player::shoot(int& i, char** cpp) {
	if ((!i) && (iy && blr || 21 != iy && (!blr))) {
		v.push_back({ *cpp, iy, blr, 0 });
		i = 3;
	}
}
void Player::shootmove(const char(*strmap)[11][11], bool bmode) {
	if (bmode) {
		for (vector<trir>::iterator it = v.begin(); v.end() != it; it++) {
			(' ' == *it->cp || '@' == *it->cp) && (*it->cp = ' ');
			if ('*' == *it->cp || it->bk || (!it->iy && (!it->b)) || (21 == it->iy && it->b)) {
				it->iy = -1;//子弹的销毁
			}
			if (0 <= it->iy) {
				it->cp -= (1 - it->b * 2);
				it->iy -= (1 - it->b * 2);
				(' ' == *it->cp || '@' == *it->cp) && (*it->cp = '@');
			}
		}
	}
	else {
		sort(v.begin(), v.end(), cmp());
		while ((!v.empty()) && 0 > v.begin()->iy) {
			v.erase(v.begin());
		}
	}
}
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
void start(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *         * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C", "7" };
	mpv.reserve(10000);
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				char** tempcpp = tempcparr;
				*tempcpp = &strmap[pxy.first][pxy.second];
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[45], 10);
	p.sgetxyhs(HEAL) = 8;
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;
	//开始界面
	for (i = 0; i < 15; i++) {
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 10; i++) {
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		Sleep(100);
	}
	tempstr[7] = 0;
	Sleep(500);
	cout << endl << endl << endl;
	cout << "           \033[33m@---------------------------------------------@" << endl;
	cout << "           |                                             |" << endl;
	cout << "           |     \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m |" << endl;
	cout << "           |                                             |" << endl;
	cout << "           |     3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m |" << endl;
	cout << "           |                                             |" << endl;
	cout << "           |     \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m           |" << endl;
	cout << "           |                                             |" << endl;
	cout << "           @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {
		cin >> ch;
		if ('1' == ch) {
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				strmap[8][5] = '*';
				strmap[6][3] = '*';
				strmap[6][7] = '*';
				strmap[4][5] = '*';
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
			for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
				*drawcp = '#';
			}
		}
		p.printmap(strmap, ba, iunmd);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a", iunmd = 2);
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = (ba ? ba = !ba, 2 : rand() % 4)) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, "\a", iunmd = 2), (iunmd || ' ' == *cp || '@' == *cp) && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			strmap[9][0] = ' ';
			b = 0;
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			1 != vism.size() && (!(rand() % 4) && (8 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0) || (!(rand() % 2)) && (8 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0));//恢复血量
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	bb && (str[7] = 'C') || (str[7] = 'A');
	system(str);
	cout << (bb ? "很遗憾，你输了" : "恭喜你，你赢了") << endl;
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“添加玩家受伤后无敌回合”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
void start(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *      *  * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C" };
	mpv.reserve(10000);
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				char** tempcpp = tempcparr;
				*tempcpp = &strmap[pxy.first][pxy.second];
				switch (rand() % 3) {
				case 0:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 1:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 2:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 3, NULL, &cp, &strmap);
					break;
				case 3:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcpp++, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[45], 10);
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;
	//开始界面
	for (i = 0; i < 15; i++) {
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 9; i++) {
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		tempstr[7] = 0;
		Sleep(100);
	}
	system("color 07");
	Sleep(500);
	cout << endl << endl << endl;
	cout << "           \033[33m@---------------------------------------------@" << endl;
	cout << "           |                                             |" << endl;
	cout << "           |     \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m |" << endl;
	cout << "           |                                             |" << endl;
	cout << "           |     3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m |" << endl;
	cout << "           |                                             |" << endl;
	cout << "           |     \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m           |" << endl;
	cout << "           |                                             |" << endl;
	cout << "           @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {
		cin >> ch;
		if ('1' == ch) {
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');
	int temparra[4] = { 8, 5, 3, 1 };
	p.sgetxyhs(HEAL) = temparra[d];
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				strmap[8][5] = '*';
				strmap[6][3] = '*';
				strmap[6][7] = '*';
				strmap[4][5] = '*';
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
			for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
				*drawcp = '#';
			}
		}
		p.printmap(strmap, ba, iunmd);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (ir = (ba ? ba = !ba, 2 : rand() % 4)) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12,-11,-10,-1,1,10,11,12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		'*' != *cp && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp为空，那么开门，并头删
		if (vism.front().vmp.empty() && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			strmap[9][0] = ' ';
			b = 0;
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			1 != vism.size() && (!(rand() % 4) && (8 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0) || (!(rand() % 2)) && (8 > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0));//恢复血量
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	char tempstrb[6] = "C2AA7";
	str[7] = tempstrb[(!bb) * (d + 1)];
	system(str);
	switch ((!bb) * (d + 1)) {
	case 0:
		cout << "很遗憾，你输了" << endl;
		break;
	case 1:
	case 2:
		cout << "恭喜你，你赢了" << endl;
		break;
	case 3:
		cout << "@------------------@" << endl;
		cout << "|                  |" << endl;
		cout << "|  恭喜你，你赢了  |" << endl;
		cout << "|                  |" << endl;
		cout << "@------------------@" << endl;
		break;
	case 4:
		for (i = 0; i < 15; i++) {
			system("cls");
			win(i);
			Sleep(10);
		}
		for (i = 0; i < 27; i++) {
			strcat(tempstr, tempstra[i % 9]);
			system(tempstr);
			tempstr[7] = 0;
			Sleep(100);
		}
		system("color 0A");
		break;
	default:
		break;
	}
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“开始时血量与告知你胜利方式已由难度而变化”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
void start(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *      *  * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	bool bc = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	vism.reserve(300);
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C" };
	mpv.reserve(10000);
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second || 7 <= pxy.first && 3 >= pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				tempcparr[itemp - i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 7) {
				case 0:
				case 1:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 2:
				case 3:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 4:
				case 5:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, &cp, &strmap);
					break;
				case 6:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[46], 10);
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;
	//开始界面
	for (i = 0; i < 15; i++) {
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 9; i++) {
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		tempstr[7] = 0;
		Sleep(100);
	}
	system("color 07");
	Sleep(500);
	cout << endl << endl << endl;
	cout << " \033[33m@---------------------------------------------@" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m             |" << endl;
	cout << " |                                             |" << endl;
	cout << " @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {
		cin >> ch;
		if ('1' == ch) {
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m，并且不同的\033[31;1m难度\033[0m也有不同的\033[32;1m战前回血概率\033[0m与\033[31;1m小BOSS\033[32m战前回血概率\033[0m，\033[4m越\033[31;1m难\033[0;4m这个概率就越\033[31;1m小\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');
	int temparra[4] = { 8, 5, 3, 1 };
	p.sgetxyhs(HEAL) = temparra[d];
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				{
					int arr[12] = { 8, 5, 6, 3, 6, 7, 4, 5, 8, 9, 4, 1 };
					for (i = 0; i < 12; i += 2) {
						strmap[arr[i]][arr[i + 1]] = '*';
					}
				}
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		if (vism.size()) {
			for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
				for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
					*drawcp = '#';
				}
			}
		}
		p.printmap(strmap, ba, iunmd);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (bc ? (bc = 0, 2) : rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		'*' != *cp && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp或者vism为空为空，那么开门，并头删
		if ((vism.empty() || vism.front().vmp.empty()) && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			b = 0;
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				'*' != *it->cp && (*it->cp = ' ');
			}
			p.sgetxyhs()->clear();
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				!i && (strmap[9][0] = ' ');
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			bool temparrb[8] = { 1, 1, !(rand() % 2), 1, !(rand() % 4), !(rand() % 2), 0, 0};
			1 != vism.size() && (temparrb[d * 2] && (temparra[d] > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0)) || (temparrb[d * 2 + 1] && (temparra[d] > p.sgetxyhs(HEAL) && p.sgetxyhs(HEAL)++, ba = 0));//恢复血量
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	char tempstrb[6] = "C2AA7";
	str[7] = tempstrb[(!bb) * (d + 1)];
	system(str);
	switch ((!bb) * (d + 1)) {
	case 0:
		cout << "很遗憾，你输了" << endl;
		break;
	case 1:
	case 2:
		cout << "恭喜你，你赢了" << endl;
		break;
	case 3:
		cout << "@------------------@" << endl;
		cout << "|                  |" << endl;
		cout << "|  恭喜你，你赢了  |" << endl;
		cout << "|                  |" << endl;
		cout << "@------------------@" << endl;
		break;
	case 4:
		for (i = 0; i < 15; i++) {
			system("cls");
			win(i);
			Sleep(10);
		}
		for (i = 0; i < 27; i++) {
			strcat(tempstr, tempstra[i % 9]);
			system(tempstr);
			tempstr[7] = 0;
			Sleep(100);
		}
		system("color 0A");
		break;
	default:
		break;
	}
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“游戏已经可以胜利”^
/*
//Player.cpp
#include <iostream>
#include "Player.h"
#include "cmp.h"
#include <algorithm>
#include <Windows.h>
using namespace std;
Player::Player(){
	ijh = 0;
	blr = 1;
	hlwait = 1;
}
void Player::printmap(const char strmap[11][11], const bool bwait, const int iunmd) {
	int i = 0;
	int ia = 0;
	cout << "\033[" << (!bwait || 5 < iheal ? "32;1m" : 2 < iheal ? "33m" : "31;1m") << "P * " << iheal << "\033[0m" << endl << endl << endl;
	for (cout << "-----------@" << endl; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : 'v' == strmap[i][ia] ? "36m" : '&' == strmap[i][ia] || '^' == strmap[i][ia] || 'o' == strmap[i][ia] || 'O' == strmap[i][ia] || 'X' == strmap[i][ia] ? "31;1m" : '+' == strmap[i][ia] || '#' == strmap[i][ia] ? "33m" : '@' == strmap[i][ia] ? "33m" : 'P' == strmap[i][ia] && iunmd ? "30;1m" : "0m") << strmap[i][ia] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
void Player::printmap(char(*strmap)[11][11], const bool bwait, const int ir, const int iunmd) {
	int i = 0;
	int ia = 0;
	cout << "\033[" << (!bwait || 5 < iheal ? "32;1m" : 2 < iheal ? "33m" : "31;1m") << "P * " << iheal << "\033[0m" << endl << endl << endl;
	for (cout << "-----------@" << endl; i < 11; i++) {
		for (ia = ir; 11 > ia - ir; ia++) {
			21 > ia && ia >= 12 && i && 10 != i && ((*strmap)[i][ia % 11] = ' ');
			cout << "\033[" << ('P' == (*strmap)[i][ia % 11] && iunmd ? "40;1m" : "0m") << (*strmap)[i][ia % 11] << "\033[0m";
		}
		cout << "|" << endl;
	}
	cout << "-----------@" << endl;
}
void Player::jump(char** cpp) {
	10 == ix || '*' == (*cpp)[11] && (ijh = JUMPHIGH);
}
void Player::left_move(char** cpp) {
	(iy && '*' != *(*cpp - 1) && ((*cpp)--));
	blr = false;
}
void Player::right_move(char** cpp) {
	10 != iy && '*' != *(*cpp + 1) && ((*cpp)++);
	blr = true;
}
int& Player::sgetxyhs(XYHS xyhsmode) {
	switch (xyhsmode) {
	case X:
		return ix;
		break;
	case Y:
		return iy;
		break;
	case HEAL:
		return iheal;
		break;
	default:
		break;
	}
}
vector<trir>* Player::sgetxyhs() {
	return &v;
}
void Player::upOrDown(char** cpp) {
	if (ijh > 0 && ix && '*' != (*cpp)[-11]) {
		ijh--, *cpp -= 11;
	}
	else if ('*' != (*cpp)[11] && (!ix || '*' == (*cpp)[-11])) {
		ijh = 0, *cpp += 11;
	}
	else if ('*' != (*cpp)[11] && 10 != ix) {
		*cpp += 11;
	}
	if (ijh > 0 && '*' == (*cpp)[11]) {
		ijh = 0;
	}
}
void Player::shoot(int& i, char** cpp) {
	if ((!i) && (iy && blr || 21 != iy && (!blr))) {
		v.push_back({ *cpp, iy, blr, 0 });
		i = 3;
	}
}
void Player::shootmove(const char(*strmap)[11][11], bool bmode) {
	if (bmode) {
		for (vector<trir>::iterator it = v.begin(); v.end() != it; it++) {
			(' ' == *it->cp || '@' == *it->cp) && (*it->cp = ' ');
			if ('*' == *it->cp || it->bk || (!it->iy && (!it->b)) || (21 == it->iy && it->b)) {
				it->iy = -1;//子弹的销毁
			}
			if (0 <= it->iy) {
				it->cp -= (1 - it->b * 2);
				it->iy -= (1 - it->b * 2);
				(' ' == *it->cp || '@' == *it->cp) && (*it->cp = '@');
			}
		}
	}
	else {
		sort(v.begin(), v.end(), cmp());
		while ((!v.empty()) && 0 > v.begin()->iy) {
			v.erase(v.begin());
		}
	}
}
*///“已更改Player类的printmap重载函数的显示机制”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
void start(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *      *  * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	bool bc = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	vism.reserve(100);
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C" };
	mpv.reserve(10000);
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second || 7 <= pxy.first && 3 >= pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				tempcparr[itemp - i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 7) {
				case 0:
				case 1:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 2:
				case 3:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 4:
				case 5:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, &cp, &strmap);
					break;
				case 6:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[46], 10);
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;
	//开始界面
	for (i = 0; i < 15; i++) {
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 9; i++) {
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		tempstr[7] = 0;
		Sleep(100);
	}
	system("color 07");
	Sleep(500);
	cout << endl << endl << endl;
	cout << " \033[33m@---------------------------------------------@" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m             |" << endl;
	cout << " |                                             |" << endl;
	cout << " @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {
		cin >> ch;
		if ('1' == ch) {
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m，并且不同的\033[31;1m难度\033[0m也有不同的\033[32;1m战前回血概率\033[0m与\033[31;1m小BOSS\033[32m战前回血概率\033[0m，\033[4m越\033[31;1m难\033[0;4m这个概率就越\033[31;1m小\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');
	int temparra[4] = { 8, 5, 3, 1 };
	p.sgetxyhs(HEAL) = temparra[d];
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				{
					int arr[12] = { 8, 5, 6, 3, 6, 7, 4, 5, 8, 9, 4, 1 };
					for (i = 0; i < 12; i += 2) {
						strmap[arr[i]][arr[i + 1]] = '*';
					}
				}
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		if (vism.size()) {
			for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
				for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
					*drawcp = '#';
				}
			}
		}
		p.printmap(strmap, ba, iunmd);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (bc ? (bc = 0, 2) : rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		'*' != *cp && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp或者vism为空，那么开门，并头删
		if ((vism.empty() || vism.front().vmp.empty()) && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			b = 0;
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				'*' != *it->cp && (*it->cp = ' ');
			}
			p.sgetxyhs()->clear();
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				!i && (strmap[9][0] = ' ');
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			bool temparrb[8] = { 1, 1, !(rand() % 2), 1, !(rand() % 4), !(rand() % 2), 0, 0};
			if (1 != vism.size()) {//恢复血量
				temparrb[d * 2] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
		    }
		    else {
				temparrb[d * 2 + 1] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
			}
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	char tempstrb[6] = "C2AA7";
	str[7] = tempstrb[(!bb) * (d + 1)];
	system(str);
	switch ((!bb) * (d + 1)) {
	case 0:
		cout << "很遗憾，你输了" << endl;
		break;
	case 1:
	case 2:
		cout << "恭喜你，你赢了" << endl;
		break;
	case 3:
		cout << "@------------------@" << endl;
		cout << "|                  |" << endl;
		cout << "|  恭喜你，你赢了  |" << endl;
		cout << "|                  |" << endl;
		cout << "@------------------@" << endl;
		break;
	case 4:
		for (i = 0; i < 15; i++) {
			system("cls");
			win(i);
			Sleep(10);
		}
		for (i = 0; i < 27; i++) {
			strcat(tempstr, tempstra[i % 9]);
			system(tempstr);
			tempstr[7] = 0;
			Sleep(100);
		}
		system("color 0A");
		break;
	default:
		break;
	}
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“战后回血功能多次调用bug已修复”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
void start(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *      *  * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	bool bc = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	vism.reserve(1000);
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C" };
	mpv.reserve(10000);
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism.back().vmp.reserve(100);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second || 7 <= pxy.first && 3 >= pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				tempcparr[itemp - i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 7) {
				case 0:
				case 1:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 2:
				case 3:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 4:
				case 5:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, &cp, &strmap);
					break;
				case 6:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[46], 10);
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;
	//开始界面
	for (i = 0; i < 15; i++) {
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 9; i++) {
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		tempstr[7] = 0;
		Sleep(100);
	}
	system("color 07");
	Sleep(500);
	cout << endl << endl << endl;
	cout << " \033[33m@---------------------------------------------@" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m             |" << endl;
	cout << " |                                             |" << endl;
	cout << " @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {
		cin >> ch;
		if ('1' == ch) {
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m，并且不同的\033[31;1m难度\033[0m也有不同的\033[32;1m战前回血概率\033[0m与\033[31;1m小BOSS\033[32m战前回血概率\033[0m，\033[4m越\033[31;1m难\033[0;4m这个概率就越\033[31;1m小\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');
	int temparra[4] = { 8, 5, 3, 1 };
	p.sgetxyhs(HEAL) = temparra[d];
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				{
					int arr[12] = { 8, 5, 6, 3, 6, 7, 4, 5, 8, 9, 4, 1 };
					for (i = 0; i < 12; i += 2) {
						strmap[arr[i]][arr[i + 1]] = '*';
					}
				}
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		if (vism.size()) {
			for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
				for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
					*drawcp = '#';
				}
			}
		}
		p.printmap(strmap, ba, iunmd);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (bc ? (bc = 0, 2) : rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front()/* <- 会改 */.vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		'*' != *cp && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp或者vism为空，那么开门，并头删
		if ((vism.empty() || vism.front().vmp.empty()) && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			b = 0;
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				'*' != *it->cp && (*it->cp = ' ');
			}
			p.sgetxyhs()->clear();
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				!i && (strmap[9][0] = ' ');
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			bool temparrb[8] = { 1, 1, !(rand() % 2), 1, !(rand() % 4), !(rand() % 2), 0, 0};
			if (1 != vism.size()) {//恢复血量
				temparrb[d * 2] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
		    }
		    else {
				temparrb[d * 2 + 1] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
			}
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	char tempstrb[6] = "C2AA7";
	str[7] = tempstrb[(!bb) * (d + 1)];
	system(str);
	switch ((!bb) * (d + 1)) {
	case 0:
		cout << "很遗憾，你输了" << endl;
		break;
	case 1:
	case 2:
		cout << "恭喜你，你赢了" << endl;
		break;
	case 3:
		cout << "@------------------@" << endl;
		cout << "|                  |" << endl;
		cout << "|  恭喜你，你赢了  |" << endl;
		cout << "|                  |" << endl;
		cout << "@------------------@" << endl;
		break;
	case 4:
		for (i = 0; i < 15; i++) {
			system("cls");
			win(i);
			Sleep(10);
		}
		for (i = 0; i < 27; i++) {
			strcat(tempstr, tempstra[i % 9]);
			system(tempstr);
			tempstr[7] = 0;
			Sleep(100);
		}
		system("color 0A");
		break;
	default:
		break;
	}
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“地牢怪物生成bug已修复”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');
}
void start(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *      *  * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	bool bc = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	vism.reserve(1000);
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C" };
	mpv.reserve(10000);
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism.back().vmp.reserve(100);
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//建议每个case都封装成一个函数
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second || 7 <= pxy.first && 3 >= pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				tempcparr[itemp - i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 7) {
				case 0:
				case 1:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 2:
				case 3:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 4:
				case 5:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, &cp, &strmap);
					break;
				case 6:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[46], 10);
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;
	//开始界面
	for (i = 0; i < 15; i++) {
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 9; i++) {
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		tempstr[7] = 0;
		Sleep(100);
	}
	system("color 07");
	Sleep(500);
	cout << endl << endl << endl;
	cout << " \033[33m@---------------------------------------------@" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m             |" << endl;
	cout << " |                                             |" << endl;
	cout << " @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {
		cin >> ch;
		if ('1' == ch) {
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m，并且不同的\033[31;1m难度\033[0m也有不同的\033[32;1m战前回血概率\033[0m与\033[31;1m小BOSS\033[32m战前回血概率\033[0m，\033[4m越\033[31;1m难\033[0;4m这个概率就越\033[31;1m小\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');
	int temparra[4] = { 8, 5, 3, 1 };
	p.sgetxyhs(HEAL) = temparra[d];
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				{
					int arr[12] = { 8, 5, 6, 3, 6, 7, 4, 5, 8, 9, 4, 1 };
					for (i = 0; i < 12; i += 2) {
						strmap[arr[i]][arr[i + 1]] = '*';
					}
				}
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		if (vism.size()) {
			for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
				for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
					*drawcp = '#';
				}
			}
		}
		p.printmap(strmap, ba, iunmd);
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (bc ? (bc = 0, 2) : rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front().vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		'*' != *cp && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp或者vism为空，那么开门，并头删
		if ((vism.empty() || vism.front().vmp.empty()) && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			b = 0;
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				'*' != *it->cp && (*it->cp = ' ');
			}
			p.sgetxyhs()->clear();
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				!i && (strmap[9][0] = ' ');
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			bool temparrb[8] = { 1, 1, !(rand() % 2), 1, !(rand() % 4), !(rand() % 2), 0, 0};
			if (1 != vism.size()) {//恢复血量
				temparrb[d * 2] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
		    }
		    else {
				temparrb[d * 2 + 1] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
			}
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	char tempstrb[6] = "C2AA7";//胜利
	str[7] = tempstrb[(!bb) * (d + 1)];
	system(str);
	switch ((!bb) * (d + 1)) {//告知你胜利的方式
	case 0:
		cout << "很遗憾，你输了" << endl;
		break;
	case 1:
	case 2:
		cout << "恭喜你，你赢了" << endl;
		break;
	case 3:
		cout << "@------------------@" << endl;
		cout << "|                  |" << endl;
		cout << "|  恭喜你，你赢了  |" << endl;
		cout << "|                  |" << endl;
		cout << "@------------------@" << endl;
		break;
	case 4:
		for (i = 0; i < 15; i++) {
			system("cls");
			win(i);
			Sleep(10);
		}
		for (i = 0; i < 27; i++) {
			strcat(tempstr, tempstra[i % 9]);
			system(tempstr);
			tempstr[7] = 0;
			Sleep(100);
		}
		system("color 0A");
		break;
	default:
		break;
	}
	for_each(mpv.begin(), mpv.end(), del);
	for_each(vo.begin(), vo.end(), delvo);
	return 0;
}
*///“添加一点注释在胜利后执行的代码段”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {//难度
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());//左边条件防出bug
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');//左边条件也防出bug
}
void start(int ichoose) {//开始时打印大字函数
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {//胜利后打印函数
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *      *  * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {//地牢图
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	bool bc = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;//小BOSS战时需要
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };//<-画“#”时所需要的数组
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };//<-画“#”时所需要的数组
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {//第5地牢的怪物移动路线
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	vism.reserve(1000);//防bug出
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};//生成时要的怪物坐标
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";//为告知你胜利的文字颜色
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C" };//大文字动态彩色变化数组(system("color 0" + tempstra[x(0<=x<=9)])
	mpv.reserve(10000);//也防bug出
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism.back().vmp.reserve(100);//还防bug出
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//编号id对应的地牢怪物生成
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second || 7 <= pxy.first && 3 >= pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				tempcparr[itemp - i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 7) {
				case 0:
				case 1:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 2:
				case 3:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 4:
				case 5:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, &cp, &strmap);
					break;
				case 6:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);//小BOSS的创建
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[46], 10);
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;//初始值(EASY)
	//开始界面
	for (i = 0; i < 15; i++) {//大文字缓缓出现
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 9; i++) {//使大文字变成动态的彩色
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		tempstr[7] = 0;
		Sleep(100);
	}
	system("color 07");
	Sleep(500);
	cout << endl << endl << endl;//游戏的开始界面
	cout << " \033[33m@---------------------------------------------@" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m             |" << endl;
	cout << " |                                             |" << endl;
	cout << " @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {//输入错误或者输入“1”(游戏规则时)重新输入
		cin >> ch;
		if ('1' == ch) {//1.游戏规则(打印游戏规则)
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m，并且不同的\033[31;1m难度\033[0m也有不同的\033[32;1m战前回血概率\033[0m与\033[31;1m小BOSS\033[32m战前回血概率\033[0m，\033[4m越\033[31;1m难\033[0;4m这个概率就越\033[31;1m小\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {//输入错误
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {//退出
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');//难度选择('2'~'5') - '2' = (0~3)
	int temparra[4] = { 8, 5, 3, 1 };
	p.sgetxyhs(HEAL) = temparra[d];//根据玩家选的难度来设置玩家的生命
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {//地牢的生成
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				{
					int arr[12] = { 8, 5, 6, 3, 6, 7, 4, 5, 8, 9, 4, 1 };
					for (i = 0; i < 12; i += 2) {
						strmap[arr[i]][arr[i + 1]] = '*';
					}
				}
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		if (vism.size()) {//开始前画“#”以用来告知人们地牢的变化
			for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
				for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
					*drawcp = '#';
				}
			}
		}
		p.printmap(strmap, ba, iunmd);//显示游戏的游玩界面
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (bc ? (bc = 0, 2) : rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front().vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		'*' != *cp && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp或者vism为空，那么开门，并头删
		if ((vism.empty() || vism.front().vmp.empty()) && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			b = 0;
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				'*' != *it->cp && (*it->cp = ' ');
			}
			p.sgetxyhs()->clear();
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				!i && (strmap[9][0] = ' ');
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			bool temparrb[8] = { 1, 1, !(rand() % 2), 1, !(rand() % 4), !(rand() % 2), 0, 0};
			if (1 != vism.size()) {//恢复血量
				temparrb[d * 2] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
		    }
		    else {
				temparrb[d * 2 + 1] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
			}
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	char tempstrb[6] = "C2AA7";//胜利
	str[7] = tempstrb[(!bb) * (d + 1)];
	system(str);
	switch ((!bb) * (d + 1)) {//告知你胜利的方式
	case 0:
		cout << "很遗憾，你输了" << endl;
		break;
	case 1:
	case 2:
		cout << "恭喜你，你赢了" << endl;
		break;
	case 3:
		cout << "@------------------@" << endl;
		cout << "|                  |" << endl;
		cout << "|  恭喜你，你赢了  |" << endl;
		cout << "|                  |" << endl;
		cout << "@------------------@" << endl;
		break;
	case 4:
		for (i = 0; i < 15; i++) {
			system("cls");
			win(i);
			Sleep(10);
		}
		for (i = 0; i < 27; i++) {
			strcat(tempstr, tempstra[i % 9]);
			system(tempstr);
			tempstr[7] = 0;
			Sleep(100);
		}
		system("color 0A");
		break;
	default:
		break;
	}
	for_each(mpv.begin(), mpv.end(), del);//释放mpv和vo里new出来的怪物对象
	for_each(vo.begin(), vo.end(), delvo);//释放mpv和vo里new出来的怪物对象
	return 0;
}
*///“添加更多的注释”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {//难度
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());//左边条件防出bug
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');//左边条件也防出bug
}
void start(int ichoose) {//开始时打印大字函数
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {//胜利后打印函数
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *      *  * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {//地牢图
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	bool bc = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;//小BOSS战时需要
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };//<-画“#”时所需要的数组
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };//<-画“#”时所需要的数组
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {//第5地牢的怪物移动路线
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	vism.reserve(1000);//防bug出
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};//生成时要的怪物坐标
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";//为告知你胜利的文字颜色
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C" };//大文字动态彩色变化数组(system("color 0" + tempstra[x(0<=x<=9)])
	mpv.reserve(10000);//也防bug出
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism.back().vmp.reserve(100);//还防bug出
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//编号id对应的地牢怪物生成
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second || 7 <= pxy.first && 3 >= pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				tempcparr[itemp - i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 7) {
				case 0:
				case 1:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 2:
				case 3:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 4:
				case 5:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, &cp, &strmap);
					break;
				case 6:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (0 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);//小BOSS的创建
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[46], 10);
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;//初始值(EASY)
	//开始界面
	for (i = 0; i < 15; i++) {//大文字缓缓出现
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 9; i++) {//使大文字变成动态的彩色
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		tempstr[7] = 0;
		Sleep(100);
	}
	system("color 07");
	Sleep(500);
	cout << endl << endl << endl;//游戏的开始界面
	cout << " \033[33m@---------------------------------------------@" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m             |" << endl;
	cout << " |                                             |" << endl;
	cout << " @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {//输入错误或者输入“1”(游戏规则时)重新输入
		cin >> ch;
		if ('1' == ch) {//1.游戏规则(打印游戏规则)
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m，并且不同的\033[31;1m难度\033[0m也有不同的\033[32;1m战前回血概率\033[0m与\033[31;1m小BOSS\033[32m战前回血概率\033[0m，\033[4m越\033[31;1m难\033[0;4m这个概率就越\033[31;1m小\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {//输入错误
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {//退出
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');//难度选择('2'~'5') - '2' = (0~3)
	int temparra[4] = { 8, 5, 3, 1 };
	p.sgetxyhs(HEAL) = temparra[d];//根据玩家选的难度来设置玩家的生命
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {//地牢的生成
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				{
					int arr[12] = { 8, 5, 6, 3, 6, 7, 4, 5, 8, 9, 4, 1 };
					for (i = 0; i < 12; i += 2) {
						strmap[arr[i]][arr[i + 1]] = '*';
					}
				}
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		if (vism.size()) {//开始前画“#”以用来告知人们地牢的变化
			for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
				for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
					*drawcp = '#';
				}
			}
		}
		p.printmap(strmap, ba, iunmd);//显示游戏的游玩界面
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (bc ? 2 : rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front().vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (bc ? (bc = 0, 2) : ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		'*' != *cp && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp或者vism为空，那么开门，并头删
		if ((vism.empty() || vism.front().vmp.empty()) && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			b = 0;
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				'*' != *it->cp && (*it->cp = ' ');
			}
			p.sgetxyhs()->clear();
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				!i && (strmap[9][0] = ' ');
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			bool temparrb[8] = { 1, 1, !(rand() % 2), 1, !(rand() % 4), !(rand() % 2), 0, 0};
			if (1 != vism.size()) {//恢复血量
				temparrb[d * 2] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
		    }
		    else {
				temparrb[d * 2 + 1] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
			}
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	char tempstrb[6] = "C2AA7";//胜利
	str[7] = tempstrb[(!bb) * (d + 1)];
	system(str);
	switch ((!bb) * (d + 1)) {//告知你胜利的方式
	case 0:
		cout << "很遗憾，你输了" << endl;
		break;
	case 1:
	case 2:
		cout << "恭喜你，你赢了" << endl;
		break;
	case 3:
		cout << "@------------------@" << endl;
		cout << "|                  |" << endl;
		cout << "|  恭喜你，你赢了  |" << endl;
		cout << "|                  |" << endl;
		cout << "@------------------@" << endl;
		break;
	case 4:
		for (i = 0; i < 15; i++) {
			system("cls");
			win(i);
			Sleep(10);
		}
		for (i = 0; i < 27; i++) {
			strcat(tempstr, tempstra[i % 9]);
			system(tempstr);
			tempstr[7] = 0;
			Sleep(100);
		}
		system("color 0A");
		break;
	default:
		break;
	}
	for_each(mpv.begin(), mpv.end(), del);//释放mpv和vo里new出来的怪物对象
	for_each(vo.begin(), vo.end(), delvo);//释放mpv和vo里new出来的怪物对象
	return 0;
}
*///“小BOSS战中怪物‘M_o’错误移动并导致报错的bug已修复”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {//难度
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());//左边条件防出bug
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');//左边条件也防出bug
}
void start(int ichoose) {//开始时打印大字函数
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {//胜利后打印函数
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *      *  * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {//地牢图
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	bool bc = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;//小BOSS战时需要
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };//<-画“#”时所需要的数组
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };//<-画“#”时所需要的数组
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {//第5地牢的怪物移动路线
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	vism.reserve(1000);//防bug出
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};//生成时要的怪物坐标
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";//为告知你胜利的文字颜色
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C" };//大文字动态彩色变化数组(system("color 0" + tempstra[x(0<=x<=9)])
	mpv.reserve(10000);//也防bug出
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism.back().vmp.reserve(100);//还防bug出
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//编号id对应的地牢怪物生成
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second || 7 <= pxy.first && 3 >= pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				tempcparr[itemp - i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 7) {
				case 0:
				case 1:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 2:
				case 3:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 4:
				case 5:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, &cp, &strmap);
					break;
				case 6:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);//小BOSS的创建
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[46], 10);
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;//初始值(EASY)
	//开始界面
	for (i = 0; i < 15; i++) {//大文字缓缓出现
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 9; i++) {//使大文字变成动态的彩色
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		tempstr[7] = 0;
		Sleep(100);
	}
	system("color 07");
	Sleep(500);
	cout << endl << endl << endl;//游戏的开始界面
	cout << " \033[33m@---------------------------------------------@" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m             |" << endl;
	cout << " |                                             |" << endl;
	cout << " @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {//输入错误或者输入“1”(游戏规则时)重新输入
		cin >> ch;
		if ('1' == ch) {//1.游戏规则(打印游戏规则)
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m，并且不同的\033[31;1m难度\033[0m也有不同的\033[32;1m战前回血概率\033[0m与\033[31;1m小BOSS\033[32m战前回血概率\033[0m，\033[4m越\033[31;1m难\033[0;4m这个概率就越\033[31;1m小\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {//输入错误
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {//退出
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');//难度选择('2'~'5') - '2' = (0~3)
	int temparra[4] = { 8, 5, 3, 1 };
	p.sgetxyhs(HEAL) = temparra[d];//根据玩家选的难度来设置玩家的生命
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {//地牢的生成
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				{
					int arr[12] = { 8, 5, 6, 3, 6, 7, 4, 5, 8, 9, 4, 1 };
					for (i = 0; i < 12; i += 2) {
						strmap[arr[i]][arr[i + 1]] = '*';
					}
				}
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		if (vism.size()) {//开始前画“#”以用来告知人们地牢的变化
			for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
				for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
					*drawcp = '#';
				}
			}
		}
		p.printmap(strmap, ba, iunmd);//显示游戏的游玩界面
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (bc ? 2 : rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front().vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (bc ? (bc = 0, 2) : ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front/* <- 会改(back) */().vmp.begin();
			while (/*完善后有判断*/!vism.front/* <- 会改(back) */().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front/* <- 会改(back) */().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		'*' != *cp && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp或者vism为空，那么开门，并头删
		if ((vism.empty() || vism.front().vmp.empty()) && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			b = 0;
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				'*' != *it->cp && (*it->cp = ' ');
			}
			p.sgetxyhs()->clear();
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				!i && (strmap[9][0] = ' ');
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			bool temparrb[8] = { 1, 1, !(rand() % 2), 1, !(rand() % 4), !(rand() % 2), 0, 0};
			if (1 != vism.size()) {//恢复血量
				temparrb[d * 2] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
		    }
		    else {
				temparrb[d * 2 + 1] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
			}
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	char tempstrb[6] = "C2AA7";//胜利
	str[7] = tempstrb[(!bb) * (d + 1)];
	system(str);
	switch ((!bb) * (d + 1)) {//告知你胜利的方式
	case 0:
		cout << "很遗憾，你输了" << endl;
		break;
	case 1:
	case 2:
		cout << "恭喜你，你赢了" << endl;
		break;
	case 3:
		cout << "@------------------@" << endl;
		cout << "|                  |" << endl;
		cout << "|  恭喜你，你赢了  |" << endl;
		cout << "|                  |" << endl;
		cout << "@------------------@" << endl;
		break;
	case 4:
		for (i = 0; i < 15; i++) {
			system("cls");
			win(i);
			Sleep(10);
		}
		for (i = 0; i < 27; i++) {
			strcat(tempstr, tempstra[i % 9]);
			system(tempstr);
			tempstr[7] = 0;
			Sleep(100);
		}
		system("color 0A");
		break;
	default:
		break;
	}
	for_each(mpv.begin(), mpv.end(), del);//释放mpv和vo里new出来的怪物对象
	for_each(vo.begin(), vo.end(), delvo);//释放mpv和vo里new出来的怪物对象
	return 0;
}
//M&.cpp
#include <iostream>
using namespace std;
#include "m&.h"
Mand::Mand() {
	this->set();
}
//vector<trir>* = NULL, char** = NULL, char** = NULL, pair<int, int>* = NULL, int = 0, int = 0, int = 3, bool = 0, bool = 0
void Mand::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*, char**, char(*)[11][11], int, int, bool b, bool) {
	m_v = v;
	m_cpp = cpp;
	m_iheal = iheal;
	mblr = b;
}
void Mand::mosterdo() {
	'*' != **m_cpp && (**m_cpp = ' ');
	if (!mblr && '*' == (*m_cpp)[-1]) {
		mblr = 1;
	}
	else if (mblr && '*' == (*m_cpp)[1]) {
		mblr = 0;
	}//撞墙换方向
	tempcp = *m_cpp;
	m_cpp = NULL;
	'*' != tempcp[-(1 - 2 * mblr)] && (tempcp -= (1 - 2 * mblr));//左右移
	'*' != tempcp[11] && (tempcp += 11);//下落
	m_cpp = &tempcp;
	//后面main函数中用Mshow函数使见
}//撞墙换方向，会自然下落
char Mand::getm() {
	return '&';
}
//moster.h
#pragma once
#include <iostream>
using namespace std;
#include "Player.h"
#include "WASD.h"
#include <map>
class moster {
protected:
	char** m_cpp;//怪物的位置
	int m_iheal;//怪物的血量数
	vector<trir>* m_v;//指向玩家射出的子弹
	char* tempcp;//用于在移动怪物的位置的时候防出bug
public:
	moster();//moster抽象基类的构造函数
	virtual void set(vector<trir>* v = NULL, char** cpp = NULL, int iheal = 3, map<char**, WASD>* = NULL, char** = NULL, char(*)[11][11] = NULL, int = 0, int = 0, bool = 0, bool = 0);//设置怪物的一些属性
	void hunt();//受伤函数
	int getheal();//获取怪物的血量数
	virtual void mosterdo() = 0;//执行每种怪物要做的事
	virtual char getm() = 0;//获取怪物的类型，用多态实现
	char*& getcp();//获取怪物的位置
};
*///“添加更多的注释”^
/*
//mosters.h
#pragma once
#include <iostream>
using namespace std;
#include "moster.h"//怪物们的头文件
#include "m_o.h"
#include "m&.h"
#include "m^.h"
#include "mO.h"
#include "m+.h"
#include "mX.h"
*///“添加一点注释”^
/*
//draw.h
#pragma once
#include <iostream>
using namespace std;
struct draw {
	int iy;//画“#”的画笔起始y坐标
	int ix;//画“#”的画笔起始x坐标
	int iwalk;//画笔往哪个方向走几步
	bool brd;//画壁画的方向(0> 1v)
};
*///“添加一点注释”^
/*
//MX.h
#pragma once
#include <iostream>
using namespace std;
#include "moster.h"
class MX : public moster {
private:
	char** m_pcpp;//玩家的地点，不用xy坐标
	char(*m_strmap)[11][11];//地牢的指针
	char m_strmapr[11][11];//刚刚创建完成之后的地牢
	char m_cc;//盖住的块
	pair<int, int>pxy;//怪物的xy坐标
	bool setb;//帮助设置怪物的一些属性
public:
	MX();//构造函数
	void set(vector<trir>* v = NULL, char** cpp = NULL, int iheal = 3, map<char**, WASD>* = NULL, char** pcpp = NULL, char(*strmap)[11][11] = NULL, int = 0, int = 0, bool = 0, bool = 0);//设置怪物MX的一些属性
	void mosterdo();//执行怪物MX要做的事
	void exset(char strmapr[11][11]);//额外设置怪物MX的一些属性
	char getm();//获取怪物MX的类型
	char getm(bool);//获取怪物MX的盖住的块
};
//MO.h
#pragma once
#include <iostream>
using namespace std;
#include <map>
#include "Player.h"
#include "moster.h"
class MO : public moster {
private:
	WASD m_wasd;//方向
	map<char**, WASD>m_m;//[strmap point, wasd]...
	pair<int, int> m_pxy;//怪物 xy坐标
	static pair<int, int> s_m_pxy;//玩家 xy坐标
	int imove;//追踪的时候充当定时器用，每到这个数模MOWAIT这个宏加1的结果为宏MOWAIT，就开始移动
public:
	void set(vector<trir>* v = NULL, char** cpp = NULL, int iheal = 3, map<char**, WASD>* m = NULL, char** = NULL, char(*)[11][11] = NULL, int ix = 0, int iy = 0, bool = 0, bool = 0);//设置怪物MO的一些属性
	MO();//构造函数
	void set_s_pxy(int ix, int iy);//监听玩家的xy坐标
	void mosterdo();//执行怪物MO要做的事
	char getm();//获取怪物MO的类型
};
//M&.h
#pragma once
#include <iostream>
using namespace std;
#include "moster.h"
class Mand: public moster {
private:
	bool mblr;//朝向(0< 1>)
public:
	void set(vector<trir>* v = NULL, char** cpp = NULL, int iheal = 3, map<char**, WASD>* = NULL, char** = NULL, char(*)[11][11] = NULL, int = 0, int = 0, bool b = 0, bool = 0);//设置怪物M&的一些属性
	Mand();//构造函数
	void mosterdo();//执行怪物M&要做的事
	char getm();//获取怪物M&的类型
};
//M^.h
#pragma once
#include <iostream>
using namespace std;
#include "moster.h"
class MUD : public moster {
private:
	bool mblr;//水平朝向(0< 1>)
	bool mbud;//垂直朝向(0^ 1v)
public:
	MUD();//构造函数
	void set(vector<trir>* v = NULL, char** cpp = NULL, int iheal = 3, map<char**, WASD>* = NULL, char** = NULL, char(*)[11][11] = NULL, int = 0, int = 0, bool b = 0, bool ba = 0);//设置怪物M^的一些属性
	void mosterdo();//执行怪物M^要做的事
	char getm();//获取怪物M^的类型
};
//M+.h
#pragma once
#include <iostream>
using namespace std;
#include "moster.h"
#include <vector>
class Mplus : public moster {
public:
	void mosterdo();//执行小BOSSM+要做的事
	char getm();//获取小BOSSM+的类型
};
//M_o.h
#pragma once
#include <iostream>
#include "moster.h"
using namespace std;
class M_o : public moster {
private:
	void near();//检测是否旁边有墙
public:
	void mosterdo();//执行怪物M_o要做的事
	char getm();//获取怪物M_o的类型
};
//WASD.h
#pragma once
#include <iostream>
using namespace std;
#ifndef onceb
#define onceb
enum WASD {
	W,
	A,
	S,
	D,
	E
};
WASD& operator++(WASD& w);//枚举WASD类型数据的前置++，无后置++
#endif
//isvp.h
#pragma once
#include <iostream>
using namespace std;
#include <vector>
#include <string>
#include "moster.h"
struct isv {//地牢怪物
	string str;//判断怪物的生成
	vector<moster*> vmp;//生成的怪物
	int id;//地牢怪物所代表的id
};
//Cmp.h
#pragma once
#include <iostream>
#include <vector>
#include "Player.h"
using namespace std;
class cmp {
public:
	bool operator()(trir t, trir ta);//用于升序排列的假函数
};
//cmpm.h
#pragma once
#ifndef oncec
#define oncec
#include <iostream>
using namespace std;
#include "moster.h"
class cmpm {
public:
	bool operator()(moster* mp, moster* mpa);//用于升序排列的假函数
};
#endif
*///“在所有头文件都添加一点注释”^
/*
//Player.cpp
#include <iostream>
#include "Player.h"
#include "cmp.h"
#include <algorithm>
#include <Windows.h>
using namespace std;
//构造函数
Player::Player(){
	ijh = 0;
	blr = 1;
}
//打印地牢函数
void Player::printmap(const char strmap[11][11], const bool bwait, const int iunmd) {
	int i = 0;
	int ia = 0;
	cout << "\033[" << (!bwait || 5 < iheal ? "32;1m" : 2 < iheal ? "33m" : "31;1m") << "P * " << iheal << "\033[0m" << endl << endl << endl;//打印玩家的血量
	for (cout << "-----------@" << endl; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : 'v' == strmap[i][ia] ? "36m" : '&' == strmap[i][ia] || '^' == strmap[i][ia] || 'o' == strmap[i][ia] || 'O' == strmap[i][ia] || 'X' == strmap[i][ia] ? "31;1m" : '+' == strmap[i][ia] || '#' == strmap[i][ia] ? "33m" : '@' == strmap[i][ia] ? "33m" : 'P' == strmap[i][ia] && iunmd ? "30;1m" : "0m") << strmap[i][ia] << "\033[0m";///打印地图
		}
		cout << "|" << endl;//竖的外边框
	}
	cout << "-----------@" << endl;//底下的的外边框
}
//打印地牢函数(右偏版本)
void Player::printmap(char(*strmap)[11][11], const bool bwait, const int ir, const int iunmd) {
	int i = 0;
	int ia = 0;
	cout << "\033[" << (!bwait || 5 < iheal ? "32;1m" : 2 < iheal ? "33m" : "31;1m") << "P * " << iheal << "\033[0m" << endl << endl << endl;//打印血量
	for (cout << "-----------@" << endl; i < 11; i++) {
		for (ia = ir; 11 > ia - ir; ia++) {
			21 > ia && ia >= 12 && i && 10 != i && ((*strmap)[i][ia % 11] = ' ');//清空左边的墙(除边框)
			cout << "\033[" << ('P' == (*strmap)[i][ia % 11] && iunmd ? "40;1m" : "0m") << (*strmap)[i][ia % 11] << "\033[0m";//打印右偏之后的地图
		}
		cout << "|" << endl;//竖的外边框
	}
	cout << "-----------@" << endl;//底下的的外边框
}//跳跃函数
void Player::jump(char** cpp) {
	10 == ix || '*' == (*cpp)[11] && (ijh = JUMPHIGH);
}
//左移函数
void Player::left_move(char** cpp) {
	(iy && '*' != *(*cpp - 1) && ((*cpp)--));
	blr = false;
}
//右移函数
void Player::right_move(char** cpp) {
	10 != iy && '*' != *(*cpp + 1) && ((*cpp)++);
	blr = true;
}
//用于设置或获得玩家的x坐标，y坐标或血量
int& Player::sgetxyhs(XYHS xyhsmode) {
	switch (xyhsmode) {
	case X:
		return ix;
		break;
	case Y:
		return iy;
		break;
	case HEAL:
		return iheal;
		break;
	default:
		break;
	}
}
//设置或获得玩家射出的子弹
vector<trir>* Player::sgetxyhs() {
	return &v;
}
//使玩家上升或下坠
void Player::upOrDown(char** cpp) {
	if (ijh > 0 && ix && '*' != (*cpp)[-11]) {//跳跃后
		ijh--, *cpp -= 11;
	}
	else if ('*' != (*cpp)[11] && (!ix || '*' == (*cpp)[-11])) {//撞墙或跳好后
		ijh = 0, *cpp += 11;
	}
	else if ('*' != (*cpp)[11] && 10 != ix) {//落下时
		*cpp += 11;
	}
	if (ijh > 0 && '*' == (*cpp)[11]) {//防磕头后还能跳
		ijh = 0;
	}
}
//射击函数
void Player::shoot(int& i, char** cpp) {
	if ((!i) && (iy && (!blr) || 10 != iy && blr)) {//检测冷却时间已过并且是否在地牢的边界射过
		v.push_back({ *cpp, iy, blr, 0 });
		i = 3;
	}
}
//子弹的移动函数
void Player::shootmove(const char(*strmap)[11][11], bool bmode) {
	if (bmode) {
		for (vector<trir>::iterator it = v.begin(); v.end() != it; it++) {
			(' ' == *it->cp || '@' == *it->cp) && (*it->cp = ' ');///编译显示之前子弹的移动
			if ('*' == *it->cp || it->bk || (!it->iy && (!it->b)) || (21 == it->iy && it->b)) {
				it->iy = -1;//子弹的销毁
			}
			if (0 <= it->iy) {
				it->cp -= (1 - it->b * 2);//子弹的移动
				it->iy -= (1 - it->b * 2);//子弹y坐标的移动
				(' ' == *it->cp || '@' == *it->cp) && (*it->cp = '@');//显示
			}
		}
	}
	else {
		sort(v.begin(), v.end(), cmp());//按子弹的y坐标进行升序排列
		while ((!v.empty()) && 0 > v.begin()->iy) {
			v.erase(v.begin());//销毁子弹
		}
	}
}
//M&.cpp
#include <iostream>
using namespace std;
#include "m&.h"
Mand::Mand() {
	this->set();
}
//vector<trir>* = NULL, char** = NULL, char** = NULL, pair<int, int>* = NULL, int = 0, int = 0, int = 3, bool = 0, bool = 0
void Mand::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*, char**, char(*)[11][11], int, int, bool b, bool) {
	m_v = v;
	m_cpp = cpp;
	m_iheal = iheal;
	mblr = b;
}
void Mand::mosterdo() {
	'*' != **m_cpp && (**m_cpp = ' ');//便于移动之后的显示
	if (!mblr && '*' == (*m_cpp)[-1]) {//如果怪物M&往左移动，并且左边有墙
		mblr = 1;//怪物M&就往右移动
	}
	else if (mblr && '*' == (*m_cpp)[1]) {//如果怪物M^往右移动，并且左边有墙
		mblr = 0;//怪物M&就往左动
	}//撞墙换方向
	tempcp = *m_cpp;//防指针的链式带动
	m_cpp = NULL;
	'*' != tempcp[-(1 - 2 * mblr)] && (tempcp -= (1 - 2 * mblr));//左右移
	'*' != tempcp[11] && (tempcp += 11);//下落
	m_cpp = &tempcp;
	//后面main函数中用Mshow函数使见
}//撞墙换方向，会自然下落
char Mand::getm() {
	return '&';
}
//M^.cpp
#include <iostream>
using namespace std;
#include "m^.h"
//构造函数
MUD::MUD() {
	set();
}
//M^的设置函数
void MUD::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*, char**, char(*)[11][11], int, int, bool b, bool ba) {
	m_v = v;//vector<trir>* = NULL, char** = NULL, char** = NULL, pair<int, int>* = NULL, int = 0, int = 0, int = 3, bool = 0, bool = 0
	m_cpp = cpp;
	m_iheal = iheal;
	mblr = b;
	mbud = ba;
}
void MUD::mosterdo() {
	'*' != **m_cpp && (**m_cpp = ' ');//便于移动之后的显示
	if (!mblr && '*' == (*m_cpp)[-1]) {//如果怪物M^往左移动，并且左边有墙
		mblr = 1;//怪物M^就往右移动
	}
	else if(mblr && '*' == (*m_cpp)[1]){//如果怪物M^往右移动，并且右边有墙
		mblr = 0;//怪物M^就往左移动
	}//撞墙换方向
	tempcp = *m_cpp;//防指针的链式带动
	m_cpp = NULL;
	'*' != tempcp[-(1 - 2 * mblr)] && (tempcp -= (1 - 2 * mblr));//左右移
	if (mbud && '*' == tempcp[11]) {//如果怪物M^往下移动，并且下边有墙
		mbud = 0;//怪物M^就往上落
	}
	else if (!mbud && '*' == tempcp[-11]) {//如果怪物M^往上落，并且上边有墙
		mbud = 1;//怪物M^就往下落
	}//碰地会反转
	'*' != tempcp[-(11 * (1 - 2 * mbud))] && (tempcp -= 11 * (1 - 2 * mbud));//上下落
	m_cpp = &tempcp;
	//后面main函数中Mshow函数使见
}//撞墙换方向，碰地会反落
char MUD::getm() {
	if (mbud) {
		return 'v';
	}
	else {
		return '^';
	}
}
//MO.cpp
#include <iostream>
using namespace std;
#include "MO.h"
#define NNEG(A, B) ((A) < (B) ? 1 : (A) > (B) ? -1 : 0)//判断宏
#define MOWAIT 1//怪物等待的回合数
pair<int, int> MO::s_m_pxy = {0, 0};//玩家坐标的初始化
//构造函数
MO::MO() {
	set();
}
//MO的设置函数
void MO::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*m, char**, char(*)[11][11], int ix, int iy, bool, bool) {
	m_v = v;//vector<trir>* = NULL, char** = NULL, pair<int, int>* = NULL, int = 0, int = 0, int = 3, bool = 0, bool = 0
	m_cpp = cpp;
	m_iheal = iheal;
	m_pxy.first = ix;
	m_pxy.second = iy;
	imove = 0;
	if (m) { 
		m_m = *m;
	}
}
void MO::mosterdo() {
	'*' != **m_cpp && (**m_cpp = ' ');//便于移动之后的显示
	tempcp = *m_cpp;//防指针的链式带动
	m_cpp = NULL;
	if (!m_m.empty()) {//沿路模式
		int arr[4] = { -11, -1, 11, 1 };//怪物MO可能会移动的四个方位
		for (map<char**, WASD>::iterator it = m_m.begin(); m_m.end() != it; it++) {//改变怪物MO的方向
			E != it->second && tempcp == *it->first && (m_wasd = it->second);
		}
		switch (tempcp += (arr[m_wasd]), m_wasd) {//怪物的移动与xy坐标的变化
		case W:
			m_pxy.second--;
			break;
		case A:
			m_pxy.first--;
			break;
		case S:
			m_pxy.second++;
			break;
		case D:
			m_pxy.first++;
			break;
		default:
			break;
		}
	}
	else {//追踪模式
		MOWAIT == imove % (MOWAIT + 1)/*如果MO等待了MOWAIT回合*/ && ('*' != *(tempcp + 11 * NNEG(m_pxy.first, s_m_pxy.first))/*并且垂直移动的方向上没有墙*/ && (tempcp += 11 * NNEG(m_pxy.first, s_m_pxy.first)/*那么怪物MO就往玩家垂直地移动*/, m_pxy.first += NNEG(m_pxy.first, s_m_pxy.first)/*怪物的x坐标也随之变化*/));//根据怪物的xy坐标和玩家的xy坐标来移动
		MOWAIT == imove++ % (MOWAIT + 1) && ('*' != *(tempcp + NNEG(m_pxy.second, s_m_pxy.second)/*并且水平移动的方向上没有墙*/) && (tempcp += NNEG(m_pxy.second, s_m_pxy.second)/*那么怪物MO就往玩家水平地移动*/, m_pxy.second += NNEG(m_pxy.second, s_m_pxy.second)/*怪物的y坐标也随之变化*/));
	}
	m_cpp = &tempcp;
}//遇向则转，看路前行（1），或追玩者（2）
//设置玩家的坐标
void MO::set_s_pxy(int ix, int iy) {
	s_m_pxy = { ix, iy };
}
char MO::getm() {
	return 'O';
}
//M_o.cpp
#include <iostream>
#include <ctime>
#include "M_o.h"
using namespace std;
void M_o::near() {
	int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };//根据向量来检测是否旁边有墙
	int i = 0;
	for (; i < 8; i++) {
		if ('*' == (*m_cpp)[arr[i]]) {
			m_iheal = -1;//去死，并生其他怪物
			break;
		}
	}
}
void M_o::mosterdo() {
	int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };//可能的移动方向
	int ir = 0;//随机数
	'*' != **m_cpp && (**m_cpp = ' ');//便于移动之后的显示
	tempcp = (near(), *m_cpp);//临时一级指针，无可用二级指针
	m_cpp = NULL;//防指针的链式移动
	'*' != tempcp[arr[ir = rand() % 8]] && (tempcp -= arr[ir]);//曾有bug点：一级指针会“带动”二级指针
	m_cpp = &tempcp;//移动
}//随便移动，有墙不动
char M_o::getm() {
	return 'o';
}
//M+.cpp
#include <iostream>
using namespace std;
#include "m+.h"
#include "M_o.h"
#include "Player.h"
void Mplus::mosterdo() {
	**m_cpp = '+';//后面根据**m_cpp的内容来执行summon方法
}
char Mplus::getm() {
	return '+';
}
//MX.cpp
#include <iostream>
using namespace std;
#include <cstring>
#include "mX.h"
//怪物MX的设置函数
void MX::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*, char** pcpp, char(*strmap)[11][11], int, int, bool, bool) {
	m_v = v;//vector<trir>* = NULL, char** = NULL, char** = NULL, pair<int, int>* = NULL, char(*)[11][11] = NULL,int = 0, int = 0, int = 3, bool = 0, bool = 0
	m_cpp = cpp;
	m_pcpp = pcpp;
	strmap && (m_strmap = strmap);
	m_iheal = iheal;
	setb = 1;
}
//怪物MX的额外设置函数
void MX::exset(char strmapr[11][11]) {
	memcpy(m_strmapr, strmapr, sizeof m_strmapr);
}
//构造函数
MX::MX() {
	set();
}
void MX::mosterdo() {
	vector<trir>::iterator it = m_v->begin();
	if (setb) {
		pxy = { (*m_cpp - &(*m_strmap)[0][0]) / 11, (*m_cpp - &(*m_strmap)[0][0]) % 11 };//设置怪物MX的坐标
		m_cc = m_strmapr[pxy.first][setb = 0, pxy.second];//设置盖住的块
	}
	for (; m_v->end() != it; it++) {
		if (*m_cpp == it->cp || *m_cpp == it->cp - (1 - it->b * 2)) {//如果怪物受伤了就停止这个循环
			break;
		}
	}
	if (m_iheal && (*m_cpp == *m_pcpp || m_v->end() != it)) {//如果刚才的这个循环停止了，并且还有生命且不在玩家的位置上
		tempcp = *m_cpp;//防指针的链式移动
		char* tempcpb = tempcp;
		bool tempb = 1;//防误覆盖空位
		m_cpp = NULL;
		do {
			tempb && m_v->end() != it && (*tempcp = ' ');//便于移动之后的显示
			tempcp = &(*m_strmap)[pxy.first = rand() % 9 + 1][pxy.second = rand() % 9 + 1];//怪物MX的移动

		} while ((tempcp == &(*m_strmap)[9][1] || '@' == (*m_strmap)[pxy.first][pxy.second] || '@' == (*m_strmap)[pxy.first][pxy.second - 1] || '@' == (*m_strmap)[pxy.first][pxy.second + 1] || tempcp == *m_pcpp || '*' == tempcp[-1] || '*' == tempcp[1] || 'X' == (tempcp)[-1] || 'X' == (tempcp)[1]) && (tempb = 0, 1));//如果满足上述的条件，就把误覆盖空位的“开关”启动
		m_cpp = &tempcp;
		*tempcpb = m_cc;
		('@' != m_strmapr[pxy.first][pxy.second] || 'X' != m_strmapr[pxy.first][pxy.second] && 'P' != m_strmapr[pxy.first][pxy.second]) && (m_cc = m_strmapr[pxy.first][pxy.second]);//记录盖住的块，不记录“@”子弹，“P”玩家和“X”怪物MX自己
	}
	//main函数使见
}//被玩家碰到传，受伤传(两旁有砖不传)，并见
char MX::getm() {
	return 'X';
}
char MX::getm(bool) {
	return m_cc;
}
//cmpm.cpp
#include <iostream>
#include "cmpM.h"
#include "moster.h"
using namespace std;
bool cmpm::operator()(moster* mp, moster* mpa) {
	return mp->getheal() < mpa->getheal();//比较两个怪物的生命值
}
//Cmp.cpp
#include <iostream>
#include "Cmp.h"
#include "Player.h"
using namespace std;
bool cmp::operator()(trir t, trir ta) {
	return t.iy < ta.iy;//比较两个子弹的y坐标
}
//WASD.cpp
#include <iostream>
using namespace std;
#include "WASD.h"
WASD& operator++(WASD& w) {
	WASD warr[5] = { W,A,S,D,E };//把WASD枚举类型的每一种东西都转化成数字
	w < E && (w = warr[w + 1]);//warr[w + 1](WASD) == w + 1(int)
	return w;
}
*///“游戏已正式做完，注释已全部添加”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {//难度
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());//左边条件防出bug
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');//左边条件也防出bug
}
void start(int ichoose) {//开始时打印大字函数
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {//胜利后打印函数
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *      *  * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {//地牢图
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	bool bc = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;//小BOSS战时需要
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };//<-画“#”时所需要的数组
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };//<-画“#”时所需要的数组
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {//第5地牢的怪物移动路线
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	vism.reserve(1000);//防bug出
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};//生成时要的怪物坐标
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";//为告知你胜利的文字颜色
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C" };//大文字动态彩色变化数组(system("color 0" + tempstra[x(0<=x<=9)])
	mpv.reserve(10000);//也防bug出
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism.back().vmp.reserve(100);//还防bug出
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//编号id对应的地牢怪物生成
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second || 7 <= pxy.first && 3 >= pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				tempcparr[itemp - i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 7) {
				case 0:
				case 1:
					mpv.push_back(new Mand());
					vism[ch].str += '&';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 2:
				case 3:
					mpv.push_back(new MUD());
					if (pbb.second) {
						vism[ch].str += 'v';
					}
					else {
						vism[ch].str += '^';
					}
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 4:
				case 5:
					mpv.push_back(new MX());
					vism[ch].str += 'X';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, &cp, &strmap);
					break;
				case 6:
					mpv.push_back(new MO());
					vism[ch].str += 'O';
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);//小BOSS的创建
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[46], 10);
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;//初始值(EASY)
	//开始界面
	for (i = 0; i < 15; i++) {//大文字缓缓出现
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 9; i++) {//使大文字变成动态的彩色
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		tempstr[7] = 0;
		Sleep(100);
	}
	system("color 07");
	Sleep(500);
	cout << endl << endl << endl;//游戏的开始界面
	cout << " \033[33m@---------------------------------------------@" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m             |" << endl;
	cout << " |                                             |" << endl;
	cout << " @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {//输入错误或者输入“1”(游戏规则时)重新输入
		cin >> ch;
		if ('1' == ch) {//1.游戏规则(打印游戏规则)
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m，并且不同的\033[31;1m难度\033[0m也有不同的\033[32;1m战前回血概率\033[0m与\033[31;1m小BOSS\033[32m战前回血概率\033[0m，\033[4m越\033[31;1m难\033[0;4m这个概率就越\033[31;1m小\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {//输入错误
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {//退出
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');//难度选择('2'~'5') - '2' = (0~3)
	int temparra[4] = { 8, 5, 3, 1 };
	p.sgetxyhs(HEAL) = temparra[d];//根据玩家选的难度来设置玩家的生命
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {//地牢的生成
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				{
					int arr[12] = { 8, 5, 6, 3, 6, 7, 4, 5, 8, 9, 4, 1 };
					for (i = 0; i < 12; i += 2) {
						strmap[arr[i]][arr[i + 1]] = '*';
					}
				}
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		if (vism.size()) {//开始前画“#”以用来告知人们地牢的变化
			for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
				for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
					*drawcp = '#';
				}
			}
		}
		p.printmap(strmap, ba, iunmd);//显示游戏的游玩界面
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (bc ? 2 : rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front().vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (bc ? (bc = 0, 2) : ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front().vmp.begin();
			while (!vism.front().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		'*' != *cp && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp或者vism为空，那么开门，并头删
		if ((vism.empty() || vism.front().vmp.empty()) && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			b = 0;
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				'*' != *it->cp && (*it->cp = ' ');
			}
			p.sgetxyhs()->clear();
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				!i && (strmap[9][0] = ' ');
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			bool temparrb[8] = { 1, 1, !(rand() % 2), 1, !(rand() % 4), !(rand() % 2), 0, 0};
			if (1 != vism.size()) {//恢复血量
				temparrb[d * 2] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
		    }
		    else {
				temparrb[d * 2 + 1] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
			}
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	char tempstrb[6] = "C2AA7";//胜利
	str[7] = tempstrb[(!bb) * (d + 1)];
	system(str);
	switch ((!bb) * (d + 1)) {//告知你胜利的方式
	case 0:
		cout << "很遗憾，你输了" << endl;
		break;
	case 1:
	case 2:
		cout << "恭喜你，你赢了" << endl;
		break;
	case 3:
		cout << "@------------------@" << endl;
		cout << "|                  |" << endl;
		cout << "|  恭喜你，你赢了  |" << endl;
		cout << "|                  |" << endl;
		cout << "@------------------@" << endl;
		break;
	case 4:
		for (i = 0; i < 15; i++) {
			system("cls");
			win(i);
			Sleep(10);
		}
		for (i = 0; i < 27; i++) {
			strcat(tempstr, tempstra[i % 9]);
			system(tempstr);
			tempstr[7] = 0;
			Sleep(100);
		}
		system("color 0A");
		break;
	default:
		break;
	}
	for_each(mpv.begin(), mpv.end(), del);//释放mpv和vo里new出来的怪物对象
	for_each(vo.begin(), vo.end(), delvo);//释放mpv和vo里new出来的怪物对象
	return 0;
}
*///“删除一些无用的注释”^
/*
bool b_(bool b) {//取反
	if ((b = !b) && (b_(b))) {
		return -114514;
	}
	return b;
}
int main() {
	cout << b_(0) << " " << b_(true) << endl;
}
*///“装B取反”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {//难度
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());//左边条件防出bug
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');//左边条件也防出bug
}
void start(int ichoose) {//开始时打印大字函数
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {//胜利后打印函数
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *      *  * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {//地牢图
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	bool bc = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;//小BOSS战时需要
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };//<-画“#”时所需要的数组
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };//<-画“#”时所需要的数组
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {//第5地牢的怪物移动路线
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	vism.reserve(1000);//防bug出
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};//生成时要的怪物坐标
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";//为告知你胜利的文字颜色
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C" };//大文字动态彩色变化数组(system("color 0" + tempstra[x(0<=x<=9)])
	mpv.reserve(10000);//也防bug出
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism.back().vmp.reserve(100);//还防bug出
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//编号id对应的地牢怪物生成
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second || 7 <= pxy.first && 3 >= pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				tempcparr[itemp - i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 7) {
				case 0:
				case 1:
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 2:
				case 3:
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 4:
				case 5:
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, &cp, &strmap);
					break;
				case 6:
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);//小BOSS的创建
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[46], 10);
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;//初始值(EASY)
	//开始界面
	for (i = 0; i < 15; i++) {//大文字缓缓出现
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 9; i++) {//使大文字变成动态的彩色
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		tempstr[7] = 0;
		Sleep(100);
	}
	system("color 07");
	Sleep(500);
	cout << endl << endl << endl;//游戏的开始界面
	cout << " \033[33m@---------------------------------------------@" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m             |" << endl;
	cout << " |                                             |" << endl;
	cout << " @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {//输入错误或者输入“1”(游戏规则时)重新输入
		cin >> ch;
		if ('1' == ch) {//1.游戏规则(打印游戏规则)
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m，并且不同的\033[31;1m难度\033[0m也有不同的\033[32;1m战前回血概率\033[0m与\033[31;1m小BOSS\033[32m战前回血概率\033[0m，\033[4m越\033[31;1m难\033[0;4m这个概率就越\033[31;1m小\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {//输入错误
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {//退出
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');//难度选择('2'~'5') - '2' = (0~3)
	int temparra[4] = { 8, 5, 3, 1 };
	p.sgetxyhs(HEAL) = temparra[d];//根据玩家选的难度来设置玩家的生命
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {//地牢的生成
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				{
					int arr[12] = { 8, 5, 6, 3, 6, 7, 4, 5, 8, 9, 4, 1 };
					for (i = 0; i < 12; i += 2) {
						strmap[arr[i]][arr[i + 1]] = '*';
					}
				}
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		if (vism.size()) {//开始前画“#”以用来告知人们地牢的变化
			for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
				for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
					*drawcp = '#';
				}
			}
		}
		p.printmap(strmap, ba, iunmd);//显示游戏的游玩界面
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (bc ? 2 : rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front().vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (bc ? (bc = 0, 2) : ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front().vmp.begin();
			while (!vism.front().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		'*' != *cp && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp或者vism为空，那么开门，并头删
		if ((vism.empty() || vism.front().vmp.empty()) && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			b = 0;
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				'*' != *it->cp && (*it->cp = ' ');
			}
			p.sgetxyhs()->clear();
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				!i && (strmap[9][0] = ' ');
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			bool temparrb[8] = { 1, 1, !(rand() % 2), 1, !(rand() % 4), !(rand() % 2), 0, 0};
			if (1 != vism.size()) {//恢复血量
				temparrb[d * 2] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
		    }
		    else {
				temparrb[d * 2 + 1] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
			}
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	char tempstrb[6] = "C2AA7";//胜利
	str[7] = tempstrb[(!bb) * (d + 1)];
	system(str);
	switch ((!bb) * (d + 1)) {//告知你胜利的方式
	case 0:
		cout << "很遗憾，你输了" << endl;
		break;
	case 1:
	case 2:
		cout << "恭喜你，你赢了" << endl;
		break;
	case 3:
		cout << "@------------------@" << endl;
		cout << "|                  |" << endl;
		cout << "|  恭喜你，你赢了  |" << endl;
		cout << "|                  |" << endl;
		cout << "@------------------@" << endl;
		break;
	case 4:
		for (i = 0; i < 15; i++) {
			system("cls");
			win(i);
			Sleep(10);
		}
		for (i = 0; i < 27; i++) {
			strcat(tempstr, tempstra[i % 9]);
			system(tempstr);
			tempstr[7] = 0;
			Sleep(100);
		}
		system("color 0A");
		break;
	default:
		break;
	}
	for_each(mpv.begin(), mpv.end(), del);//释放mpv和vo里new出来的怪物对象
	for_each(vo.begin(), vo.end(), delvo);//释放mpv和vo里new出来的怪物对象
	return 0;
}
*///“删掉无用代码”^
/*
//以前来自MO.cpp，现在无
#include <iostream>
//其他头文件
using namespace std;
//对象的成员函数
void M_o::mosterdo() {//发生bug的成员函数
	int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
	int ir = 0;
	'*' != **m_cpp && (**m_cpp = ' ');
	'*' != (*m_cpp)[arr[ir = rand() % 8]] && (*m_cpp -= arr[ir]);//看起来没问题，但此乃bug点(重点)：一级指针会“带动”二级指针
}//随便移动，有墙不动
//对象的成员函数
*///“指针的链式带动”^
/*
int main() {
	cout << INT_MAX << endl;
	return 0;
}
*///“climits头文件的使用”^
/*
int main() {
	cout << INT_MIN << endl;
	return 0;
}
*///“INT_MIN”^
/*
int main() {
	cout << CHAR_MAX << endl;
	return 0;
}
*///“CHAR_MAX”^
/*
int main() {
	cout << CHAR_MIN << endl;
	return 0;
}
*///“CHAR_MIN”^
/*
int main() {
	deque<int> d;
	d.push_back(4);
	cout << d.front() << endl;
	d.pop_front();
	d.push_back(4);
	d.push_front(3);
	d.push_back(-2);
	for (deque<int>::iterator it = d.begin(); d.end() != it; it++) {
		cout << *it << " ";
	}
	cout << endl;
	return 0;
}
*///“deque双端数组”^
/*
int main() {
	stack<int>s;
	int i = 0;
	for (; i < 5; i++) {//放入
		s.push(i);
		cout << i << " ";
	}
	for (cout << endl; i; i--) {//移出
		cout << s.top() << " ";
		s.pop();
	}
	cout << endl;
	return 0;
}
*///“stack栈容器的反转元素顺序功能”^
/*
/*
int main() {
	set<int>s;
	int i = -10;
	for (; i < 10; i++) {
		s.insert(i);
	}
	for (set<int>::const_iterator cit = s.cbegin(); s.cend() != cit; cit++) {
		!*cit && cout << endl;
		cout << *cit << " ";
	}
	cout << endl;
	return 0;
}
*///“set容器的正负分组”^
/*
int main() {
	set<int, greater<int>>s;
	int i = -10;
	for (; i < 10; i++) {
		s.insert(i);
	}
	for (set<int>::const_iterator cit = s.cbegin(); s.cend() != cit; cit++) {
		cout << *cit << " ";
	}
	cout << endl;
	return 0;
}
*///“set容器的排序方式已变为从大到小排”^
/*
int main() {
	vector<int>v = { 1, 1, 4, 5, 1, 4 };
	sort(v.begin(), v.end());
	for_each(v.begin(), v.end(), [=](int i) {
		cout << i;
	});
	return 0;
}
*///“sort排序函数和for_each遍历函数”^
/*
int main() {
	[=]() {
		cout << "Hello, Lambda!" << endl;
	}();
	return 0;
}
*///“后面有用于函数的调用的括号的匿名函数体”^
/*
//M+.cpp
#include <iostream>
using namespace std;
#include "m+.h"
void Mplus::mosterdo() {
	**m_cpp = '+';//后面根据**m_cpp的内容来执行summon方法
}
char Mplus::getm() {
	return '+';
}
*///“减少导入的头文件”^
/*
//M&.cpp
#include <iostream>
using namespace std;
#include "m&.h"
Mand::Mand() {
	this->set();
}
void Mand::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*, char**, char(*)[11][11], int, int, bool b, bool) {
	m_v = v;
	m_cpp = cpp;
	m_iheal = iheal;
	mblr = b;
}
void Mand::mosterdo() {
	'*' != **m_cpp && (**m_cpp = ' ');//便于移动之后的显示
	if (!mblr && '*' == (*m_cpp)[-1]) {//如果怪物M&往左移动，并且左边有墙
		mblr = 1;//怪物M&就往右移动
	}
	else if (mblr && '*' == (*m_cpp)[1]) {//如果怪物M^往右移动，并且左边有墙
		mblr = 0;//怪物M&就往左动
	}//撞墙换方向
	tempcp = *m_cpp;//防指针的链式带动
	m_cpp = NULL;
	'*' != tempcp[-(1 - 2 * mblr)] && (tempcp -= (1 - 2 * mblr));//左右移
	'*' != tempcp[11] && (tempcp += 11);//下落
	m_cpp = &tempcp;
	//后面main函数中用Mshow函数使见
}//撞墙换方向，会自然下落
char Mand::getm() {
	return '&';
}
//M^.cpp
#include <iostream>
using namespace std;
#include "m^.h"
//构造函数
MUD::MUD() {
	set();
}
//M^的设置函数
void MUD::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*, char**, char(*)[11][11], int, int, bool b, bool ba) {
	m_v = v;
	m_cpp = cpp;
	m_iheal = iheal;
	mblr = b;
	mbud = ba;
}
void MUD::mosterdo() {
	'*' != **m_cpp && (**m_cpp = ' ');//便于移动之后的显示
	if (!mblr && '*' == (*m_cpp)[-1]) {//如果怪物M^往左移动，并且左边有墙
		mblr = 1;//怪物M^就往右移动
	}
	else if(mblr && '*' == (*m_cpp)[1]){//如果怪物M^往右移动，并且右边有墙
		mblr = 0;//怪物M^就往左移动
	}//撞墙换方向
	tempcp = *m_cpp;//防指针的链式带动
	m_cpp = NULL;
	'*' != tempcp[-(1 - 2 * mblr)] && (tempcp -= (1 - 2 * mblr));//左右移
	if (mbud && '*' == tempcp[11]) {//如果怪物M^往下移动，并且下边有墙
		mbud = 0;//怪物M^就往上落
	}
	else if (!mbud && '*' == tempcp[-11]) {//如果怪物M^往上落，并且上边有墙
		mbud = 1;//怪物M^就往下落
	}//碰地会反转
	'*' != tempcp[-(11 * (1 - 2 * mbud))] && (tempcp -= 11 * (1 - 2 * mbud));//上下落
	m_cpp = &tempcp;
	//后面main函数中Mshow函数使见
}//撞墙换方向，碰地会反落
char MUD::getm() {
	if (mbud) {
		return 'v';
	}
	else {
		return '^';
	}
}
//MO.cpp
#include <iostream>
using namespace std;
#include "MO.h"
#define NNEG(A, B) ((A) < (B) ? 1 : (A) > (B) ? -1 : 0)//判断宏
#define MOWAIT 1//怪物等待的回合数
pair<int, int> MO::s_m_pxy = {0, 0};//玩家坐标的初始化
//构造函数
MO::MO() {
	set();
}
//MO的设置函数
void MO::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*m, char**, char(*)[11][11], int ix, int iy, bool, bool) {
	m_v = v;
	m_cpp = cpp;
	m_iheal = iheal;
	m_pxy.first = ix;
	m_pxy.second = iy;
	imove = 0;
	if (m) { 
		m_m = *m;
	}
}
void MO::mosterdo() {
	'*' != **m_cpp && (**m_cpp = ' ');//便于移动之后的显示
	tempcp = *m_cpp;//防指针的链式带动
	m_cpp = NULL;
	if (!m_m.empty()) {//沿路模式
		int arr[4] = { -11, -1, 11, 1 };//怪物MO可能会移动的四个方位
		for (map<char**, WASD>::iterator it = m_m.begin(); m_m.end() != it; it++) {//改变怪物MO的方向
			E != it->second && tempcp == *it->first && (m_wasd = it->second);
		}
		switch (tempcp += (arr[m_wasd]), m_wasd) {//怪物的移动与xy坐标的变化
		case W:
			m_pxy.second--;
			break;
		case A:
			m_pxy.first--;
			break;
		case S:
			m_pxy.second++;
			break;
		case D:
			m_pxy.first++;
			break;
		default:
			break;
		}
	}
	else {//追踪模式
		MOWAIT == imove % (MOWAIT + 1)/*如果MO等待了MOWAIT回合*/ && ('*' != *(tempcp + 11 * NNEG(m_pxy.first, s_m_pxy.first))/*并且垂直移动的方向上没有墙*/ && (tempcp += 11 * NNEG(m_pxy.first, s_m_pxy.first)/*那么怪物MO就往玩家垂直地移动*/, m_pxy.first += NNEG(m_pxy.first, s_m_pxy.first)/*怪物的x坐标也随之变化*/));//根据怪物的xy坐标和玩家的xy坐标来移动
		MOWAIT == imove++ % (MOWAIT + 1) && ('*' != *(tempcp + NNEG(m_pxy.second, s_m_pxy.second)/*并且水平移动的方向上没有墙*/) && (tempcp += NNEG(m_pxy.second, s_m_pxy.second)/*那么怪物MO就往玩家水平地移动*/, m_pxy.second += NNEG(m_pxy.second, s_m_pxy.second)/*怪物的y坐标也随之变化*/));
	}
	m_cpp = &tempcp;
}//遇向则转，看路前行（1），或追玩者（2）
//设置玩家的坐标
void MO::set_s_pxy(int ix, int iy) {
	s_m_pxy = { ix, iy };
}
char MO::getm() {
	return 'O';
}
//MX.cpp
#include <iostream>
using namespace std;
#include <cstring>
#include "mX.h"
//怪物MX的设置函数
void MX::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*, char** pcpp, char(*strmap)[11][11], int, int, bool, bool) {
	m_v = v;
	m_cpp = cpp;
	m_pcpp = pcpp;
	strmap && (m_strmap = strmap);
	m_iheal = iheal;
	setb = 1;
}
//怪物MX的额外设置函数
void MX::exset(char strmapr[11][11]) {
	memcpy(m_strmapr, strmapr, sizeof m_strmapr);
}
//构造函数
MX::MX() {
	set();
}
void MX::mosterdo() {
	vector<trir>::iterator it = m_v->begin();
	if (setb) {
		pxy = { (*m_cpp - &(*m_strmap)[0][0]) / 11, (*m_cpp - &(*m_strmap)[0][0]) % 11 };//设置怪物MX的坐标
		m_cc = m_strmapr[pxy.first][setb = 0, pxy.second];//设置盖住的块
	}
	for (; m_v->end() != it; it++) {
		if (*m_cpp == it->cp || *m_cpp == it->cp - (1 - it->b * 2)) {//如果怪物受伤了就停止这个循环
			break;
		}
	}
	if (m_iheal && (*m_cpp == *m_pcpp || m_v->end() != it)) {//如果刚才的这个循环停止了，并且还有生命且不在玩家的位置上
		tempcp = *m_cpp;//防指针的链式移动
		char* tempcpb = tempcp;
		bool tempb = 1;//防误覆盖空位
		m_cpp = NULL;
		do {
			tempb && m_v->end() != it && (*tempcp = ' ');//便于移动之后的显示
			tempcp = &(*m_strmap)[pxy.first = rand() % 9 + 1][pxy.second = rand() % 9 + 1];//怪物MX的移动

		} while ((tempcp == &(*m_strmap)[9][1] || '@' == (*m_strmap)[pxy.first][pxy.second] || '@' == (*m_strmap)[pxy.first][pxy.second - 1] || '@' == (*m_strmap)[pxy.first][pxy.second + 1] || tempcp == *m_pcpp || '*' == tempcp[-1] || '*' == tempcp[1] || 'X' == (tempcp)[-1] || 'X' == (tempcp)[1]) && (tempb = 0, 1));//如果满足上述的条件，就把误覆盖空位的“开关”启动
		m_cpp = &tempcp;
		*tempcpb = m_cc;
		('@' != m_strmapr[pxy.first][pxy.second] || 'X' != m_strmapr[pxy.first][pxy.second] && 'P' != m_strmapr[pxy.first][pxy.second]) && (m_cc = m_strmapr[pxy.first][pxy.second]);//记录盖住的块，不记录“@”子弹，“P”玩家和“X”怪物MX自己
	}
	//main函数使见
}//被玩家碰到传，受伤传(两旁有砖不传)，并见
char MX::getm() {
	return 'X';
}
char MX::getm(bool) {
	return m_cc;
}
*///“减少注释”^
/*
//mosters.h
#pragma once
#include <iostream>
using namespace std;
#include "moster.h"//怪物们的头文件
#include "M_o.h"
#include "M&.h"
#include "M^.h"
#include "MO.h"
#include "M+.h"
#include "MX.h"
*///“导入的头文件名字已改变”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {//难度
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());//左边条件防出bug
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');//左边条件也防出bug
}
void start(int ichoose) {//开始时打印大字函数
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {//胜利后打印函数
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *      *  * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {//地牢图
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	bool bc = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;//小BOSS战时需要
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };//<-画“#”时所需要的数组
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };//<-画“#”时所需要的数组
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {//第5地牢的怪物移动路线
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	vism.reserve(5000);//防bug出
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};//生成时要的怪物坐标
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";//为告知你胜利的文字颜色
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C" };//大文字动态彩色变化数组(system("color 0" + tempstra[x(0<=x<=9)])
	mpv.reserve(10000);//也防bug出
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism.back().vmp.reserve(500);//还防bug出
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//编号id对应的地牢怪物生成
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second || 7 <= pxy.first && 3 >= pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				tempcparr[itemp - i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 7) {
				case 0:
				case 1:
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 2:
				case 3:
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 4:
				case 5:
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, &cp, &strmap);
					break;
				case 6:
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);//小BOSS的创建
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[46], 10);
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;//初始值(EASY)
	//开始界面
	for (i = 0; i < 15; i++) {//大文字缓缓出现
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 9; i++) {//使大文字变成动态的彩色
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		tempstr[7] = 0;
		Sleep(100);
	}
	system("color 07");
	Sleep(500);
	cout << endl << endl << endl;//游戏的开始界面
	cout << " \033[33m@---------------------------------------------@" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m             |" << endl;
	cout << " |                                             |" << endl;
	cout << " @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {//输入错误或者输入“1”(游戏规则时)重新输入
		cin >> ch;
		if ('1' == ch) {//1.游戏规则(打印游戏规则)
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m，并且不同的\033[31;1m难度\033[0m也有不同的\033[32;1m战前回血概率\033[0m与\033[31;1m小BOSS\033[32m战前回血概率\033[0m，\033[4m越\033[31;1m难\033[0;4m这个概率就越\033[31;1m小\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {//输入错误
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {//退出
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');//难度选择('2'~'5') - '2' = (0~3)
	int temparra[4] = { 8, 5, 3, 1 };
	p.sgetxyhs(HEAL) = temparra[d];//根据玩家选的难度来设置玩家的生命
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {//地牢的生成
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				{
					int arr[12] = { 8, 5, 6, 3, 6, 7, 4, 5, 8, 9, 4, 1 };
					for (i = 0; i < 12; i += 2) {
						strmap[arr[i]][arr[i + 1]] = '*';
					}
				}
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		if (vism.size()) {//开始前画“#”以用来告知人们地牢的变化
			for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
				for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
					*drawcp = '#';
				}
			}
		}
		p.printmap(strmap, ba, iunmd);//显示游戏的游玩界面
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (bc ? 2 : rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front().vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (bc ? (bc = 0, 2) : ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front().vmp.begin();
			while (!vism.front().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		'*' != *cp && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp或者vism为空，那么开门，并头删
		if ((vism.empty() || vism.front().vmp.empty()) && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			b = 0;
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				'*' != *it->cp && (*it->cp = ' ');
			}
			p.sgetxyhs()->clear();
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				!i && (strmap[9][0] = ' ');
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			bool temparrb[8] = { 1, 1, !(rand() % 2), 1, !(rand() % 4), !(rand() % 2), 0, 0};
			if (1 != vism.size()) {//恢复血量
				temparrb[d * 2] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
		    }
		    else {
				temparrb[d * 2 + 1] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
			}
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	char tempstrb[6] = "C2AA7";//胜利
	str[7] = tempstrb[(!bb) * (d + 1)];
	system(str);
	switch ((!bb) * (d + 1)) {//告知你胜利的方式
	case 0:
		cout << "很遗憾，你输了" << endl;
		break;
	case 1:
	case 2:
		cout << "恭喜你，你赢了" << endl;
		break;
	case 3:
		cout << "@------------------@" << endl;
		cout << "|                  |" << endl;
		cout << "|  恭喜你，你赢了  |" << endl;
		cout << "|                  |" << endl;
		cout << "@------------------@" << endl;
		break;
	case 4:
		for (i = 0; i < 15; i++) {
			system("cls");
			win(i);
			Sleep(10);
		}
		for (i = 0; i < 27; i++) {
			strcat(tempstr, tempstra[i % 9]);
			system(tempstr);
			tempstr[7] = 0;
			Sleep(100);
		}
		system("color 0A");
		break;
	default:
		break;
	}
	for_each(mpv.begin(), mpv.end(), del);//释放mpv和vo里new出来的怪物对象
	for_each(vo.begin(), vo.end(), delvo);//释放mpv和vo里new出来的怪物对象
	return 0;
}
*///“vism与里面的vmp的预留大小已改变”^
/*
enum a {
	b,
	c
};

const int& fun(a aa) {
	if (b == aa) {
		return 45;
	}
}

int main() {
	a aa = b;
	cout << fun(c);
	return 0;
}
*///“会报错”^
/*
enum a {
	b,
	c
};

const int& fun(a aa) {
	if (b == aa) {
		return -0;
	}
}

int main() {
	a aa = b;
	cout << fun(c);
	return 0;
}
*///“更会报错”^
/*
int main() {
	list<int>l;
	l.push_back(1);
	l.push_front(3);
	for (list<int>::const_iterator it = l.cbegin(); l.cend() != it; it++) {
		cout << *it << " ";
	}
	cout << endl;
	return 0;
}
*///“list链表容器的初步使用”^
/*
int main() {
	list<int>l;
	cout << "初始化时list链表容器l的容量：" << l.size() << " " << endl << endl;
	l.push_back(1);
	cout << "往后面添加元素后list链表容器l的容量：" << l.size() << " " << endl << endl;
	l.push_front(1);
	cout << "往前面添加元素后list链表容器l的容量：" << l.size() << " " << endl;
	return 0;
}
*///“list链表容器的size方法调用”^
/*
int main() {
	list<int>l;
	l.push_front(1);
	l.push_back(2);
	l.push_front(3);
	cout << l.front() << " " << l.back() << " ";
	l.pop_front();
	cout << l.front() << " ";
	l.pop_back();
	cout << l.back() << " " << endl;
	return 0;
}
*///“list容器的pop_front删除前面元素方法和pop_back删除后面元素方法”^
/*
int main() {
	list<int>l;
	for (int i = 0; i < 10; i++) {
		l.push_back(0);
	}
	cout << l.size() << " <- 此时list链表容器的容量" << endl;
	l.clear();
	cout << l.size() << " <- 删除所有元素后list链表容器的容量" << endl;
	return 0;
}
*///“list容器clear方法的调用”^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
struct node {
	T t;
	node next;
};
template<class T>
class mylist {
private:
	int capacity;
public:
	T& operator[](int i){
	
	}
	T& at(int i){
	
	}
	int findindex(T t){
	
	}
	int capacity(){
	
	}
	void push_back(T t){
	
	}
	void insert(T t, int i){
	
	}	
	void clear(){
	
	}
	void del_back(){
	
	}
	bool IsEmpty(){
	
	}
};
*///“单向链表容器已创建”^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		node(T tc, node* nextc) {
			t = tc;
			next = nextc;
		}
		node() {
			t = NULL;
			next = NULL;
		}
	};
	node head;
public:
	friend class node;
	T& operator[](int i){
		
	}
	T& at(int i){

	}
	int findindex(T t){
	
	}
	int capacity(){
		return ic;
	}
	void push_back(T t){

	}
	void insert(T t, int i){
		
	}	
	void clear(){
		ic = 0;
	}
	void del_back(){
	
	}
	bool IsEmpty(){
		return !ic;
	}
	mylist(){}
	mylist(T* tarr) {
		if (sizeof *tarr) {
			ic = sizeof *tarr / sizeof (*tarr)[0];
			//...
		}
	}
	~mylist() {
		while (head.next) {
			del_back();
		}
	}
};
*///“部分成员函数已完成”^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	T& operator[](int i){
		
	}
	T& at(int i){

	}
	int indexfind(T t){
	
	}
	int capacity(){
		return ic;
	}
	void push_back(T t){
		node* findnode = head;
		node* newnode = new node;
		newnode->set(t, NULL);
		while (findnode->next) {
			findnode = findnode->next;
		}
		findnode->next = newnode;
	}
	void insert(T t, int i){
		if (ic > i && i >= 0) {
			node* findnode = head->next;
			node* newnode = new node;
			newnode->set(t, NULL);
			for (; i; i--) {
				findnode = findnode->next;
			}
			findnode->next = newnode;
		}
	}	
	void clear(){
		//...
		ic = 0;
	}
	void del_back(){
		
	}
	void del_index(int index) {

	}
	bool IsEmpty(){
		return !ic;
	}
	mylist(){}
	mylist(T* tarr) {
		if (sizeof *tarr) {
			ic = sizeof *tarr / sizeof (*tarr)[0];
			//...
		}
	}
	~mylist() {
		while (head.next) {
			del_back();
		}
	}
};
*///“链表元素插入函数已完成”^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	T& operator[](int i) const {
		return at(i);
	}
	T& at(int i) const {
		node* findnode = head->next;
		for (; i; i--) {
			findnode = findnode->next;
		}
		return findnode->t;
	}
	int indexfind(T t){
		
	}
	int capacity() const {
		return ic;
	}
	void push_back(T t){
		node* findnode = head;
		node* newnode = new node;
		newnode->set(t, NULL);
		while (findnode->next) {
			findnode = findnode->next;
		}
		findnode->next = newnode;
	}
	void insert(T t, int i){
		if (ic > i && i >= 0) {
			node* findnode = head->next;
			node* newnode = new node;
			newnode->set(t, NULL);
			for (; i; i--) {
				findnode = findnode->next;
			}
			findnode->next = newnode;
		}
	}	
	void clear(){
		while (ic) {
			del_back();
		}
	}
	void del_back(){
		if (ic) {
			node* prenode = head;
			while (prenode->next->next) {
				prenode = prenode->next;
			}
			node* delnode = prenode->next;
			prenode->next = NULL;
			delete delnode;
			ic--;
		}
	}
	void del_index(int index) {
		if (ic - 1 == index) {
			del_back();
		}
		else if (ic > index && index >= 0) {
			node* prenode = head;
			for (; index > 0; index--) {
				prenode = prenode->next;
			}
			node* delnode = prenode->next;
			node* nextnode = delnode->next;
			prenode->next = nextnode;
			delnode->next = NULL;
			delete delnode;
		}
		ic--;
	}
	bool IsEmpty() const {
		return !ic;
	}
	mylist(){}
	mylist(const T* const tarr) {
		if (sizeof *tarr) {
			ic = sizeof *tarr / sizeof (*tarr)[0];
			T* tp = tarr;
			for (int i = 0; i < ic; i++) {
				push_back(*tp++);
			}
		}
	}
	~mylist() {
		while (head->next) {
			del_back();
		}
	}
};
*///“就差indexfind成员函数没实现”^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	T& operator[](int i) const {
		return at(i);
	}
	T& at(int i) const {
		node* findnode = head->next;
		for (; i; i--) {
			findnode = findnode->next;
		}
		return findnode->t;
	}
	int indexfind(T t){
		node* findnode = head;
		int index = 0;
		while (head->next) {
			findnode = findnode->next;
			if (findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void push_back(T t){
		node* findnode = head;
		node* newnode = new node;
		newnode->set(t, NULL);
		while (findnode->next) {
			findnode = findnode->next;
		}
		findnode->next = newnode;
	}
	void insert(T t, int i){
		if (ic > i && i >= 0) {
			node* findnode = head->next;
			node* newnode = new node;
			newnode->set(t, NULL);
			for (; i; i--) {
				findnode = findnode->next;
			}
			findnode->next = newnode;
		}
	}	
	void clear(){
		while (ic) {
			del_back();
		}
	}
	void del_back(){
		if (ic) {
			node* prenode = head;
			while (prenode->next->next) {
				prenode = prenode->next;
			}
			node* delnode = prenode->next;
			prenode->next = NULL;
			delete delnode;
			ic--;
		}
	}
	void del_index(int index) {
		if (ic - 1 == index) {
			del_back();
		}
		else if (ic > index && index >= 0) {
			node* prenode = head;
			for (; index > 0; index--) {
				prenode = prenode->next;
			}
			node* delnode = prenode->next;
			node* nextnode = delnode->next;
			prenode->next = nextnode;
			delnode->next = NULL;
			delete delnode;
		}
		ic--;
	}
	bool IsEmpty() const {
		return !ic;
	}
	mylist(){}
	mylist(const T* const tarr) {
		if (sizeof *tarr) {
			ic = sizeof *tarr / sizeof (*tarr)[0];
			T* tp = tarr;
			for (int i = 0; i < ic; i++) {
				push_back(*tp++);
			}
		}
	}
	~mylist() {
		while (head->next) {
			del_back();
		}
	}
};
*///“mylist单向链表的所有基本的成员方法已完成”^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (head->next) {
			findnode = findnode->next;
			if (findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void push_back(T t) {
		node* findnode = head;
		node* newnode = new node;
		newnode->set(t, NULL);
		while (findnode->next) {
			findnode = findnode->next;
		}
		findnode->next = newnode;
	}
	void operator=(const mylist ml) {
		this->ic = ml.ic;
		int ia = 0;
		clear();
		node* findnode = head->next;
		for (int i = 0; i < this->ic; i++) {
			i && (findnode = findnode->next);
			push_back(findnode->t);
		}
	}
	mylist(const mylist ml) {
		*this = ml;
	}
	mylist(const T* const tarr) {
		if (sizeof * tarr) {
			ic = sizeof * tarr / sizeof(*tarr)[0];
			T* tp = tarr;
			for (int i = 0; i < ic; i++) {
				push_back(*tp++);
			}
		}
	}
	void insert(T t, int i) {
		if (ic > i && i >= 0) {
			node* findnode = head->next;
			node* newnode = new node;
			newnode->set(t, NULL);
			for (; i; i--) {
				findnode = findnode->next;
			}
			findnode->next = newnode;
		}
	}
	void del_back() {
		if (ic) {
			node* prenode = head;
			while (prenode->next->next) {
				prenode = prenode->next;
			}
			node* delnode = prenode->next;
			prenode->next = NULL;
			delete delnode;
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
	}
	void del_index(int index) {
		if (ic - 1 == index) {
			del_back();
		}
		else if (ic > index && index >= 0) {
			node* prenode = head;
			for (; index > 0; index--) {
				prenode = prenode->next;
			}
			node* delnode = prenode->next;
			node* nextnode = delnode->next;
			prenode->next = nextnode;
			delnode->next = NULL;
			delete delnode;
		}
		ic--;
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) const {
		node* findnode = head->next;
		for (; i; i--) {
			findnode = findnode->next;
		}
		return findnode->t;
	}
	T& operator[](int i) const {
		return at(i);
	}
};
*///“mylist单向链表的拷贝方法已变为深拷贝”^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {//难度
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());//左边条件防出bug
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');//左边条件也防出bug
}
void start(int ichoose) {//开始时打印大字函数
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {//胜利后打印函数
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *      *  * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {//地牢图
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	bool bc = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;//小BOSS战时需要
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };//<-画“#”时所需要的数组
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };//<-画“#”时所需要的数组
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {//第5地牢的怪物移动路线
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	vism.reserve(5000);//防bug出
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};//生成时要的怪物坐标
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";//为告知你胜利的文字颜色
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C" };//大文字动态彩色变化数组(system("color 0" + tempstra[x(0<=x<=9)])
	mpv.reserve(10000);//也防bug出
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism.back().vmp.reserve(500);//还防bug出
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//编号id对应的地牢怪物生成
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second || 7 <= pxy.first && 3 >= pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				tempcparr[itemp - i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 7) {
				case 0:
				case 1:
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 2:
				case 3:
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 4:
				case 5:
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, &cp, &strmap);
					break;
				case 6:
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);//小BOSS的创建
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[46], 10);
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;//初始值(EASY)
	//开始界面
	for (i = 0; i < 15; i++) {//大文字缓缓出现
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 9; i++) {//使大文字变成动态的彩色
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		tempstr[7] = 0;
		Sleep(100);
	}
	system("color 07");
	Sleep(500);
	cout << endl << endl << endl;//游戏的开始界面
	cout << " \033[33m@---------------------------------------------@" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m             |" << endl;
	cout << " |                                             |" << endl;
	cout << " @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {//输入错误或者输入“1”(游戏规则时)重新输入
		cin >> ch;
		if ('1' == ch) {//1.游戏规则(打印游戏规则)
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m，并且不同的\033[31;1m难度\033[0m也有不同的\033[32;1m战前回血概率\033[0m与\033[31;1m小BOSS\033[32m战前回血概率\033[0m，\033[4m越\033[31;1m难\033[0;4m这个概率就越\033[31;1m小\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {//输入错误
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {//退出
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');//难度选择('2'~'5') - '2' = (0~3)
	int temparra[4] = { 8, 5, 3, 1 };
	p.sgetxyhs(HEAL) = temparra[d];//根据玩家选的难度来设置玩家的生命
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {//地牢的生成
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				{
					int arr[12] = { 8, 5, 6, 3, 6, 7, 4, 5, 8, 9, 4, 1 };
					for (i = 0; i < 12; i += 2) {
						strmap[arr[i]][arr[i + 1]] = '*';
					}
				}
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		if (vism.size()) {//开始前画“#”以用来告知人们地牢的变化
			for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
				for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
					*drawcp = '#';
				}
			}
		}
		p.printmap(strmap, ba, iunmd);//显示游戏的游玩界面
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {//怪物死
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (bc ? 2 : rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front().vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
					while (!cpa || ' ' != *cpa) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					mx = (cpa - &strmap[0][0]) / 11;
					my = (cpa - &strmap[0][0]) % 11;
					switch (bc ? (bc = 0, 2) : ir) {
					case 0:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
						break;
					case 1:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
						break;
					case 2:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
						break;
					case 3:
						vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
						break;
					default:
						break;
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front().vmp.begin();
			while (!vism.front().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		'*' != *cp && (*cp = 'P');
		//没血使怪物死亡
		system("cls");//清屏
		//如果vism的第0项vmp或者vism为空，那么开门，并头删
		if ((vism.empty() || vism.front().vmp.empty()) && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地图('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			b = 0;
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				'*' != *it->cp && (*it->cp = ' ');
			}
			p.sgetxyhs()->clear();
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				!i && (strmap[9][0] = ' ');
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			bool temparrb[8] = { 1, 1, !(rand() % 2), 1, !(rand() % 4), !(rand() % 2), 0, 0};
			if (1 != vism.size()) {//恢复血量
				temparrb[d * 2] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
		    }
		    else {
				temparrb[d * 2 + 1] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
			}
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	char tempstrb[6] = "C2AA7";//胜利
	str[7] = tempstrb[(!bb) * (d + 1)];
	system(str);
	switch ((!bb) * (d + 1)) {//告知你胜利的方式
	case 0:
		cout << "很遗憾，你输了" << endl;
		break;
	case 1:
	case 2:
		cout << "恭喜你，你赢了" << endl;
		break;
	case 3:
		cout << "@------------------@" << endl;
		cout << "|                  |" << endl;
		cout << "|  恭喜你，你赢了  |" << endl;
		cout << "|                  |" << endl;
		cout << "@------------------@" << endl;
		break;
	case 4:
		for (i = 0; i < 15; i++) {
			system("cls");
			win(i);
			Sleep(10);
		}
		for (i = 0; i < 27; i++) {
			strcat(tempstr, tempstra[i % 9]);
			system(tempstr);
			tempstr[7] = 0;
			Sleep(100);
		}
		system("color 0A");
		break;
	default:
		break;
	}
	for_each(mpv.begin(), mpv.end(), del);//释放mpv和vo里new出来的怪物对象
	for_each(vo.begin(), vo.end(), delvo);//释放mpv和vo里new出来的怪物对象
	return 0;
}
*///“怪物死”注释已添加^
/*
//Player.cpp
#include <iostream>
#include "Player.h"
#include "cmp.h"
#include <algorithm>
#include <Windows.h>
using namespace std;
//构造函数
Player::Player(){
	ijh = 0;
	blr = 1;
}
//打印地牢方法
void Player::printmap(const char strmap[11][11], const bool bwait, const int iunmd) {
	int i = 0;
	int ia = 0;
	cout << "\033[" << (!bwait || 5 < iheal ? "32;1m" : 2 < iheal ? "33m" : "31;1m") << "P * " << iheal << "\033[0m" << endl << endl << endl;//打印玩家的血量
	for (cout << "-----------@" << endl; i < 11; i++) {
		for (ia = 0; ia < 11; ia++) {
			cout << "\033[" << ('G' == strmap[i][ia] ? "32;1m" : 'v' == strmap[i][ia] ? "36m" : '&' == strmap[i][ia] || '^' == strmap[i][ia] || 'o' == strmap[i][ia] || 'O' == strmap[i][ia] || 'X' == strmap[i][ia] ? "31;1m" : '+' == strmap[i][ia] || '#' == strmap[i][ia] || '@' == strmap[i][ia] ? "33m" : 'P' == strmap[i][ia] && iunmd ? "30;1m" : "0m") << strmap[i][ia] << "\033[0m";///打印地图
		}
		cout << "|" << endl;//竖的外边框
	}
	cout << "-----------@" << endl;//底下的外边框
}
//打印地牢方法(右偏版本)
void Player::printmap(char(*strmap)[11][11], const bool bwait, const int ir, const int iunmd) {
	int i = 0;
	int ia = 0;
	cout << "\033[" << (!bwait || 5 < iheal ? "32;1m" : 2 < iheal ? "33m" : "31;1m") << "P * " << iheal << "\033[0m" << endl << endl << endl;//打印血量
	for (cout << "-----------@" << endl; i < 11; i++) {
		for (ia = ir; 11 > ia - ir; ia++) {
			21 > ia && ia >= 12 && i && 10 != i && ((*strmap)[i][ia % 11] = ' ');//清空左边的墙(除边框)
			cout << "\033[" << ('P' == (*strmap)[i][ia % 11] && iunmd ? "40;1m" : "0m") << (*strmap)[i][ia % 11] << "\033[0m";//打印右偏之后的地图
		}
		cout << "|" << endl;//竖的外边框
	}
	cout << "-----------@" << endl;//底下的外边框
}//跳跃方法
void Player::jump(char** cpp) {
	10 == ix || '*' == (*cpp)[11] && (ijh = JUMPHIGH);
}
//左移方法
void Player::left_move(char** cpp) {
	(iy && '*' != *(*cpp - 1) && ((*cpp)--));
	blr = false;
}
//右移函数
void Player::right_move(char** cpp) {
	10 != iy && '*' != *(*cpp + 1) && ((*cpp)++);
	blr = true;
}
//用于设置或获得玩家的x坐标，y坐标或血量
int& Player::sgetxyhs(XYHS xyhsmode) {
	switch (xyhsmode) {
	case X:
		return ix;
		break;
	case Y:
		return iy;
		break;
	case HEAL:
		return iheal;
		break;
	default:
		break;
	}
}
//设置或获得玩家射出的子弹
vector<trir>* Player::sgetxyhs() {
	return &v;
}
//使玩家上升或下坠
void Player::upOrDown(char** cpp) {
	if (ijh > 0 && ix && '*' != (*cpp)[-11]) {//跳跃后
		ijh--, *cpp -= 11;
	}
	else if ('*' != (*cpp)[11] && (!ix || '*' == (*cpp)[-11])) {//撞墙或跳好后
		ijh = 0, *cpp += 11;
	}
	else if ('*' != (*cpp)[11] && 10 != ix) {//落下时
		*cpp += 11;
	}
	if (ijh > 0 && '*' == (*cpp)[11]) {//防磕头后还能跳
		ijh = 0;
	}
}
//射击方法
void Player::shoot(int& i, char** cpp) {
	if ((!i) && (iy && (!blr) || 10 != iy && blr)) {//检测冷却时间已过并且是否在地牢的边界射过
		v.push_back({ *cpp, iy, blr, 0 });
		i = 3;
	}
}
//子弹的移动方法
void Player::shootmove(const char(*strmap)[11][11], bool bmode) {
	if (bmode) {
		for (vector<trir>::iterator it = v.begin(); v.end() != it; it++) {
			(' ' == *it->cp || '@' == *it->cp) && (*it->cp = ' ');///编译显示之前子弹的移动
			if ('*' == *it->cp || it->bk || (!it->iy && (!it->b)) || (21 == it->iy && it->b)) {
				it->iy = -1;//子弹的销毁
			}
			if (0 <= it->iy) {
				it->cp -= (1 - it->b * 2);//子弹的移动
				it->iy -= (1 - it->b * 2);//子弹y坐标的移动
				(' ' == *it->cp || '@' == *it->cp) && (*it->cp = '@');//显示
			}
		}
	}
	else {
		sort(v.begin(), v.end(), cmp());//按子弹的y坐标进行升序排列
		while ((!v.empty()) && 0 > v.begin()->iy) {
			v.erase(v.begin());//销毁子弹
		}
	}
}
*///注释中多处“函数”已改为“方法”^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (head->next) {
			findnode = findnode->next;
			if (findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void push_back(T t) {
		node* findnode = head;
		node* newnode = new node;
		newnode->set(t, NULL);
		while (findnode->next) {
			findnode = findnode->next;
		}
		findnode->next = newnode;
	}
	void operator=(const mylist ml) {
		this->ic = ml.ic;
		int ia = 0;
		clear();
		node* findnode = head->next;
		for (int i = 0; i < this->ic; i++) {
			i && (findnode = findnode->next);
			push_back(findnode->t);
		}
	}
	mylist(const mylist ml) {
		*this = ml;
	}
	mylist(const T* const tarr) {
		if (sizeof * tarr) {
			ic = sizeof * tarr / sizeof(*tarr)[0];
			T* tp = tarr;
			for (int i = 0; i < ic; i++) {
				push_back(*tp++);
			}
		}
	}
	void insert(T t, int i) {
		if (ic > i && i >= 0) {
			node* findnode = head->next;
			node* newnode = new node;
			newnode->set(t, NULL);
			for (; i; i--) {
				findnode = findnode->next;
			}
			findnode->next = newnode;
		}
	}
	void del_back() {
		if (ic) {
			node* prenode = head;
			while (prenode->next->next) {
				prenode = prenode->next;
			}
			node* delnode = prenode->next;
			prenode->next = NULL;
			delete delnode;
			ic--;
		}
	}
	void clear() const {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
	}
	void del_index(int index) {
		if (ic - 1 == index) {
			del_back();
		}
		else if (ic > index && index >= 0) {
			node* prenode = head;
			for (; index > 0; index--) {
				prenode = prenode->next;
			}
			node* delnode = prenode->next;
			node* nextnode = delnode->next;
			prenode->next = nextnode;
			delnode->next = NULL;
			delete delnode;
		}
		ic--;
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		node* findnode = head->next;
		for (; i; i--) {
			findnode = findnode->next;
		}
		return findnode->t;
	}
	void myreverse() {
		if (ic >= 2) {
			node* lastnode = head->next;
			node* findnode = head;
			while (lastnode->next) {
				lastnode = lastnode->next;
			}
			while (head->next->next) {
				findnode = head;
				while (findnode->next->next) {
					findnode = findnode->next;
				}
				findnode->next->next = findnode;
				findnode->next = NULL;
			}
			head->next = lastnode;

		}// n 1 2 3
	}
	T& operator[](int i) const {
		return at(i);
	}
};
*///“reverse方法已完成”^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		//this->head->t = NULL;
		head->next = nullptr;
	}
	void push_back(T t) {
		node* newnode = new node;
		node** findnode = &head;
		newnode->set(t, nullptr);
		while (nullptr != (*findnode)->next) {
			findnode = &(*findnode)->next;
		}
		(*findnode)->next = newnode;
		ic++;
	}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (nullptr != head->next) {
			findnode = findnode->next;
			if (findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		this->ic = ml.ic;
		int ia = 0;
		clear();
		node* findnode = head->next;
		for (int i = 0; i < this->ic; i++) {
			i && (findnode = findnode->next);
			push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		this->head->next = nullptr;
		*this = ml;
	}
	mylist(const T* const tarr) {
		//this->head->t = nullptr;
		this->head->next = nullptr;
		if (sizeof * tarr) {
			ic = sizeof * tarr / sizeof(*tarr)[0];
			T* tp = tarr;
			for (int i = 0; i < ic; i++) {
				push_back(*tp++);
			}
		}
	}
	void insert(T t, int i) {
		if (ic > i && i >= 0) {
			node* findnode = head->next;
			node* newnode = new node;
			newnode->set(t, nullptr);
			for (; i; i--) {
				findnode = findnode->next;
			}
			findnode->next = newnode;
			ic++;
		}
	}
	void del_back() {
		if (ic) {
			node* prenode = head;
			while (nullptr != prenode->next->next) {
				prenode = prenode->next;
			}
			node* delnode = prenode->next;
			prenode->next = nullptr;
			delete delnode;
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
	}
	void del_index(int index) {
		if (ic) {
			if (ic - 1 == index) {
				del_back();
			}
			else if (ic > index && index >= 0) {
				node* prenode = head;
				for (; index > 0; index--) {
					prenode = prenode->next;
				}
				node* delnode = prenode->next;
				node* nextnode = delnode->next;
				prenode->next = nextnode;
				delnode->next = nullptr;
				delete delnode;
			}
			ic--;
		}
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		node* findnode = head->next;
		for (; i; i--) {
			findnode = findnode->next;
		}
		return findnode->t;
	}
	void myreverse() {
		if (ic >= 2) {
			node* lastnode = head->next;
			node* findnode = head;
			while (nullptr != lastnode->next) {
				lastnode = lastnode->next;
			}
			while (nullptr != head->next->next) {
				findnode = head;
				while (findnode->next->next) {
					findnode = findnode->next;
				}
				findnode->next->next = findnode;
				findnode->next = nullptr;
			}
			head->next = lastnode;

		}// n 1 2 3
	}
	T& operator[](int i) {
		return at(i);
	}
};
*///“mylist单向链表head节点指向位置不可访问bug未修复”^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
	}
	void push_back(T t) {
		node* newnode = new node;
		node** findnode = &head;
		newnode->set(t, nullptr);
		while (nullptr != (*findnode)->next) {
			findnode = &(*findnode)->next;
		}
		(*findnode)->next = newnode;
		ic++;
	}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (nullptr != head->next) {
			findnode = findnode->next;
			if (findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		this->ic = ml.ic;
		int ia = 0;
		clear();
		node* findnode = head->next;
		for (int i = 0; i < this->ic; i++) {
			i && (findnode = findnode->next);
			push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		this->head->next = nullptr;
		*this = ml;
	}
	mylist(const T* const tarr) {
		//this->head->t = nullptr;
		this->head->next = nullptr;
		if (sizeof * tarr) {
			ic = sizeof * tarr / sizeof(*tarr)[0];
			T* tp = tarr;
			for (int i = 0; i < ic; i++) {
				push_back(*tp++);
			}
		}
	}
	void insert(T t, int i) {
		if (ic > i && i >= 0) {
			node* findnode = head->next;
			node* newnode = new node;
			newnode->set(t, nullptr);
			for (; i; i--) {
				findnode = findnode->next;
			}
			findnode->next = newnode;
			ic++;
		}
	}
	void del_back() {
		if (ic) {
			node* prenode = head;
			while (nullptr != prenode->next->next) {
				prenode = prenode->next;
			}
			node* delnode = prenode->next;
			prenode->next = nullptr;
			delete delnode;
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		//delete head;
	}
	void del_index(int index) {
		if (ic) {
			if (ic - 1 == index) {
				del_back();
			}
			else if (ic > index && index >= 0) {
				node* prenode = head;
				for (; index > 0; index--) {
					prenode = prenode->next;
				}
				node* delnode = prenode->next;
				node* nextnode = delnode->next;
				prenode->next = nextnode;
				delnode->next = nullptr;
				delete delnode;
			}
			ic--;
		}
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		node* findnode = head->next;
		for (; i; i--) {
			findnode = findnode->next;
		}
		return findnode->t;
	}
	void myreverse() {
		if (ic >= 2) {
			node* lastnode = head->next;
			node* findnode = head;
			while (nullptr != lastnode->next) {
				lastnode = lastnode->next;
			}
			while (nullptr != head->next->next) {
				findnode = head;
				while (findnode->next->next) {
					findnode = findnode->next;
				}
				findnode->next->next = findnode;
				findnode->next = nullptr;
			}
			head->next = lastnode;

		}// n 1 2 3
	}
	T& operator[](int i) {
		return at(i);
	}
};
*///“mylist单向链表里的节点node类的set重载无参方法已添加”^
/*
//meiri.cpp
#include <iostream>
#include <list>
#include "mylist.hpp"
using namespace std;

int main() {
	list<int>l;
	mylist<int>ml;
	cout << "ml单向链表容器的容量：" << ml.capacity() << " ml单向链表容器的是否为空：" << (ml.IsEmpty() ? "为空" : "不为空") << endl << endl << "添加一个新元素后：" << endl << endl;
	ml.push_back(1);
	cout << "ml单向链表容器的容量：" << ml.capacity() << " ml单向链表容器的是否为空：" << (ml.IsEmpty() ? "为空" : "不为空") << endl;
	return 0;
}
*///“mylist单向链表里的capacity和IsEmpty常方法已测试完毕”^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
	}
	void push_back(T t) {
		node* newnode = new node;
		node** findnode = &head;
		newnode->set(t, nullptr);
		while (nullptr != (*findnode)->next) {
			findnode = &(*findnode)->next;
		}
		(*findnode)->next = newnode;
		ic++;
	}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (nullptr != head->next) {
			findnode = findnode->next;
			if (findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		this->ic = ml.ic;
		int ia = 0;
		clear();
		node* findnode = head->next;
		for (int i = 0; i < this->ic; i++) {
			i && (findnode = findnode->next);
			push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		this->head->next = nullptr;
		*this = ml;
	}
	mylist(const T* const tarr) {
		//this->head->t = nullptr;
		this->head->next = nullptr;
		if (sizeof * tarr) {
			ic = sizeof * tarr / sizeof(*tarr)[0];
			T* tp = tarr;
			for (int i = 0; i < ic; i++) {
				push_back(*tp++);
			}
		}
	}
	void insert(T t, int i) {
		if (ic > i && i >= 0) {
			node* findnode = head->next;
			node* newnode = new node;
			newnode->set(t, nullptr);
			for (; i; i--) {
				findnode = findnode->next;
			}
			findnode->next = newnode;
			ic++;
		}
	}
	void del_back() {
		if (ic) {
			node* prenode = head;
			while (nullptr != prenode->next->next) {
				prenode = prenode->next;
			}
			node* delnode = prenode->next;
			prenode->next = nullptr;
			delete delnode;
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	void del_index(int index) {
		if (ic) {
			if (ic - 1 == index) {
				del_back();
			}
			else if (ic > index && index >= 0) {
				node* prenode = head;
				for (; index > 0; index--) {
					prenode = prenode->next;
				}
				node* delnode = prenode->next;
				node* nextnode = delnode->next;
				prenode->next = nextnode;
				delnode->next = nullptr;
				delete delnode;
			}
			ic--;
		}
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		node* findnode = head->next;
		for (; i; i--) {
			findnode = findnode->next;
		}
		return findnode->t;
	}
	void myreverse() {
		if (ic >= 2) {
			node* lastnode = head->next;
			node* findnode = head;
			while (nullptr != lastnode->next) {
				lastnode = lastnode->next;
			}
			while (nullptr != head->next->next) {
				findnode = head;
				while (findnode->next->next) {
					findnode = findnode->next;
				}
				findnode->next->next = findnode;
				findnode->next = nullptr;
			}
			head->next = lastnode;

		}// n 1 2 3
	}
	T& operator[](int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
};
*///“重载中括号运算符的内部代码已更改”^
/*
//meiri.cpp
#include <iostream>
#include <list>
#include "mylist.hpp"
using namespace std;

int main() {
	mylist<int>ml;
	ml.push_back(54);
	ml.push_back(-54);
	ml.push_back(5);
	ml.push_back(540);
	cout << "ml单向链表容器的第2项：" << ml.at(2) << "           ml单向链表容器的第-1项：" << (NULL == ml[-1] ? "NULL" : "NOT NULL") << endl;;
	return 0;
}
*///“ml单向链表容器的at成员方法和重载中括号的安全检测方式已正常运行”^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
	}
	void push_back(T t) {
		node* newnode = new node;
		node** findnode = &head;
		newnode->set(t, nullptr);
		while (nullptr != (*findnode)->next) {
			findnode = &(*findnode)->next;
		}
		(*findnode)->next = newnode;
		ic++;
	}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (nullptr != head->next) {
			findnode = findnode->next;
			if (findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		this->ic = ml.ic;
		int ia = 0;
		clear();
		node* findnode = head->next;
		for (int i = 0; i < this->ic; i++) {
			i && (findnode = findnode->next);
			push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		this->head->next = nullptr;
		*this = ml;
	}
	mylist(const T* const tarr) {
		//this->head->t = nullptr;
		this->head->next = nullptr;
		if (sizeof * tarr) {
			ic = sizeof * tarr / sizeof(*tarr)[0];
			T* tp = tarr;
			for (int i = 0; i < ic; i++) {
				push_back(*tp++);
			}
		}
	}
	void insert(T t, int i) {
		if (ic > i && i >= 0) {
			node* findnode = head->next;
			node* newnode = new node;
			newnode->set(t, nullptr);
			for (; i; i--) {
				findnode = findnode->next;
			}
			findnode->next = newnode;
			ic++;
		}
	}
	void del_back() {
		if (ic) {
			node** prenode = &head;
			while (nullptr != (*prenode)->next->next) {
				prenode = &((*prenode)->next);
			}
			node** delnode = &((*prenode)->next);
			(*prenode)->next = nullptr;
			delete *delnode;
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	void del_index(int index) {
		if (ic) {
			if (ic - 1 == index) {
				del_back();
			}
			else if (ic > index && index >= 0) {
				node* prenode = head;
				for (; index > 0; index--) {
					prenode = prenode->next;
				}
				node* delnode = prenode->next;
				node* nextnode = delnode->next;
				prenode->next = nextnode;
				delnode->next = nullptr;
				delete delnode;
			}
			ic--;
		}
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
	void myreverse() {
		if (ic >= 2) {
			node* lastnode = head->next;
			node* findnode = head;
			while (nullptr != lastnode->next) {
				lastnode = lastnode->next;
			}
			while (nullptr != head->next->next) {
				findnode = head;
				while (findnode->next->next) {
					findnode = findnode->next;
				}
				findnode->next->next = findnode;
				findnode->next = nullptr;
			}
			head->next = lastnode;

		}// n 1 2 3
	}
	T& operator[](int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
};
*///“del_back方法已重新构建”^
/*
//meiri.cpp
#include <iostream>
#include <list>
#include "mylist.hpp"
using namespace std;

int main() {
	mylist<int>ml;
	ml.push_back(54);
	ml.push_back(-54);
	ml.push_back(5);
	ml.push_back(540);
	ml.del_back();
	cout << "ml单向链表容器的容量：" << ml.capacity() << endl;
	return 0;
}
*///新del_back方法已测试好^
/*
//meiri.cpp
#include <iostream>
#include <list>
#include "mylist.hpp"
using namespace std;

int main() {
	mylist<int>ml;
	ml.push_back(54);
	ml.push_back(-54);
	ml.push_back(5);
	ml.push_back(540);
	ml.clear();
	cout << "ml单向链表容器的容量：" << ml.capacity() << endl;
	return 0;
}
*///clear方法已测试好^
/*
//meiri.cpp
#include <iostream>
#include <list>
#include "mylist.hpp"
using namespace std;

int main() {
	mylist<int>ml;
	ml.del_back();
	ml.del_back();
	ml.del_back();
	ml.clear();
	ml.clear();
	ml.del_back();
	cout << "程序已正常运行" << endl;
	return 0;
}
*///mylist单向链表的del_back方法和clear方法的安全检测方式已正常运行^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
	}
	void push_back(T t) {
		node* newnode = new node;
		node** findnode = &head;
		newnode->set(t, nullptr);
		while (nullptr != (*findnode)->next) {
			findnode = &(*findnode)->next;
		}
		(*findnode)->next = newnode;
		ic++;
	}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (nullptr != head->next) {
			findnode = findnode->next;
			if (findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		this->ic = ml.ic;
		int ia = 0;
		clear();
		node* findnode = head->next;
		for (int i = 0; i < this->ic; i++) {
			i && (findnode = findnode->next);
			push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		this->head->next = nullptr;
		*this = ml;
	}
	mylist(const T* const tarr) {
		//this->head->t = nullptr;
		this->head->next = nullptr;
		if (sizeof * tarr) {
			ic = sizeof * tarr / sizeof(*tarr)[0];
			T* tp = tarr;
			for (int i = 0; i < ic; i++) {
				push_back(*tp++);
			}
		}
	}
	void insert(T t, int i) {
		if (ic > i && i >= 0) {
			node* findnode = head->next;
			node* newnode = new node;
			newnode->set(t, nullptr);
			for (; i; i--) {
				findnode = findnode->next;
			}
			findnode->next = newnode;
			ic++;
		}
	}
	void del_back() {
		if (ic) {
			node** prenode = &head;
			while (nullptr != (*prenode)->next->next) {
				prenode = &((*prenode)->next);
			}
			node** delnode = &((*prenode)->next);
			(*prenode)->next = nullptr;
			delete *delnode;
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	void del_index(int index) {
		if (ic) {
			if (ic - 1 == index) {
				del_back();
			}
			else if (ic > index && index >= 0) {
				node** prenode = &head;
				for (; index > 0; index--) {
					prenode = &(*prenode)->next;
				}
				node** delnode = &(*prenode)->next;
				node** nextnode = &(*delnode)->next;
				&(*prenode)->next = nextnode;
				(*delnode)->next = nullptr;
				delete *delnode;
			}
			ic--;
		}
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
	void myreverse() {
		if (ic >= 2) {
			node* lastnode = head->next;
			node* findnode = head;
			while (nullptr != lastnode->next) {
				lastnode = lastnode->next;
			}
			while (nullptr != head->next->next) {
				findnode = head;
				while (findnode->next->next) {
					findnode = findnode->next;
				}
				findnode->next->next = findnode;
				findnode->next = nullptr;
			}
			head->next = lastnode;

		}// n 1 2 3
	}
	T& operator[](int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
};
*///mylist单向链表中的del_index方法的实现方式已改变^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
	}
	void push_back(T t) {
		node* newnode = new node;
		node** findnode = &head;
		newnode->set(t, nullptr);
		while (nullptr != (*findnode)->next) {
			findnode = &(*findnode)->next;
		}
		(*findnode)->next = newnode;
		ic++;
	}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (nullptr != head->next) {
			findnode = findnode->next;
			if (findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		this->ic = ml.ic;
		int ia = 0;
		clear();
		node* findnode = head->next;
		for (int i = 0; i < this->ic; i++) {
			i && (findnode = findnode->next);
			push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		this->head->next = nullptr;
		*this = ml;
	}
	mylist(const T* const tarr) {
		//this->head->t = nullptr;
		this->head->next = nullptr;
		if (sizeof * tarr) {
			ic = sizeof * tarr / sizeof(*tarr)[0];
			T* tp = tarr;
			for (int i = 0; i < ic; i++) {
				push_back(*tp++);
			}
		}
	}
	void insert(T t, int i) {
		if (ic > i && i >= 0) {
			node* findnode = head->next;
			node* newnode = new node;
			newnode->set(t, nullptr);
			for (; i; i--) {
				findnode = findnode->next;
			}
			findnode->next = newnode;
			ic++;
		}
	}
	void del_back() {
		if (ic) {
			node** prenode = &head;
			while (nullptr != (*prenode)->next->next) {
				prenode = &((*prenode)->next);
			}
			node** delnode = &((*prenode)->next);
			(*prenode)->next = nullptr;
			delete *delnode;
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	void del_index(int index) {
		if (ic > index && index >= 0) {
			node** prenode = &head;
			for (; index > 0; index--) {
				prenode = &(*prenode)->next;
			}
			node** delnode = &((*prenode)->next);
			node* nextnode = (*delnode)->next;
			delete* delnode;
			(*prenode)->next = nextnode;
			ic--;
		}
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
	void myreverse() {
		if (ic >= 2) {
			node* lastnode = head->next;
			node* findnode = head;
			while (nullptr != lastnode->next) {
				lastnode = lastnode->next;
			}
			while (nullptr != head->next->next) {
				findnode = head;
				while (findnode->next->next) {
					findnode = findnode->next;
				}
				findnode->next->next = findnode;
				findnode->next = nullptr;
			}
			head->next = lastnode;

		}// n 1 2 3
	}
	T& operator[](int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
};
*///mylist单向链表中的del_index方法的实现方式已再次改变^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
	}
	void push_back(T t) {
		node* newnode = new node;
		node** findnode = &head;
		newnode->set(t, nullptr);
		while (nullptr != (*findnode)->next) {
			findnode = &(*findnode)->next;
		}
		(*findnode)->next = newnode;
		ic++;
	}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (nullptr != head->next) {
			findnode = findnode->next;
			if (findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		this->ic = ml.ic;
		int ia = 0;
		clear();
		node* findnode = head->next;
		for (int i = 0; i < this->ic; i++) {
			i && (findnode = findnode->next);
			push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		this->head->next = nullptr;
		*this = ml;
	}
	mylist(const T* const tarr) {
		//this->head->t = nullptr;
		this->head->next = nullptr;
		if (sizeof * tarr) {
			ic = sizeof * tarr / sizeof(*tarr)[0];
			T* tp = tarr;
			for (int i = 0; i < ic; i++) {
				push_back(*tp++);
			}
		}
	}
	void insert(T t, int i) {
		if (ic && ic > i && i >= 0) {
			node** findnode = &head;
			for (; i; i--) {
				findnode = &(*findnode)->next;
			}
			node* newnode = new node;
			newnode->set(t, (*findnode)->next);
			(*findnode)->next = newnode;
			ic++;
		}
	}
	void del_back() {
		if (ic) {
			node** prenode = &head;
			while (nullptr != (*prenode)->next->next) {
				prenode = &((*prenode)->next);
			}
			node** delnode = &((*prenode)->next);
			(*prenode)->next = nullptr;
			delete *delnode;
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	void del_index(int index) {
		if (ic > index && index >= 0) {
			node** prenode = &head;
			for (; index > 0; index--) {
				prenode = &(*prenode)->next;
			}
			node** delnode = &((*prenode)->next);
			node* nextnode = (*delnode)->next;
			delete* delnode;
			(*prenode)->next = nextnode;
			ic--;
		}
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
	void myreverse() {
		if (ic >= 2) {
			node* lastnode = head->next;
			node* findnode = head;
			while (nullptr != lastnode->next) {
				lastnode = lastnode->next;
			}
			while (nullptr != head->next->next) {
				findnode = head;
				while (findnode->next->next) {
					findnode = findnode->next;
				}
				findnode->next->next = findnode;
				findnode->next = nullptr;
			}
			head->next = lastnode;

		}// n 1 2 3
	}
	T& operator[](int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
};
*///mylist单向链表的insert方法的实现方式已重新修改^
/*
//meiri.cpp
#include <iostream>
#include <list>
#include "mylist.hpp"
using namespace std;

int main() {
	mylist<int>ml;
	ml.insert(-1, -1);
	ml.insert(0, 0);
	ml.push_back(6565);
	ml.push_back(12345);
	ml.push_back(-665);
	ml.push_back(655);
	ml.insert(114514, 2);
	cout << "ml单向链表容器的容量：" << ml.capacity() << endl << endl << "ml单项链表容器的第2项：" << ml[2] << endl;;
	return 0;
}
*///ml单向链表的insert方法已正常运行，ml单向链表insert方法的安全性检测已正常运行^
/*
//mylist.hpp
#pragma once
#include <iostream>
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
	}
	void push_back(T t) {
		node* newnode = new node;
		node** findnode = &head;
		newnode->set(t, nullptr);
		while (nullptr != (*findnode)->next) {
			findnode = &(*findnode)->next;
		}
		(*findnode)->next = newnode;
		ic++;
	}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (nullptr != findnode->next) {
			findnode = findnode->next;
			if (t == findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		this->ic = ml.ic;
		int ia = 0;
		clear();
		node* findnode = head->next;
		for (int i = 0; i < this->ic; i++) {
			i && (findnode = findnode->next);
			push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		this->head->next = nullptr;
		*this = ml;
	}
	mylist(const T* const tarr) {
		//this->head->t = nullptr;
		this->head->next = nullptr;
		if (sizeof * tarr) {
			ic = sizeof * tarr / sizeof(*tarr)[0];
			T* tp = tarr;
			for (int i = 0; i < ic; i++) {
				push_back(*tp++);
			}
		}
	}
	void insert(T t, int i) {
		if (ic && ic > i && i >= 0) {
			node** findnode = &head;
			for (; i; i--) {
				findnode = &(*findnode)->next;
			}
			node* newnode = new node;
			newnode->set(t, (*findnode)->next);
			(*findnode)->next = newnode;
			ic++;
		}
	}
	void del_back() {
		if (ic) {
			node** prenode = &head;
			while (nullptr != (*prenode)->next->next) {
				prenode = &((*prenode)->next);
			}
			node** delnode = &((*prenode)->next);
			(*prenode)->next = nullptr;
			delete *delnode;
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	void del_index(int index) {
		if (ic > index && index >= 0) {
			node** prenode = &head;
			for (; index > 0; index--) {
				prenode = &(*prenode)->next;
			}
			node** delnode = &((*prenode)->next);
			node* nextnode = (*delnode)->next;
			delete* delnode;
			(*prenode)->next = nextnode;
			ic--;
		}
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
	void myreverse() {
		if (ic >= 2) {
			node* lastnode = head->next;
			node* findnode = head;
			while (nullptr != lastnode->next) {
				lastnode = lastnode->next;
			}
			while (nullptr != head->next->next) {
				findnode = head;
				while (findnode->next->next) {
					findnode = findnode->next;
				}
				findnode->next->next = findnode;
				findnode->next = nullptr;
			}
			head->next = lastnode;

		}// n 1 2 3
	}
	T& operator[](int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
};
*///mylist单向链表的indexfind方法的内部实现已重写^
/*
//meiri.cpp
#include <iostream>
#include <list>
#include "mylist.hpp"
using namespace std;

int main() {
	mylist<int>ml;
	ml.push_back(6565);
	ml.push_back(12345);
	ml.push_back(-665);
	ml.push_back(655);
	cout << "ml单向链表中12345的位置：" << ml.indexfind(12345) << endl << "ml单向链表中-12345的位置：" << ml.indexfind(-12345) << "(无)" << endl;
	return 0;
}
*///mylist单向链表的indexfind方法已测试完毕^
/*
//mylist.hpp
#pragma once
#include <iostream>
#include <stack>
using std::stack;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
	}
	void push_back(T t) {
		node* newnode = new node;
		node** findnode = &head;
		newnode->set(t, nullptr);
		while (nullptr != (*findnode)->next) {
			findnode = &(*findnode)->next;
		}
		(*findnode)->next = newnode;
		ic++;
	}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (nullptr != findnode->next) {
			findnode = findnode->next;
			if (t == findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		this->ic = ml.ic;
		int ia = 0;
		clear();
		node* findnode = head->next;
		for (int i = 0; i < this->ic; i++) {
			i && (findnode = findnode->next);
			push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		this->head->next = nullptr;
		*this = ml;
	}
	mylist(const T* const tarr) {
		//this->head->t = nullptr;
		this->head->next = nullptr;
		if (sizeof * tarr) {
			ic = sizeof * tarr / sizeof(*tarr)[0];
			T* tp = tarr;
			for (int i = 0; i < ic; i++) {
				push_back(*tp++);
			}
		}
	}
	void insert(T t, int i) {
		if (ic && ic > i && i >= 0) {
			node** findnode = &head;
			for (; i; i--) {
				findnode = &(*findnode)->next;
			}
			node* newnode = new node;
			newnode->set(t, (*findnode)->next);
			(*findnode)->next = newnode;
			ic++;
		}
	}
	void del_back() {
		if (ic) {
			node** prenode = &head;
			while (nullptr != (*prenode)->next->next) {
				prenode = &((*prenode)->next);
			}
			node** delnode = &((*prenode)->next);
			(*prenode)->next = nullptr;
			delete *delnode;
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	void del_index(int index) {
		if (ic > index && index >= 0) {
			node** prenode = &head;
			for (; index > 0; index--) {
				prenode = &(*prenode)->next;
			}
			node** delnode = &((*prenode)->next);
			node* nextnode = (*delnode)->next;
			delete* delnode;
			(*prenode)->next = nextnode;
			ic--;
		}
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
	void myreverse() {
		if (nullptr != head) {
			int newc = ic;
			stack<node*>s;
			node* snode = head;
			while (nullptr != snode->next) {
				s.push(snode->next);
				snode = snode->next;
			}
			this->clear();
			head->next = s.top();
			s.pop();
			node** addnode = &(head->next);
			while (s.size()) {
				(*addnode)->next = s.top();
				addnode = &((*addnode)->next);
				s.pop();
			}
			(*addnode)->next = nullptr;
			ic = newc;
		}
	}
	T& operator[](int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
};
*///mylist单向链表的myreverse方法的内部实现已重新构造^
/*
//meiri.cpp
#include <iostream>
#include "mylist.hpp"
using namespace std;

int main() {
	mylist<int>ml;
	ml.push_back(6565);
	ml.push_back(12345);
	ml.push_back(-665);
	ml.push_back(655);
	ml.myreverse();
	cout << ml[0] << " " << ml[1] << " " << ml[2] << " " << ml[3] << endl;
	return 0;
}
*///mylist单向链表的myreverse方法已测试完毕^
/*
//mylist.hpp
#pragma once
#include <iostream>
#include <stack>
using std::stack;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
	}
	void push_back(T t) {
		node* newnode = new node;
		node** findnode = &head;
		newnode->set(t, nullptr);
		while (nullptr != (*findnode)->next) {
			findnode = &(*findnode)->next;
		}
		(*findnode)->next = newnode;
		ic++;
	}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (nullptr != findnode->next) {
			findnode = findnode->next;
			if (t == findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		this->ic = ml.ic;
		int ia = 0;
		clear();
		node* findnode = head->next;
		for (int i = 0; i < this->ic; i++) {
			i && (findnode = findnode->next);
			push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		this->head->next = nullptr;
		*this = ml;
	}
	void insert(T t, int i) {
		if (ic && ic > i && i >= 0) {
			node** findnode = &head;
			for (; i; i--) {
				findnode = &(*findnode)->next;
			}
			node* newnode = new node;
			newnode->set(t, (*findnode)->next);
			(*findnode)->next = newnode;
			ic++;
		}
	}
	void del_back() {
		if (ic) {
			node** prenode = &head;
			while (nullptr != (*prenode)->next->next) {
				prenode = &((*prenode)->next);
			}
			node** delnode = &((*prenode)->next);
			(*prenode)->next = nullptr;
			delete *delnode;
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	void del_index(int index) {
		if (ic > index && index >= 0) {
			node** prenode = &head;
			for (; index > 0; index--) {
				prenode = &(*prenode)->next;
			}
			node** delnode = &((*prenode)->next);
			node* nextnode = (*delnode)->next;
			delete* delnode;
			(*prenode)->next = nextnode;
			ic--;
		}
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
	void myreverse() {
		if (nullptr != head) {
			int newc = ic;
			stack<node*>s;
			node* snode = head;
			while (nullptr != snode->next) {
				s.push(snode->next);
				snode = snode->next;
			}
			this->clear();
			head->next = s.top();
			s.pop();
			node** addnode = &(head->next);
			while (s.size()) {
				(*addnode)->next = s.top();
				addnode = &((*addnode)->next);
				s.pop();
			}
			(*addnode)->next = nullptr;
			ic = newc;
		}
	}
	T& operator[](int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
};
*///mylist单向链表的复制构造函数已删除^
/*
//mylist.hpp
#pragma once
#include <iostream>
#include <stack>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
	}
	void push_back(T t) {
		node* newnode = new node;
		node** findnode = &head;
		newnode->set(t, nullptr);
		while (nullptr != (*findnode)->next) {
			findnode = &(*findnode)->next;
		}
		(*findnode)->next = newnode;
		ic++;
	}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (nullptr != findnode->next) {
			findnode = findnode->next;
			if (t == findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.head;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	void insert(T t, int i) {
		if (ic && ic > i && i >= 0) {
			node** findnode = &head;
			for (; i; i--) {
				findnode = &(*findnode)->next;
			}
			node* newnode = new node;
			newnode->set(t, (*findnode)->next);
			(*findnode)->next = newnode;
			ic++;
		}
	}
	void del_back() {
		if (ic) {
			node** prenode = &head;
			while (nullptr != (*prenode)->next->next) {
				prenode = &((*prenode)->next);
			}
			node** delnode = &((*prenode)->next);
			(*prenode)->next = nullptr;
			delete *delnode;
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	void del_index(int index) {
		if (ic > index && index >= 0) {
			node** prenode = &head;
			for (; index > 0; index--) {
				prenode = &(*prenode)->next;
			}
			node** delnode = &((*prenode)->next);
			node* nextnode = (*delnode)->next;
			delete* delnode;
			(*prenode)->next = nextnode;
			ic--;
		}
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
	void myreverse() {
		if (nullptr != head) {
			int newc = ic;
			stack<node*>s;
			node* snode = head;
			while (nullptr != snode->next) {
				s.push(snode->next);
				snode = snode->next;
			}
			this->clear();
			head->next = s.top();
			s.pop();
			node** addnode = &(head->next);
			while (s.size()) {
				(*addnode)->next = s.top();
				addnode = &((*addnode)->next);
				s.pop();
			}
			(*addnode)->next = nullptr;
			ic = newc;
		}
	}
	T& operator[](int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
};
*///重载运算符“=”的内部实现已重新修改^
/*
//mylist.hpp
#pragma once
#include <iostream>
#include <stack>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
	}
	void push_back(T t) {
		node* newnode = new node;
		node** findnode = &head;
		newnode->set(t, nullptr);
		while (nullptr != (*findnode)->next) {
			findnode = &(*findnode)->next;
		}
		(*findnode)->next = newnode;
		ic++;
	}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (nullptr != findnode->next) {
			findnode = findnode->next;
			if (t == findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.head;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		head = new node;
		head->set();
		if (sizeof *tarr) {
			const T* tp = tarr;
			for (int i = 0; i < has; i++) {
				push_back(*tp++);
			}
		}
	}
	void insert(T t, int i) {
		if (ic && ic > i && i >= 0) {
			node** findnode = &head;
			for (; i; i--) {
				findnode = &(*findnode)->next;
			}
			node* newnode = new node;
			newnode->set(t, (*findnode)->next);
			(*findnode)->next = newnode;
			ic++;
		}
	}
	void del_back() {
		if (ic) {
			node** prenode = &head;
			while (nullptr != (*prenode)->next->next) {
				prenode = &((*prenode)->next);
			}
			node** delnode = &((*prenode)->next);
			(*prenode)->next = nullptr;
			delete *delnode;
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	void del_index(int index) {
		if (ic > index && index >= 0) {
			node** prenode = &head;
			for (; index > 0; index--) {
				prenode = &(*prenode)->next;
			}
			node** delnode = &((*prenode)->next);
			node* nextnode = (*delnode)->next;
			delete* delnode;
			(*prenode)->next = nextnode;
			ic--;
		}
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
	void myreverse() {
		if (nullptr != head) {
			int newc = ic;
			stack<node*>s;
			node* snode = head;
			while (nullptr != snode->next) {
				s.push(snode->next);
				snode = snode->next;
			}
			this->clear();
			head->next = s.top();
			s.pop();
			node** addnode = &(head->next);
			while (s.size()) {
				(*addnode)->next = s.top();
				addnode = &((*addnode)->next);
				s.pop();
			}
			(*addnode)->next = nullptr;
			ic = newc;
		}
	}
	T& operator[](int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
	void printlist(void (*printfun)(T item, bool b)) {
		if (ic) {
			node* printnode = head;
			while (nullptr != printnode->next) {
				printnode = printnode->next;
				printfun(printnode->t, nullptr != printnode->next);
			}
		}
	}
};
*///已新构建出mylist单向链表的printlist方法^
/*
//meiri.cpp
#include <iostream>
#include <list>
#include "mylist.hpp"
using namespace std;

void printstr(char ch, bool status) {
	cout << ch;
	status || cout << endl;
}

int main() {
	mylist<char>ml("Hello, world!", sizeof "Hello, world!");
	ml.printlist(printstr);
	return 0;
}
*///mylist单向链表的printstr方法已测试好^
/*
//meiri.cpp
#include <iostream>
#include <list>
#include "mylist.hpp"
using namespace std;

void printarr(int i, bool status) {
	cout << i;
	if (status) {
		cout << ", ";
	}
	else {
		cout << endl;
	}
}

int main() {
	int arr[7] = { 1,3,5,5,8,8,9 };
	mylist<int>ml(arr, 7);
	ml.printlist(printarr);
	return 0;
}
*///单向链表的实际应用之一^
/*
//meiri.cpp
#include <iostream>
#include <list>
#include "mylist.hpp"
using namespace std;

void printarr(int i, bool status) {
	cout << i << " -> ";
	if (!status) {
		cout << "nullptr" << endl;
	}
}

int main() {
	mylist<int>ml;
	int i = -1;
	while (i++ < 10) {
		ml.push_back(i);
	}
	ml.printlist(printarr);
	return 0;
}
*///也是单向链表的实际应用之一^
/*
//MX.cpp
#include <iostream>
using namespace std;
#include <cstring>
#include "MX.h"
//怪物MX的设置函数
void MX::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*, char** pcpp, char(*strmap)[11][11], int, int, bool, bool) {
	m_v = v;
	if (nullptr == cpp) {
		m_cpp = cpp;
	}
	else {
		tempcp = *cpp;
		cpp = NULL;
		m_cpp = &tempcp;
	}
	m_pcpp = pcpp;
	nullptr != strmap && (m_strmap = strmap);
	m_iheal = iheal;
	setb = 1;
	
}
//怪物MX的额外设置函数
void MX::exset(char strmapr[11][11]) {
	memcpy(m_strmapr, strmapr, sizeof m_strmapr);
}
//构造函数
MX::MX() {
	set();
}
void MX::mosterdo() {
	vector<trir>::iterator it = m_v->begin();
	if (setb) {
		pxy = { (*m_cpp - &(*m_strmap)[0][0]) / 11, (*m_cpp - &(*m_strmap)[0][0]) % 11 };//设置怪物MX的坐标
		m_cc = m_strmapr[pxy.first][setb = 0, pxy.second];//设置盖住的块
	}
	for (; m_v->end() != it; it++) {
		if (*m_cpp == it->cp || *m_cpp == it->cp - (1 - it->b * 2)) {//如果怪物受伤了就停止这个循环
			break;
		}
	}
	if (m_iheal > 0 && (*m_cpp == *m_pcpp || m_v->end() != it)) {//如果刚才的这个循环停止了，并且还有生命且不在玩家的位置上
		tempcp = *m_cpp;//防指针的链式移动
		char* tempcpb = tempcp;
		bool tempb = 1;//防误覆盖空位
		m_cpp = NULL;
		do {
			tempb && m_v->end() != it && (*tempcp = ' ');//便于移动之后的显示
			tempcp = &(*m_strmap)[pxy.first = rand() % 9 + 1][pxy.second = rand() % 9 + 1];//怪物MX的移动
		} while ((tempcp == &(*m_strmap)[9][1] || '@' == (*m_strmap)[pxy.first][pxy.second] || '@' == (*m_strmap)[pxy.first][pxy.second - 1] || '@' == (*m_strmap)[pxy.first][pxy.second + 1] || tempcp == *m_pcpp || '*' == tempcp[-1] || '*' == tempcp[1] || 'X' == (tempcp)[-1] || 'X' == *tempcp || 'X' == (tempcp)[1]) && (tempb = 0, 1));//如果满足上述的条件，就把误覆盖空位的“开关”启动
		m_cpp = &tempcp;
		*tempcpb = m_cc;
		('@' != m_strmapr[pxy.first][pxy.second] || 'X' != m_strmapr[pxy.first][pxy.second] && 'P' != m_strmapr[pxy.first][pxy.second]) && (m_cc = m_strmapr[pxy.first][pxy.second]);//记录盖住的块，不记录“@”子弹，“P”玩家和“X”怪物MX自己
	}
	//main函数使见
}//被玩家碰到传，受伤传(两旁有砖不传)，并见
char MX::getm() {
	return 'X';
}
char MX::getm(bool) {
	return m_cc;
}
//MO.cpp
#include <iostream>
using namespace std;
#include "MO.h"
#define NNEG(A, B) ((A) < (B) ? 1 : (A) > (B) ? -1 : 0)//判断宏
#define MOWAIT 1//怪物MO等待的回合数
pair<int, int> MO::s_m_pxy = {0, 0};//玩家坐标的初始化
//构造函数
MO::MO() {
	set();
}
//MO的设置函数
void MO::set(vector<trir>* v, char** cpp, int iheal, map<char**, WASD>*m, char**, char(*)[11][11], int ix, int iy, bool, bool) {
	m_v = v;
	m_cpp = cpp;
	m_iheal = iheal;
	m_pxy.first = ix;
	m_pxy.second = iy;
	imove = 0;
	if (nullptr != m) { 
		m_m = *m;
	}
}
void MO::mosterdo() {
    '*' != **m_cpp && (**m_cpp = ' ');//便于移动之后的显示
	tempcp = *m_cpp;//防指针的链式带动
	m_cpp = NULL;
	if (!m_m.empty()) {//沿路模式
		int arr[4] = { -11, -1, 11, 1 };//怪物MO可能会移动的四个方位
		for (map<char**, WASD>::iterator it = m_m.begin(); m_m.end() != it; it++) {//改变怪物MO的方向
			E != it->second && tempcp == *it->first && (m_wasd = it->second);
		}
		switch (tempcp += (arr[m_wasd]), m_wasd) {//怪物的移动与xy坐标的变化
		case W:
			m_pxy.second--;
			break;
		case A:
			m_pxy.first--;
			break;
		case S:
			m_pxy.second++;
			break;
		case D:
			m_pxy.first++;
			break;
		default:
			break;
		}
	}
	else {//追踪模式
		MOWAIT == imove % (MOWAIT + 1)/*如果MO等待了MOWAIT回合*/ && ('*' != *(tempcp + 11 * NNEG(m_pxy.first, s_m_pxy.first))/*并且垂直移动的方向上没有墙*/ && (tempcp += 11 * NNEG(m_pxy.first, s_m_pxy.first)/*那么怪物MO就往玩家垂直地移动*/, m_pxy.first += NNEG(m_pxy.first, s_m_pxy.first)/*怪物的x坐标也随之变化*/));//根据怪物的xy坐标和玩家的xy坐标来移动
		MOWAIT == imove++ % (MOWAIT + 1) && ('*' != *(tempcp + NNEG(m_pxy.second, s_m_pxy.second)/*并且水平移动的方向上没有墙*/) && (tempcp += NNEG(m_pxy.second, s_m_pxy.second)/*那么怪物MO就往玩家水平地移动*/, m_pxy.second += NNEG(m_pxy.second, s_m_pxy.second)/*怪物的y坐标也随之变化*/));
	}
	m_cpp = &tempcp;
}//遇向则转，看路前行（1），或追玩者（2）
//设置玩家的坐标
void MO::set_s_pxy(int ix, int iy) {
	s_m_pxy = { ix, iy };
}
char MO::getm() {
	return 'O';
}
*///解决在小BOSS战中有的怪物MO乱走，怪物MX在被子弹打后移动本不应该移动的另一个怪物MX并且也没有使移动前的位置设为空格的两个bug^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {//难度
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());//左边条件防出bug
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');//左边条件也防出bug
}
void start(int ichoose) {//开始时打印大字函数
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {//胜利后打印函数
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *      *  * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {//地牢图
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	bool bc = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;//小BOSS战时需要
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };//<-画“#”时所需要的数组
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };//<-画“#”时所需要的数组
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {//第5地牢的怪物移动路线
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	vism.reserve(11000);//防bug出
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};//生成时要的怪物坐标
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";//为告知你胜利的文字颜色
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C" };//大文字动态彩色变化数组(system("color 0" + tempstra[x(0<=x<=9)])
	mpv.reserve(10000);//也防bug出
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism.back().vmp.reserve(1000);//还防bug出
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//编号id对应的地牢怪物生成
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second || 7 <= pxy.first && 3 >= pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				tempcparr[itemp - i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 7) {
				case 0:
				case 1:
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 2:
				case 3:
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 4:
				case 5:
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, &cp, &strmap);
					break;
				case 6:
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);//小BOSS的创建
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.reserve(1000);
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[46], 10);
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;//初始值(EASY)
	//开始界面
	for (i = 0; i < 15; i++) {//大文字缓缓出现
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 9; i++) {//使大文字变成动态的彩色
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		tempstr[7] = 0;
		Sleep(100);
	}
	system("color 07");
	Sleep(500);
	cout << endl << endl << endl;//游戏的开始界面
	cout << " \033[33m@---------------------------------------------@" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m             |" << endl;
	cout << " |                                             |" << endl;
	cout << " @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {//输入错误或者输入“1”(游戏规则时)重新输入
		cin >> ch;
		if ('1' == ch) {//1.游戏规则(打印游戏规则)
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m，并且不同的\033[31;1m难度\033[0m也有不同的\033[32;1m战前回血概率\033[0m与\033[31;1m小BOSS\033[32m战前回血概率\033[0m，\033[4m越\033[31;1m难\033[0;4m这个概率就越\033[31;1m小\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {//输入错误
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {//退出
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');//难度选择('2'~'5') - '2' = (0~3)
	int temparra[4] = { 8, 5, 3, 1 };
	p.sgetxyhs(HEAL) = temparra[d];//根据玩家选的难度来设置玩家的生命
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {//地牢的生成
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				{
					int arr[12] = { 8, 5, 6, 3, 6, 7, 4, 5, 8, 9, 4, 1 };
					for (i = 0; i < 12; i += 2) {
						strmap[arr[i]][arr[i + 1]] = '*';
					}
				}
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		if (vism.size()) {//开始前画“#”以用来告知人们地牢的变化
			for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
				for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
					*drawcp = '#';
				}
			}
		}
		p.printmap(strmap, ba, iunmd);//显示游戏的游玩界面
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {//怪物死
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (bc ? 2 : ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front().vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
					int isummon = 0;
					while (255 != isummon && (!cpa || ' ' != *cpa || ('X' == mpv.back()->getm() && (cpa == &strmap[9][1] || '@' == *cpa || '@' == *(cpa - 1) || '@' == *(cpa + 1) || cpa == cp || '*' == *(cpa - 1) || '*' == *(cpa + 1) || 'X' == *(cpa - 1) || 'X' == *cpa || 'X' == *(cpa + 1))))) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						(isummon >> ira & 1) || (isummon += (1 << ira));
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					if (255 != isummon) {
						mx = (cpa - &strmap[0][0]) / 11;
						my = (cpa - &strmap[0][0]) % 11;
						switch (bc ? (bc = 0, 2) : ir) {
						case 0:
							vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
							break;
						case 1:
							vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
							break;
						case 2:
							vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
							break;
						case 3:
							vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
							break;
						default:
							break;
						}
					}
					else {
						vism.front().vmp.pop_back();
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front().vmp.begin();
			while (!vism.front().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		'*' != *cp && (*cp = 'P');
		system("cls");//清屏
		//如果vism的第0项vmp或者vism为空，那么开门，并头删
		if ((vism.empty() || vism.front().vmp.empty()) && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地牢('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			b = 0;
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				'*' != *it->cp && (*it->cp = ' ');
			}
			p.sgetxyhs()->clear();
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				!i && (strmap[9][0] = ' ');
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			bool temparrb[8] = { 1, 1, !(rand() % 2), 1, !(rand() % 4), !(rand() % 2), 0, 0};
			if (1 != vism.size()) {//恢复血量
				temparrb[d * 2] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
		    }
		    else {
				temparrb[d * 2 + 1] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
			}
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	char tempstrb[6] = "C2AA7";//胜利
	str[7] = tempstrb[(!bb) * (d + 1)];
	system(str);
	switch ((!bb) * (d + 1)) {//告知你胜利的方式
	case 0:
		cout << "很遗憾，你输了" << endl;
		break;
	case 1:
	case 2:
		cout << "恭喜你，你赢了" << endl;
		break;
	case 3:
		cout << "@------------------@" << endl;
		cout << "|                  |" << endl;
		cout << "|  恭喜你，你赢了  |" << endl;
		cout << "|                  |" << endl;
		cout << "@------------------@" << endl;
		break;
	case 4:
		for (i = 0; i < 15; i++) {
			system("cls");
			win(i);
			Sleep(10);
		}
		for (i = 0; i < 27; i++) {
			strcat(tempstr, tempstra[i % 9]);
			system(tempstr);
			tempstr[7] = 0;
			Sleep(100);
		}
		system("color 0A");
		break;
	default:
		break;
	}
	for_each(mpv.begin(), mpv.end(), del);//释放mpv和vo里new出来的怪物对象
	for_each(vo.begin(), vo.end(), delvo);//释放mpv和vo里new出来的怪物对象
	return 0;
}
*///已解决怪物MX在被怪物M_o生出来后没有按照怪物MX移动的规则(移动的规则见https://github.com/2fand/Cpp/blob/master/%E6%89%93%E5%B0%8F%E6%80%AA%E6%B8%B8%E6%88%8F/%E6%BA%90%E6%96%87%E4%BB%B6/MX.cpp)选定移动的位置的bug^
/*
//Game.cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include <iostream>
using namespace std;
#include "Player.h"
#include "mosters.h"
#include "cmpm.h"
#include "isvp.h"
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <string>
#include <cstring>
#include <Windows.h>
#include "draw.h"
enum difficulty {//难度
	EASY,
	NORMAL,
	HARD,
	LIMIT
};
void MShow(moster*& mp) {
	('X' == mp->getm() || '*' != *mp->getcp()) && (*mp->getcp() = mp->getm());//左边条件防出bug
}
void del(moster*& mp) {
	delete mp;
}
void delvo(M_o*& mp) {
	delete mp;
}
void setMempty(moster*& mp) {
	'*' != *mp->getcp() && (*mp->getcp() = ' ');//左边条件也防出bug
}
void start(int ichoose) {//开始时打印大字函数
	switch (ichoose) {
	case 14:
		cout << "      *                  *          *           " << endl;
	case 13:
		cout << "      *                  *          * ********  " << endl;
	case 12:
		cout << "      *  ********        *          *  *     *  " << endl;
	case 11:
		cout << "   ******    *           *        * **  *   *   " << endl;
	case 10:
		cout << "      *      *           *        * * *  * *    " << endl;
	case 9:
		cout << "      * *    *        *  *  *     * *     **    " << endl;
	case 8:
		cout << "     ***     *       **  *   *   *  *   **  *   " << endl;
	case 7:
		cout << "   ** *      *      *    *    *     * **  *  ** " << endl;
	case 6:
		cout << "      *      *     *     *    **    *     *     " << endl;
	case 5:
		cout << "      *      *    *      *     *    *     *     " << endl;
	case 4:
		cout << "      *      *           *          *  *******  " << endl;
	case 3:
		cout << "      *      *           *          *     *     " << endl;
	case 2:
		cout << "      *      *           *          *     *     " << endl;
	case 1:
		cout << "    * *    * *         * *          * ********* " << endl;
	case 0:
		cout << "     *      *           *           *           " << endl;
	default:
		break;
	}
} 
void win(int ichoose) {//胜利后打印函数
	switch (ichoose) {
	case 14:
		cout << "      *   *            *           *  *                       *  *              *                     " << endl;
	case 13:
		cout << "      *   *       ************     *  *                       *  *        ************** *************" << endl;
	case 12:
		cout << "   ************        *           *  *                       *  *         *                        * " << endl;
	case 11:
		cout << "      *   *        **********     *  ********                *  ********   ************            *  " << endl;
	case 10:
		cout << "      *   *                       *  *      *                *  *      *    *       *            **   " << endl;
	case 9:
		cout << "  **************   **********    ** *      *                ** *      *     *********          **     " << endl;
	case 8:
		cout << "      *    *       *        *   * *     *                  * *     *                           *      " << endl;
	case 7:
		cout << "     *  *   *      **********     *     *                    *     *      *** ***** ***        *      " << endl;
	case 6:
		cout << "    *   *    *       *    *       *   * * *                  *   * * *    * * *   * * *        *      " << endl;
	case 5:
		cout << "  **    *     ** **************   *   * *  *      **         *   * *  *   *** *   * * *        *      " << endl;
	case 4:
		cout << "     *  **  *                     *  *  *  **     **         *  *  *  **  * * * * * ***        *      " << endl;
	case 3:
		cout << "    *   * *  *     *********      * *   *   *      *         * *   *   *  *** * * * * *        *      " << endl;
	case 2:
		cout << "   *    * *  *     *       *      *     *         *          *     *      * *   *   * *        *      " << endl;
	case 1:
		cout << "      * *          *********      *   * *        *           *   * *      * *  * * *  **     * *      " << endl;
	case 0:
		cout << "       *           *       *      *    *                     *    *      *  * *   *    *      *       " << endl;
	default:
		break;
	}
}
int main() {
	srand((unsigned int)time(NULL));
	char strmap[11][11] = {//地牢图
		'*','*','*','*','*','*','*','*','*','*','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'P',' ',' ',' ',' ',' ',' ',' ',' ',' ','*',
		'*','*','*','*','*','*','*','*','*','*','*',
	};
	bool ba = 1;
	bool bb = 1;
	bool bc = 1;
	char ch = 0;
	int iunmd = 0;
	vector<M_o*>vo;//小BOSS战时需要
	vector<draw>vmd[5] = { {{5,2,6,1}}, {{3,2,4,0}, {7,2,3,1}, {3,5,4,0}, {3,5,3,1}, {3,8,4,0}}, {{3,2,4,0},{3,5,4,0},{3,8,4,0},{7,2,6,1}}, {{3,2,3,1},{3,5,4,0},{7,2,6,1}}, {{5,3,4,1},{3,5,4,0}} };//<-画“#”时所需要的数组
	multimap<int, int>mwasd[4] = { {{9,1},{9,3},{3,3},{5,3},{7,3},{9,3},{8,4},{8,8},{6,8},{4,8}}, {{2,3},{9,9},{3,8},{5,8},{7,8},{9,2}}, {{2,2},{2,7},{1,9}}, {{1,1},{2,4},{4,3},{6,3},{8,3},{8,7}} };//<-画“#”时所需要的数组
	vo.reserve(99999);
	int i = 0;
	int temparr[6] = { 4, 8, 12, 15, 17, 18 };
	int ia = rand() % 10 + 1;// 后：+1 +1 +1 +1 +2 +2 +2 +2 +3 +3 +3 +3 +4 +4 +4 +5 +5 +6
	int tempir = rand() % 22;
	for (i = 0; i < 6; i++) {
		if (tempir < temparr[i]) {
			ia += (i + 1);
			break;
		}
	}
	Player p;
	char* cp = &strmap[9][0];
	vector<map<int, int>>vm;
	map<char**, WASD>m[3];
	map<char**, WASD>em;//追踪map
	char* cparr[45] = { NULL };
	char** cpp = cparr;
	for (WASD w = W; E != w; ++w) {//第5地牢的怪物移动路线
		switch (w) {
		case W:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[10 - i][i];
				m[0].insert({cpp++, W});
			}
			break;
		case A:
			for (i = 6; i < 10; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, A});
			}
			break;
		case S:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][10 - i];
				m[0].insert({cpp++, S});
			}
			break;
		case D:
			for (i = 1; i < 5; i++) {
				*cpp = &strmap[i][i];
				m[0].insert({cpp++, D});
			}
			break;
		default:
			break;
		}
		for (multimap<int, int>::iterator it = mwasd[w].begin(); mwasd[w].end() != it; it++) {
			*cpp = &strmap[it->first][it->second];
			m[1].insert({ cpp++, w });
		}
	}
	const int arr[4] = { 6,9,1,5 };
	for (i = 0; i < 4; i++) {
		*cpp = &strmap[arr[i]][i % 2 + 1];
		m[2].insert({ cpp++, (WASD)(i / 2 * 2) });//注意：i / 2 * 2 != i
	}
	char strmapr[11][11];
	isv ism;//用来布置怪物
	vector<isv> vism;//地牢布置与怪物布置，无时即BOSS战(+)(int为编号)
	vism.reserve(11000);//防bug出
	char* strcp[47] = { &strmap[9][5], &strmap[9][7], &strmap[9][3], &strmap[1][5], &strmap[1][5], &strmap[6][1], &strmap[4][9], &strmap[6][8], &strmap[3][3], &strmap[4][3], &strmap[5][3], &strmap[6][3], &strmap[7][3], &strmap[8][3], &strmap[9][3], &strmap[4][5], &strmap[5][4], &strmap[5][5], &strmap[5][6], &strmap[6][5], &strmap[1][5], &strmap[1][5], &strmap[9][5], &strmap[9][5], &strmap[1][9], &strmap[1][1], &strmap[8][2], &strmap[2][8], &strmap[8][8], &strmap[2][2], &strmap[5][5], &strmap[1][1], &strmap[2][2], &strmap[3][3], &strmap[4][4], &strmap[8][5], &strmap[5][2], &strmap[2][4], &strmap[4][9], &strmap[1][8], &strmap[9][2], &strmap[1][1], &strmap[9][9], &strmap[3][4], &strmap[5][1], &strmap[5][9], &strmap[5][5]};//生成时要的怪物坐标
	vector<moster*>mpv;//mpv里一共要有的怪物们
	char tempstr[9] = "color 0";//为告知你胜利的文字颜色
	char tempstra[10][2] = { "C", "E", "A", "9", "D", "9", "A", "E", "C" };//大文字动态彩色变化数组(system("color 0" + tempstra[x(0<=x<=9)])
	mpv.reserve(10000);//也防bug出
	//随机设置地牢布置与怪物布置
	for (i = 0; ch < 11; ch++) {
		vism.push_back(ism);
		vism.back().vmp.reserve(1000);//还防bug出
		vism[ch].id = ch;
		int itemp = 0;
		switch (ch) {//编号id对应的地牢怪物生成
		case 0:
			for (itemp = i + 8, vism[ch].str = "O&&^^OXX"; i < itemp; i++) {
				switch (vism[ch].str[8 - (itemp - i)]) {
				case '&':
					mpv.push_back(new Mand());
					break;
				case '^':
					mpv.push_back(new MUD());
					break;
				case 'O':
					mpv.push_back(new MO());
					break;
				case 'X':
					mpv.push_back(new MX());
					break;
				default:
					break;
				}
				vism[ch].vmp.push_back(mpv[i]);
				if (8 == itemp - i) {
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &em, NULL, NULL, 9, 5);
				}
				else {
					switch (vism[ch].str[8 - (itemp - i)]) {
					case '&':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, NULL, NULL, 0, 0, itemp - i - 6);
						break;
					case '^':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 4, NULL, NULL, NULL, 0, 0, itemp - i - 4, true);
						break;
					case 'O':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 5, &m[2], NULL, NULL, 5, 2);
						break;
					case 'X':
						vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[8 - (itemp - i)], 3, NULL, &cp, &strmap);
						break;
					default:
						break;
					}
				}
			}
			break;
		case 1:
			for (itemp = i + 7; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[7 - (itemp - i) + 8], 5, &m[1], NULL, NULL, 0, 0, 10 - (i - itemp), 3);
			}
			break;
		case 2:
			for (itemp = i + 5; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 15], 3, NULL, NULL, NULL, 0, 0, 1, 1);
			}
			break;
		case 3:
			for (itemp = i + 6, vism[ch].str = "&&^^^^"; i < itemp; i++) {
				if ('&' == (vism[ch].str[6 - (itemp - i)])) {
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 3, NULL, NULL, NULL, 0, 0, (i - itemp) % 2);
				}
				else {
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[6 - (itemp - i) + 20], 4, NULL, NULL, NULL, 0, 0, (6 - (itemp - i) - 2) & 1, (6 - (itemp - i) - 2) & 2);//qezc(键盘)
				}
			}
			break;
		case 4:
			for (itemp = i + 5, vism[ch].str = "XXXXO"; i < itemp; i++) {
				if ('X' == (vism[ch].str[5 - (itemp - i)])) {
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 3, NULL, &cp, &strmap);
				}
				else {
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv[i]);
					vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[5 - (itemp - i) + 26], 5, &em, NULL, NULL, 5, 5);
				}

			}
			break;
		case 5:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MO());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 31], 5, &m[0], NULL, NULL, itemp - i, itemp - i);
			}
			break;
		case 6:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MX());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 35], 3, NULL, &cp, &strmap);
			}
			break;
		case 7:
			for (itemp = i + 4; i < itemp; i++) {
				mpv.push_back(new MUD());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[4 - (itemp - i) + 39], 4, NULL, NULL, NULL, 0, 0, (itemp - i) % 2, (itemp - i + 1) % 2);
			}
			break;
		case 8:
			for (itemp = i + 3; i < itemp; i++) {
				mpv.push_back(new Mand());
				vism[ch].vmp.push_back(mpv[i]);
				vism[ch].vmp.back()->set(p.sgetxyhs(), &strcp[3 - (itemp - i) + 43], 3, NULL, NULL, NULL, 0, 0, !((itemp - i) % 2));
			}
			break;
		case 9:
		{
			char* tempcparr[20] = { NULL };
			for (itemp = i + ia; i < itemp; i++) {
				pair<bool, bool>pbb = { rand() % 2, rand() % 2 };
				pair<int, int>pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				while ((7 == pxy.first || 5 == pxy.first) && 4 == pxy.second || 7 <= pxy.first && 3 >= pxy.second) {
					pxy = { rand() % 9 + 1, rand() % 9 + 1 };
				}
				tempcparr[itemp - i] = &strmap[pxy.first][pxy.second];
				switch (rand() % 7) {
				case 0:
				case 1:
					mpv.push_back(new Mand());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, NULL, NULL, 0, 0, pbb.first);
					break;
				case 2:
				case 3:
					mpv.push_back(new MUD());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 2, NULL, NULL, NULL, 0, 0, pbb.first, pbb.second);
					break;
				case 4:
				case 5:
					mpv.push_back(new MX());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 3, NULL, &cp, &strmap);
					break;
				case 6:
					mpv.push_back(new MO());
					vism[ch].vmp.push_back(mpv.back());
					vism[ch].vmp.back()->set(p.sgetxyhs(), tempcparr + itemp - i, 5, &em, NULL, NULL, pxy.first, pxy.second);
					break;
				default:
					break;
				}
			}
		}
		break;
		default:
			break;
		}
	}
	random_shuffle(vism.begin(), vism.end());//使地牢随机化
	while (4 != vism.size()) {
		vism.pop_back();//删除本次游戏不需要的地牢
	}
	vism.push_back(ism);//小BOSS的创建
	vism.back().id = 10;
	mpv.push_back(new Mplus());
	vism.back().vmp.reserve(1000);
	vism.back().vmp.push_back(mpv.back());
	vism.back().vmp.back()->set(p.sgetxyhs(), &strcp[46], 10);
	int ishoot = 0;
	int bosswait = 0;
	bool b = 0;
	char str[9] = "color 0";
	difficulty d = EASY;//初始值(EASY)
	//开始界面
	for (i = 0; i < 15; i++) {//大文字缓缓出现
		system("cls");
		start(i);
		Sleep(10);
	}
	Sleep(10);
	for (i = 0; i < 9; i++) {//使大文字变成动态的彩色
		strcat(tempstr, tempstra[i]);
		system(tempstr);
		tempstr[7] = 0;
		Sleep(100);
	}
	system("color 07");
	Sleep(500);
	cout << endl << endl << endl;//游戏的开始界面
	cout << " \033[33m@---------------------------------------------@" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[0m1. 游戏规则           \033[32;1m2. 开始游戏(简单)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   3. 开始游戏(普通)     \033[31;1m4. 开始游戏(困难)\033[0;33m   |" << endl;
	cout << " |                                             |" << endl;
	cout << " |   \033[31m5. 开始游戏(极限)\033[1m     0. 退出\033[0;33m             |" << endl;
	cout << " |                                             |" << endl;
	cout << " @---------------------------------------------@\033[0m" << endl;
	cout << endl << endl << endl;
	while ('1' == ch || '0' > ch || ch > '5') {//输入错误或者输入“1”(游戏规则时)重新输入
		cin >> ch;
		if ('1' == ch) {//1.游戏规则(打印游戏规则)
			cout << "游戏规则：" << endl;
			cout << "    “P”是你，“*”是墙，a键左移，d键右移，w键跳，s及其其他键让时间流逝，上面显示你的\033[32;1m生\033[0;33m命\033[31;1m值\033[0m，如果你生命值\033[31m归0\033[0m，那么你就\033[31;1m失败\033[0m，在遇到\033[31;1m怪物\033[0m的时候，你要按下z键用枪射出\033[33m子弹射\033[31;1m死\033[0m各种各样的\033[31;1m怪物\033[0m，\033[31;1m怪物\033[0m是怎么样的你自己看，如果你碰到了\033[31;1m怪物\033[0m，那么你就会被\033[31;1m怪物伤到\033[0m，\033[31;1m血量减1\033[0m，而打败\033[31;1m小BOSS\033[0m“\033[33m+\033[0m”并从\033[31;1m小BOSS\033[0m的房间中\033[32;1m走出去\033[0m即可\033[32;1m胜利\033[0m。而这个游戏有四种可游玩的模式：一种是\033[32;1m简单模式\033[0m，一种是\033[33m普通模式\033[0m，一种是\033[31;1m困难模式\033[0m，一种是\033[31m极限模式\033[0m，其中，\033[32;1m简单模式\033[0m会让你开始时有\033[32;1m8滴血\033[0m，\033[33m普通模式\033[0m会让你开始时有\033[33m5滴血\033[0m，\033[31;1m困难模式\033[0m会让你开始时有\033[31;1m3滴血\033[0m，而\033[31m极限模式\033[0m会让你开始时\033[31;4m只有1滴血\033[0m；同样，\033[4m我们也会根据你选择的\033[31;1m难度\033[0;4m来选择不同的告知你\033[32;1m胜利方式\033[0m：\033[4m如果你选择了\033[31;1m难玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也更\033[32;1m新奇\033[0;4m；反之如果你选择了\033[32;1m易玩的难度\033[0;4m，那么告知你\033[32;1m胜利方式\033[0;4m也\033[31;1m更不新奇\033[0m，并且不同的\033[31;1m难度\033[0m也有不同的\033[32;1m战前回血概率\033[0m与\033[31;1m小BOSS\033[32m战前回血概率\033[0m，\033[4m越\033[31;1m难\033[0;4m这个概率就越\033[31;1m小\033[0m。这就是这个打小怪游戏的规则，你听明白了吗?" << endl << endl;
		}
		else if ('0' > ch || ch > '5') {//输入错误
			cout << "\033[31;1m输入错误，请重新输入\033[0m" << endl << endl;
		}
		rewind(stdin);
	}
	if ('0' == ch) {//退出
		cout << endl << "欢迎下次游玩" << endl;
		return 0;
	}
	d = (difficulty)(ch - '2');//难度选择('2'~'5') - '2' = (0~3)
	int temparra[4] = { 8, 5, 3, 1 };
	p.sgetxyhs(HEAL) = temparra[d];//根据玩家选的难度来设置玩家的生命
	system("cls");
	while (p.sgetxyhs(HEAL) && (bb || 'P' != strmap[9][10])) {
		MO mo;
		//如果玩家踏进新的地牢(具体位置：&strmap[9][1])(!b)，b设为真，并重置怪物生成和地牢生成(vism无时BOSS战(+))
		if (!b && (&strmap[9][1] == cp || &strmap[8][1] == cp)) {
			b = 1;
			strmap[9][0] = '*';
			for (i = 1; i < 10; i++) {
				for (ch = 1; ch < 10; ch++) {
					'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
				}
			}
			switch (vism.front().id) {//地牢的生成
			case 0:
				for (ch = 3; ch < 8; ch++) {
					for (i = 3; i < 8; i++) {
						strmap[ch][i] = '*';
					}
				}
				{
					int arr[10] = { 1, 2, 5, 2, 7, 1, 1, 8, 6, 7 };
					for (i = 0; i < 10; i += 2) {
						strmap[arr[i]][arr[i + 1]] = (8 != i ? '*' : strmap[7][7] = ' ');
					}
				}
				break;
			case 1:
				strmap[2][8] = '*';
				break;
			case 2:
				strmap[4][6] = '*';
				strmap[7][7] = '*';
				break;
			case 3:
			{
				char* cparr[6] = { &strmap[2][4], &strmap[4][1], &strmap[4][7], &strmap[8][1], &strmap[8][7], &strmap[6][4] };
				for (ch = 0; ch < 3; ch++) {
					for (i = 0; i < 6; i++) {
						*cparr[i]++ = '*';
					}
				}
			}
			break;
			case 4:
				for (i = 2; i < 9; i += 2) {
					for (ch = 2; ch < 9; ch += 2) {
						strmap[i][ch] = '*';
					}
				}
				{
					int arr[12] = { 8, 5, 6, 3, 6, 7, 4, 5, 8, 9, 4, 1 };
					for (i = 0; i < 12; i += 2) {
						strmap[arr[i]][arr[i + 1]] = '*';
					}
				}
				break;
			case 6:
			{
				int temparr[5] = { 8,5,2,4,9 };//8,5 5,2 2,4 4,9
				for (ch = 2; ch < 9; ch++) {
					strmap[ch][ch] = '*';
					strmap[ch][10 - ch] = '*';
					if (ch < 6) {
						strmap[temparr[ch - 2]][temparr[ch - 1]] = '*';
					}
				}
				break;
			}
			case 7:
				for (ch = 1; ch < 4; ch++) {
					strmap[2][ch] = '*';
					strmap[5][ch + 3] = '*';
					strmap[8][ch + 6] = '*';
				}
				break;
			case 8:
				for (ch = 2; ch < 5; ch++) {
					strmap[7][ch] = '*';
					strmap[7][ch + 4] = '*';
					strmap[4][ch + 1] = '*';
				}
				break;
			case 9:
				strmap[4][5] = '*';
				strmap[7][5] = '*';
				break;
			case 10:
				for (i = 1; i < 10; i++) {
					for (ch = 1; ch < 10; ch++) {
						'#' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				for (i = 2; i <= 8; i += 6) {
					for (ch = 4; ch < 7; ch++) {
						strmap[i][ch] = '+';
						strmap[ch][i] = '+';
					}
					for (ch = 2; ch <= 8; ch++) {
						'+' != strmap[i][ch] && (strmap[i][ch] = '-');
						'+' != strmap[ch][i] && (strmap[ch][i] = '-');
					}
				}
				for (i = 2; i <= 8; i++) {
					for (ch = 2; ch <= 8; ch++) {
						'-' == strmap[i][ch] && (strmap[i][ch] = '*');
						'+' == strmap[i][ch] && (strmap[i][ch] = ' ');
					}
				}
				strmap[5][1] = '*';
				strmap[5][9] = '*';
				break;
			default:
				break;
			}
			memcpy(strmapr, strmap, sizeof strmap);
			strmapr[9][1] = ' ';
			for (ch = 0; vism.front().vmp[ch] != vism.front().vmp.back(); ch++) {
				if ('X' == vism.front().vmp[ch]->getm()) {
					((MX*)vism.front().vmp[ch])->exset(strmap);
				}
			}
			if ('X' == vism.front().vmp[ch]->getm()) {
				((MX*)vism.front().vmp[ch])->exset(strmap);
			}
			for (ch = 0; vism.front().vmp.size() != ch; ch++) {
				*vism.front().vmp[ch]->getcp() = vism.front().vmp[ch]->getm();
			}
		}
		p.sgetxyhs(X) = (cp - &strmap[0][0]) / 11;
		p.sgetxyhs(Y) = (cp - &strmap[0][0]) % 11;
		mo.set_s_pxy(p.sgetxyhs(X), p.sgetxyhs(Y));
		p.shootmove(&strmap, 0);//子弹删
		if (vism.size()) {//开始前画“#”以用来告知人们地牢的变化
			for (vector<draw>::iterator it = vmd[5 - vism.size()].begin(); &strmap[9][0] == cp && vmd[5 - vism.size()].back().iwalk + 1; it++) {
				for (char* drawcp = &strmap[it->ix][it->iy]; it->iwalk + 1; drawcp += (1 + 10 * it->brd), it->iwalk--) {
					*drawcp = '#';
				}
			}
		}
		p.printmap(strmap, ba, iunmd);//显示游戏的游玩界面
		ba = 1;
		cin >> ch;
		rewind(stdin);
		'*' != *cp && (*cp = ' ');
		//玩弹怪依次动
		//玩动
		switch (ch) {
		case 'a':
			p.left_move(&cp);
			break;
		case 'd':
			p.right_move(&cp);
			break;
		case 'w':
			p.jump(&cp);
			break;
		case 'z':
			p.shoot(ishoot, &cp);
		default:
			break;
		}
		p.upOrDown(&cp);
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		//有怪物使你扣血
		ishoot > 0 && ishoot--;
		if (' ' != strmap[9][10]) {//怪物死
			sort(vism.front().vmp.begin(), vism.front().vmp.end(), cmpm());//对怪物血量进行升序排序
			while (!vism.front().vmp.empty() && vism.front().vmp.front()->getheal() < 1) {
				if (-1 == vism.front().vmp.front()->getheal()) {
					int ir = 0;
					//把怪物“o”转换成其他怪物
					switch (bc ? 2 : ir = rand() % 4) {
					case 0:
						mpv.push_back(new Mand());
						break;
					case 1:
						mpv.push_back(new MUD());
						break;
					case 2:
						mpv.push_back(new MO());
						break;
					case 3:
						mpv.push_back(new MX());
						break;
					default:
						break;
					}
					vism.front().vmp.push_back(mpv.back());
					char* cpa = NULL;
					int mx = 0;
					int my = 0;
					const int arr[8] = { -12, -11, -10, -1, 1, 10, 11, 12 };
					int isummon = 0;
					while (255 != isummon && (!cpa || ' ' != *cpa || ('X' == mpv.back()->getm() && (cpa == &strmap[9][1] || '@' == *cpa || '@' == *(cpa - 1) || '@' == *(cpa + 1) || cpa == cp || '*' == *(cpa - 1) || '*' == *(cpa + 1) || 'X' == *(cpa - 1) || 'X' == *cpa || 'X' == *(cpa + 1))))) {
						int ira = rand() % (cpa = vism.front().vmp.front()->getcp(), 8);
						(isummon >> ira & 1) || (isummon += (1 << ira));
						int imx = (vism.front().vmp.front()->getcp() - &strmap[0][0]) / 11;
						int imy = (vism.front().vmp.front()->getcp() - &strmap[0][0]) % 11;
						bool boolarr[8] = { (imx || imy), !!imx, (imx || 10 != imy), !!imy, 10 != imy, (10 != imx || imy), 10 != imx, (imx || 10 != imy) };
						boolarr[ira] && (cpa += arr[ira]);
					}
					if (255 != isummon) {
						mx = (cpa - &strmap[0][0]) / 11;
						my = (cpa - &strmap[0][0]) % 11;
						switch (bc ? (bc = 0, 2) : ir) {
						case 0:
							vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, NULL, NULL, NULL, 0, 0, rand() % 2);//怪物“&”
							break;
						case 1:
							vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 2, NULL, NULL, NULL, 0, 0, rand() % 2, rand() % 2);//怪物“^”
							break;
						case 2:
							vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 3, &em, NULL, NULL, mx, my);//怪物“O”
							break;
						case 3:
							vism.front().vmp.back()->set(p.sgetxyhs(), &cpa, 5, NULL, &cp, &strmap);//怪物“X”
							break;
						default:
							break;
						}
					}
					else {
						vism.front().vmp.pop_back();
					}
				}
				'*' != *vism.front().vmp.back()->getcp() && (*vism.front().vmp.back()->getcp() = vism.front().vmp.back()->getm());
				if ('X' == vism.front().vmp.back()->getm()) {
					((MX*)vism.front().vmp.back())->exset(strmapr);
				}
				//如果该地只有一个怪物，那么设怪物所在的位置为空格
				vector<moster*>::iterator it = vism.front().vmp.begin() + 1;
				for (; it != vism.front().vmp.end(); it++) {
					if (vism.front().vmp.front()->getcp() == (*it)->getcp()) {
						break;
					}
				}
				'*' != *vism.front().vmp.front()->getcp() && it == vism.front().vmp.end() && (*vism.front().vmp.front()->getcp() = ' ');
				'X' == vism.front().vmp.front()->getm() && (*vism.front().vmp.front()->getcp() = ((MX*)vism.front().vmp.front())->getm(0));
				'*' != *vism.front().vmp.front()->getcp() && (*vism.front().vmp.front()->getcp() = ' ');
				if ('+' == vism.front().vmp.front()->getm()) {
					for_each(vism.front().vmp.begin(), vism.front().vmp.end(), setMempty);
					vism.front().vmp.clear();
					bb = 0;
				} 
				bb && (vism.front().vmp.erase(vism.front().vmp.begin()), 0);//删除怪物
			}
		}
		p.shootmove(&strmap, 1);//子弹动
		if (b && '*' == strmap[9][10]) {//怪物动
			vector<moster*>::iterator vfvp = vism.front().vmp.begin();
			while (!vism.front().vmp.empty() && '+' != (*vfvp)->getm()) {
				if (vism.front().vmp.end() == ++vfvp) {
					break;
				}
			}
			if (1 == vism.size() && bb && (!bosswait || (bosswait--, 0))) {
				char* setcp = &strmap[5][5];
				vo.push_back(new M_o());
				vism.front().vmp.push_back(vo.back());
				vism.front().vmp.back()->set(p.sgetxyhs(), &setcp, 5);
				bosswait = 15;
			}//**会变**
			for (vector<moster*>::iterator it = vism.front().vmp.begin(); vism.front().vmp.end() != it/* || ((*it)->getcp() = tempcp, 0)*/; it++) {
				(*it)->hunt();
				(*it)->mosterdo();
				(*it)->hunt();
			}
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				-2 >= it->iy && it->iy++;
			}
			for_each(vism.front().vmp.begin(), vism.front().vmp.end(), MShow);
		}
		(iunmd || ' ' == *cp || '@' == *cp) || cout << (p.sgetxyhs(HEAL)--, iunmd = 2, "\a");
		'*' != *cp && (*cp = 'P');
		system("cls");//清屏
		//如果vism的第0项vmp或者vism为空，那么开门，并头删
		if ((vism.empty() || vism.front().vmp.empty()) && '*' == strmap[9][10]) {
			strmap[9][10] = ' ';
			vism.erase(vism.begin());
		}
		//如果进门，那么重置地牢('*'  -->  ' ')，并把b设为假
		if (bb && 'P' == strmap[9][10]) {
			b = 0;
			for (vector<trir>::iterator it = p.sgetxyhs()->begin(); p.sgetxyhs()->end() != it; it++) {
				'*' != *it->cp && (*it->cp = ' ');
			}
			p.sgetxyhs()->clear();
			for (i = 0; i < 10; i++) {
				p.printmap(&strmap, ba, i, iunmd);
				!i && (strmap[9][0] = ' ');
				Sleep(100);
				system("cls");
			}
			//下一地牢初始化
			////( <- 分界 )
			strmap[9][10] = '*';
			strmap[9][0] = 'P';
			////
			p.printmap(&strmap, ba, 11, iunmd);
			Sleep(100);
			system("cls");
			bool temparrb[8] = { 1, 1, !(rand() % 2), 1, !(rand() % 4), !(rand() % 2), 0, 0};
			if (1 != vism.size()) {//恢复血量
				temparrb[d * 2] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
		    }
		    else {
				temparrb[d * 2 + 1] && temparra[d] > p.sgetxyhs(HEAL) && (p.sgetxyhs(HEAL)++, ba = 0);
			}
			//并把cp设为&strmap[9][0]
			cp = &strmap[9][0];
		}
		iunmd && iunmd--;
	}
	char tempstrb[6] = "C2AA7";//胜利
	str[7] = tempstrb[(!bb) * (d + 1)];
	system(str);
	switch ((!bb) * (d + 1)) {//告知你胜利的方式
	case 0:
		cout << "很遗憾，你输了" << endl;
		break;
	case 1:
	case 2:
		cout << "恭喜你，你赢了" << endl;
		break;
	case 3:
		cout << "@------------------@" << endl;
		cout << "|                  |" << endl;
		cout << "|  恭喜你，你赢了  |" << endl;
		cout << "|                  |" << endl;
		cout << "@------------------@" << endl;
		break;
	case 4:
		for (i = 0; i < 15; i++) {
			system("cls");
			win(i);
			Sleep(10);
		}
		for (i = 0; i < 27; i++) {
			strcat(tempstr, tempstra[i % 9]);
			system(tempstr);
			tempstr[7] = 0;
			Sleep(100);
		}
		system("color 0A");
		break;
	default:
		break;
	}
	for_each(mpv.begin(), mpv.end(), del);//释放mpv和vo里new出来的怪物对象
	for_each(vo.begin(), vo.end(), delvo);//释放mpv和vo里new出来的怪物对象
	return 0;
}
*///无用注释已删除^
/*
//mylist.hpp
#pragma once
#include <iostream>
#include <stack>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
		this->ic = 0;
	}
	void push_back(T t) {
		node* newnode = new node;
		node** findnode = &head;
		newnode->set(t, nullptr);
		while (nullptr != (*findnode)->next) {
			findnode = &(*findnode)->next;
		}
		(*findnode)->next = newnode;
		ic++;
	}
	int indexfind(T t) {
		node* findnode = head;
		int index = 0;
		while (nullptr != findnode->next) {
			findnode = findnode->next;
			if (t == findnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.head;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		head = new node;
		head->set();
		if (sizeof *tarr) {
			const T* tp = tarr;
			for (int i = 0; i < has; i++) {
				push_back(*tp++);
			}
		}
	}
	void insert(T t, int i) {
		if (ic && ic > i && i >= 0) {
			node** findnode = &head;
			for (; i; i--) {
				findnode = &(*findnode)->next;
			}
			node* newnode = new node;
			newnode->set(t, (*findnode)->next);
			(*findnode)->next = newnode;
			ic++;
		}
	}
	void del_back() {
		if (ic) {
			node** prenode = &head;
			while (nullptr != (*prenode)->next->next) {
				prenode = &((*prenode)->next);
			}
			node** delnode = &((*prenode)->next);
			(*prenode)->next = nullptr;
			delete *delnode;
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	void del_index(int index) {
		if (ic > index && index >= 0) {
			node** prenode = &head;
			for (; index > 0; index--) {
				prenode = &(*prenode)->next;
			}
			node** delnode = &((*prenode)->next);
			node* nextnode = (*delnode)->next;
			delete* delnode;
			(*prenode)->next = nextnode;
			ic--;
		}
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
	void myreverse() {
		if (nullptr != head) {
			int newc = ic;
			stack<node*>s;
			node* snode = head;
			while (nullptr != snode->next) {
				s.push(snode->next);
				snode = snode->next;
			}
			this->clear();
			head->next = s.top();
			s.pop();
			node** addnode = &(head->next);
			while (s.size()) {
				(*addnode)->next = s.top();
				addnode = &((*addnode)->next);
				s.pop();
			}
			(*addnode)->next = nullptr;
			ic = newc;
		}
	}
	T& operator[](int i) {
		if (i >= 0 && i < ic) {
			node* findnode = head->next;
			for (; i; i--) {
				findnode = findnode->next;
			}
			return findnode->t;
		}
		else {
			return head->t;
		}
	}
	void printlist(void (*printfun)(T item, bool b)) {
		if (ic) {
			node* printnode = head;
			while (nullptr != printnode->next) {
				printnode = printnode->next;
				printfun(printnode->t, nullptr != printnode->next);
			}
		}
	}
};
*///已为单向链表的无参构造函数进行优化^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <stack>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf, node* rightf) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
		this->ic = 0;
	}
	void push_back(T t) {
		
	}
	int indexfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.head;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		head = new node;
		head->set();
		
	}
	void insert(T t) {
		
	}
	void del_back() {
		
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T& at(int i) {
		
	}
	T& operator[](int i) {
		
	}
	void printlist(void (*printfun)(T item, bool b)) {
		
	}
};
*///已新建mybintree.hpp文件^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <stack>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf, node* rightf) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
		this->ic = 0;
	}
	void push_back(T t) {
		
	}
	int indexfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.head;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		head = new node;
		head->set();
		
	}
	void insert(T t) {
		
	}
	void del_back() {
		
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		
	}
	T operator[](int i) {
		
	}
	void printlist(void (*printfun)(T item, bool b)) {
		
	}
	T max() {

	}
	T min() {

	}
};
*///新建了两个方法^
/*
//mybintree.hpp
#pragma once
#include <iostream>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf, node* rightf) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
		this->ic = 0;
	}
	void push_back(T t) {
		
	}
	int indexfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.head;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->push_back(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		head = new node;
		head->set();
		
	}
	void insert(T t) {
		
	}
	void del_back() {
		
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {

	}
	T min() {

	}
};
*///更改了某个成员方法的名字^
/*
//mybintree.hpp
#pragma once
#include <iostream>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
		}
	}
	int indexfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del() {
		
	}
	void clear() {
		while (ic) {
			del();
		}
	}
	~mylist() {
		clear();
		del root;
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {

	}
	T min() {

	}
};
*///已为二叉树的insert方法做实现^
/*
//mybintree.hpp
#pragma once
#include <iostream>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int indexfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {

	}
	T min() {

	}
}
*///已实现mybintree二叉树的del_back方法^
/*
//mybintree.hpp
#pragma once
#include <iostream>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int indexfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
            ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {

	}
	T min() {

	}
}
*///已修正mybintree二叉树的del_back方法^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int indexfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {

	}
	T min() {

	}
}
*///已导入queue类文件^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int indexfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {

	}
}
*///已实现mybintree二叉树的max方法^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int indexfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///已实现mybintree二叉树的min方法^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int itemfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
		}
		else if (ic){
			//...
		}
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///已新建mybintree二叉树的del_front方法^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int itemfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
   			ic--;
		}
		else if (ic){
			node** findnode = root->right;
			if (nullptr == findnode) {
				node** leftnode = root->left;
				delete root;
				root = *leftnode;
			}
			else if(nullptr == (*findnode)->left){
				root->t = (*findnode)->t;
				delete* findnode;
				root->right = nullptr;
			}
			else {
				while (nullptr != (*findnode)->left->left) {
					findnode = &(*findnode)->left;
				}
				root->t = (*findnode)->left->t;
				delete (*findnode)->left;
				(*findnode)->left = nullptr;
			}
   			ic--;
		}
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///二叉树mybintree的del_front方法已完成实现^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	node** get_node(int index) {

	}
	void del_node(node** node) {

	}
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int itemfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
            ic--;
		}
		else if (ic){
			node** findnode = root->right;
			if (nullptr == findnode) {
				node** leftnode = root->left;
				delete root;
				root = *leftnode;
			}
			else if(nullptr == (*findnode)->left){
				root->t = (*findnode)->t;
				delete* findnode;
				root->right = nullptr;
			}
			else {
				while (nullptr != (*findnode)->left->left) {
					findnode = &(*findnode)->left;
				}
				root->t = (*findnode)->left->t;
				delete (*findnode)->left;
				(*findnode)->left = nullptr;
			}
            ic--;
		}
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///已在mybintree二叉树类的私有域中新建了两个方法^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	node** findnodef;
	void set_findnodef(int index, int noden = 0, node** findnode = &root) {
		if (ic >= 0 && index < ic) {
			if (nullptr != (*findnode)->left) {
				get_node(index, noden, &(*findnode)->left);
				noden = nodenf;
			}
			if (index == noden++) {
				fidnndoef = findnode;
				return;
			}
			nodenf = noden;
			if (nullptr != (*findnode)->right) {
				get_node(index, noden, &(*findnode)->right);
				noden = nodenf;
			}
		}
	}
	void del_node(node** node) {

	}
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int itemfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
			ic--;
		}
		else if (ic){
			node** findnode = root->right;
			if (nullptr == findnode) {
				node** leftnode = root->left;
				delete root;
				root = *leftnode;
			}
			else if(nullptr == (*findnode)->left){
				root->t = (*findnode)->t;
				delete* findnode;
				root->right = nullptr;
			}
			else {
				while (nullptr != (*findnode)->left->left) {
					findnode = &(*findnode)->left;
				}
				root->t = (*findnode)->left->t;
				delete (*findnode)->left;
				(*findnode)->left = nullptr;
			}
			ic--;
		}
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///mybintree二叉树的set_findnodef方法已构造完成^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	node** findnodef;
	void set_findnodef(int index, int noden = 0, node** findnode = &root) {
		if (ic >= 0 && index < ic) {
			if (nullptr != (*findnode)->left) {
				get_node(index, noden, &(*findnode)->left);
				noden = nodenf;
			}
			if (index == noden++) {
				fidnndoef = findnode;
				return;
			}
			nodenf = noden;
			if (nullptr != (*findnode)->right) {
				get_node(index, noden, &(*findnode)->right);
				noden = nodenf;
			}
		}
	}
	void del_node(node** delnode) {
		node** findnode = delnode->right;
		if (nullptr == findnode) {
			node** leftnode = (*delnode)->left;
			delete *delnode;
			*delnode = *leftnode;
		}
		else if (nullptr == (*findnode)->left) {
			(*delnode)->t = (*findnode)->t;
			delete *findnode;
			(*delnode)->right = nullptr;
		}
		else {
			while (nullptr != (*findnode)->left->left) {
				findnode = &(*findnode)->left;
			}
			(*delnode)->t = (*findnode)->left->t;
			delete (*findnode)->left;
			(*findnode)->left = nullptr;
		}
		ic--;
	}
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int itemfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
			ic--;
		}
		else if (ic){
			node** findnode = root->right;
			if (nullptr == findnode) {
				node** leftnode = root->left;
				delete root;
				root = *leftnode;
			}
			else if(nullptr == (*findnode)->left){
				root->t = (*findnode)->t;
				delete* findnode;
				root->right = nullptr;
			}
			else {
				while (nullptr != (*findnode)->left->left) {
					findnode = &(*findnode)->left;
				}
				root->t = (*findnode)->left->t;
				delete (*findnode)->left;
				(*findnode)->left = nullptr;
			}
			ic--;
		}
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///mybintree二叉树的del_node方法已构造完成^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	node** returnnode;
	node** get_node(int index, int noden = 0, node** findtree = nullptr) {
		if (ic >= 0 && index < ic && nullptr != findtree) {
			if (nullptr != (*findtree)->left) {
				if (nullptr != (returnnode = get_node(index, noden, &(*findtree)->left))) {
					return returnnode;
				}
				noden = nodenf;
			}
			if (index == noden++) {
				return findtree;
			}
			nodenf = noden;
			if (nullptr != (*findtree)->right) {
				if (nullptr != (returnnode = get_node(index, noden, &(*findtree)->left))) {
					return returnnode;
				}
				noden = nodenf;
			}
		}
		return nullptr;
	}
	void del_node(node** delnode) {
		node** findnode = delnode->right;
		if (nullptr == findnode) {
			node** leftnode = (*delnode)->left;
			delete *delnode;
			*delnode = *leftnode;
		}
		else if (nullptr == (*findnode)->left) {
			(*delnode)->t = (*findnode)->t;
			delete *findnode;
			(*delnode)->right = nullptr;
		}
		else {
			while (nullptr != (*findnode)->left->left) {
				findnode = &(*findnode)->left;
			}
			(*delnode)->t = (*findnode)->left->t;
			delete (*findnode)->left;
			(*findnode)->left = nullptr;
		}
		ic--;
	}
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int itemfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
			ic--;
		}
		else if (ic){
			node** findnode = root->right;
			if (nullptr == findnode) {
				node** leftnode = root->left;
				delete root;
				root = *leftnode;
			}
			else if(nullptr == (*findnode)->left){
				root->t = (*findnode)->t;
				delete* findnode;
				root->right = nullptr;
			}
			else {
				while (nullptr != (*findnode)->left->left) {
					findnode = &(*findnode)->left;
				}
				root->t = (*findnode)->left->t;
				delete (*findnode)->left;
				(*findnode)->left = nullptr;
			}
			ic--;
		}
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///已优化mybintree二叉树的get_node方法^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	node** returnnode;
	node** get_node(int index, node** findtree, int noden = 0) {
		if (ic >= 0 && index < ic && nullptr != findtree) {
			if (nullptr != (*findtree)->left) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->left, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
			if (index == noden++) {
				return findtree;
			}
			nodenf = noden;
			if (nullptr != (*findtree)->right) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->right, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
		}
		return nullptr;
	}
	void del_node(node** delnode) {
		node** findnode = delnode->right;
		if (nullptr == findnode) {
			node** leftnode = (*delnode)->left;
			delete *delnode;
			*delnode = *leftnode;
		}
		else if (nullptr == (*findnode)->left) {
			(*delnode)->t = (*findnode)->t;
			delete *findnode;
			(*delnode)->right = nullptr;
		}
		else {
			while (nullptr != (*findnode)->left->left) {
				findnode = &(*findnode)->left;
			}
			(*delnode)->t = (*findnode)->left->t;
			delete (*findnode)->left;
			(*findnode)->left = nullptr;
		}
		ic--;
	}
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int itemfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
			ic--;
		}
		else if (ic){
			node** findnode = root->right;
			if (nullptr == findnode) {
				node** leftnode = root->left;
				delete root;
				root = *leftnode;
			}
			else if(nullptr == (*findnode)->left){
				root->t = (*findnode)->t;
				delete* findnode;
				root->right = nullptr;
			}
			else {
				while (nullptr != (*findnode)->left->left) {
					findnode = &(*findnode)->left;
				}
				root->t = (*findnode)->left->t;
				delete (*findnode)->left;
				(*findnode)->left = nullptr;
			}
			ic--;
		}
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		return (*get_node(i, &root))->t;
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///已构建出mybintree二叉树的at方法^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	node** returnnode;
	node** get_node(int index, node** findtree, int noden = 0) {
		if (ic >= 0 && index < ic && nullptr != findtree) {
			if (nullptr != (*findtree)->left) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->left, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
			if (index == noden++) {
				return findtree;
			}
			nodenf = noden;
			if (nullptr != (*findtree)->right) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->right, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
		}
		return nullptr;
	}
	void del_node(node** delnode) {
		node** findnode = (*delnode)->right;
		if (nullptr == findnode) {
			node** leftnode = (*delnode)->left;
			delete *delnode;
			*delnode = *leftnode;
		}
		else if (nullptr == (*findnode)->left) {
			(*delnode)->t = (*findnode)->t;
			delete *findnode;
			(*delnode)->right = nullptr;
		}
		else {
			while (nullptr != (*findnode)->left->left) {
				findnode = &(*findnode)->left;
			}
			(*delnode)->t = (*findnode)->left->t;
			delete (*findnode)->left;
			(*findnode)->left = nullptr;
		}
		ic--;
	}
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int itemfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
			ic--;
		}
		else if (ic){
			node** findnode = root->right;
			if (nullptr == findnode) {
				node** leftnode = root->left;
				delete root;
				root = *leftnode;
			}
			else if(nullptr == (*findnode)->left){
				root->t = (*findnode)->t;
				delete* findnode;
				root->right = nullptr;
			}
			else {
				while (nullptr != (*findnode)->left->left) {
					findnode = &(*findnode)->left;
				}
				root->t = (*findnode)->left->t;
				delete (*findnode)->left;
				(*findnode)->left = nullptr;
			}
			ic--;
		}
	}
	void del_index(int index) {
		
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		return (*get_node(i, &root))->t;
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///已修正mybintree二叉树中del_node方法的一处错误^
/*
#include <iostream>
using namespace std;
int main() {
	const float farr[7] = { 0.64f, 0.32f, 0.16f, 0.08f, 0.04f, 0.02f, 0.01f };
	const char* strs[8] = {"Common", "Unusual", "Rare", "Epic", "Legendary", "Mythic", "Ultra", "Super"};
	int icraft = 1;
	float f = 0.0;
	float fstart = 0.0;
	for (int i = 0; i < 7; i++) {
		cout << "至少";
		f = 1 - farr[i];
		fstart = f;
		icraft = 1;
		while (f >= 0.5) {
			f *= fstart;
			icraft++;
		}
		printf("%d张%s才能在运气为%.1f%c的情况下合出一张%s来\n", icraft * 4 + 1, strs[i], (1 - f) * 100, '%', strs[i + 1]);
	}
	return 0;
}
*///florr.io合卡计算器^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	node** returnnode;
	node** get_node(int index, node** findtree, int noden = 0) {
		if (ic >= 0 && index < ic && nullptr != findtree) {
			if (nullptr != (*findtree)->left) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->left, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
			if (index == noden++) {
				return findtree;
			}
			nodenf = noden;
			if (nullptr != (*findtree)->right) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->right, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
		}
		return nullptr;
	}
	void del_node(node** delnode) {
		node** findnode = (*delnode)->right;
		if (nullptr == findnode) {
			node** leftnode = (*delnode)->left;
			delete *delnode;
			*delnode = *leftnode;
		}
		else if (nullptr == (*findnode)->left) {
			(*delnode)->t = (*findnode)->t;
			delete *findnode;
			(*delnode)->right = nullptr;
		}
		else {
			while (nullptr != (*findnode)->left->left) {
				findnode = &(*findnode)->left;
			}
			(*delnode)->t = (*findnode)->left->t;
			delete (*findnode)->left;
			(*findnode)->left = nullptr;
		}
		ic--;
	}
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int itemfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
			ic--;
		}
		else if (ic){
			node** findnode = root->right;
			if (nullptr == findnode) {
				node** leftnode = root->left;
				delete root;
				root = *leftnode;
			}
			else if(nullptr == (*findnode)->left){
				root->t = (*findnode)->t;
				delete* findnode;
				root->right = nullptr;
			}
			else {
				while (nullptr != (*findnode)->left->left) {
					findnode = &(*findnode)->left;
				}
				root->t = (*findnode)->left->t;
				delete (*findnode)->left;
				(*findnode)->left = nullptr;
			}
			ic--;
		}
	}
	void del_index(int index) {
		del_node(get_node(index, &root));
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		return (*get_node(i, &root))->t;
	}
	T operator[](int i) {
		
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///mybintree二叉树的del_index方法已构建完毕^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	node** returnnode;
	node** get_node(int index, node** findtree, int noden = 0) {
		if (ic >= 0 && index < ic && nullptr != findtree) {
			if (nullptr != (*findtree)->left) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->left, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
			if (index == noden++) {
				return findtree;
			}
			nodenf = noden;
			if (nullptr != (*findtree)->right) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->right, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
		}
		return nullptr;
	}
	void del_node(node** delnode) {
		node** findnode = (*delnode)->right;
		if (nullptr == findnode) {
			node** leftnode = (*delnode)->left;
			delete *delnode;
			*delnode = *leftnode;
		}
		else if (nullptr == (*findnode)->left) {
			(*delnode)->t = (*findnode)->t;
			delete *findnode;
			(*delnode)->right = nullptr;
		}
		else {
			while (nullptr != (*findnode)->left->left) {
				findnode = &(*findnode)->left;
			}
			(*delnode)->t = (*findnode)->left->t;
			delete (*findnode)->left;
			(*findnode)->left = nullptr;
		}
		ic--;
	}
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int itemfind(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
			ic--;
		}
		else if (ic){
			node** findnode = root->right;
			if (nullptr == findnode) {
				node** leftnode = root->left;
				delete root;
				root = *leftnode;
			}
			else if(nullptr == (*findnode)->left){
				root->t = (*findnode)->t;
				delete* findnode;
				root->right = nullptr;
			}
			else {
				while (nullptr != (*findnode)->left->left) {
					findnode = &(*findnode)->left;
				}
				root->t = (*findnode)->left->t;
				delete (*findnode)->left;
				(*findnode)->left = nullptr;
			}
			ic--;
		}
	}
	void del_index(int index) {
		del_node(get_node(index, &root));
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		return (*get_node(i, &root))->t;
	}
	T operator[](int i) {
		return at(i);
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///mybintree二叉树的重载中括号运算符的运算逻辑已构建完成^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	node** returnnode;
	node** get_node(int index, node** findtree, int noden = 0) {
		if (ic >= 0 && index < ic && nullptr != findtree) {
			if (nullptr != (*findtree)->left) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->left, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
			if (index == noden++) {
				return findtree;
			}
			nodenf = noden;
			if (nullptr != (*findtree)->right) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->right, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
		}
		return nullptr;
	}
	void del_node(node** delnode) {
		node** findnode = (*delnode)->right;
		if (nullptr == findnode) {
			node** leftnode = (*delnode)->left;
			delete *delnode;
			*delnode = *leftnode;
		}
		else if (nullptr == (*findnode)->left) {
			(*delnode)->t = (*findnode)->t;
			delete *findnode;
			(*delnode)->right = nullptr;
		}
		else {
			while (nullptr != (*findnode)->left->left) {
				findnode = &(*findnode)->left;
			}
			(*delnode)->t = (*findnode)->left->t;
			delete (*findnode)->left;
			(*findnode)->left = nullptr;
		}
		ic--;
	}
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int itemfind(T t) {
		for (int i = 0; i < ic; i++) {
			if ((*get_node(i, &root))->t == t) {
				return i;
			}
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
			ic--;
		}
		else if (ic){
			node** findnode = root->right;
			if (nullptr == findnode) {
				node** leftnode = root->left;
				delete root;
				root = *leftnode;
			}
			else if(nullptr == (*findnode)->left){
				root->t = (*findnode)->t;
				delete* findnode;
				root->right = nullptr;
			}
			else {
				while (nullptr != (*findnode)->left->left) {
					findnode = &(*findnode)->left;
				}
				root->t = (*findnode)->left->t;
				delete (*findnode)->left;
				(*findnode)->left = nullptr;
			}
			ic--;
		}
	}
	void del_index(int index) {
		del_node(get_node(index, &root));
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		return (*get_node(i, &root))->t;
	}
	T operator[](int i) {
		return at(i);
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///mybintree二叉树的itemfind方法已构造完毕^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	node** returnnode;
	node** get_node(int index, node** findtree, int noden = 0) {
		if (ic >= 0 && index < ic && nullptr != findtree) {
			if (nullptr != (*findtree)->left) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->left, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
			if (index == noden++) {
				return findtree;
			}
			nodenf = noden;
			if (nullptr != (*findtree)->right) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->right, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
		}
		return nullptr;
	}
	void del_node(node** delnode) {
		node** findnode = (*delnode)->right;
		if (nullptr == findnode) {
			node** leftnode = (*delnode)->left;
			delete *delnode;
			*delnode = *leftnode;
		}
		else if (nullptr == (*findnode)->left) {
			(*delnode)->t = (*findnode)->t;
			delete *findnode;
			(*delnode)->right = nullptr;
		}
		else {
			while (nullptr != (*findnode)->left->left) {
				findnode = &(*findnode)->left;
			}
			(*delnode)->t = (*findnode)->left->t;
			delete (*findnode)->left;
			(*findnode)->left = nullptr;
		}
		ic--;
	}
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int itemfind(T t) {
		for (int i = 0; i < ic; i++) {
			if ((*get_node(i, &root))->t == t) {
				return i;
			}
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
			ic--;
		}
		else if (ic){
			node** findnode = root->right;
			if (nullptr == findnode) {
				node** leftnode = root->left;
				delete root;
				root = *leftnode;
			}
			else if(nullptr == (*findnode)->left){
				root->t = (*findnode)->t;
				delete* findnode;
				root->right = nullptr;
			}
			else {
				while (nullptr != (*findnode)->left->left) {
					findnode = &(*findnode)->left;
				}
				root->t = (*findnode)->left->t;
				delete (*findnode)->left;
				(*findnode)->left = nullptr;
			}
			ic--;
		}
	}
	void del_index(int index) {
		del_node(get_node(index, &root));
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		return (*get_node(i, &root))->t;
	}
	T operator[](int i) {
		return at(i);
	}
	void printtree(void (*printfun)(T item, bool b)) {
		for (int i = 0; i < ic; i++) {
			printfun((*get_node(i, &root))->t, ic - 1 != i);
		}
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///mybintree二叉树的printtree方法已构建完成^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	node** returnnode;
	node** get_node(int index, node** findtree, int noden = 0) {
		if (ic >= 0 && index < ic && nullptr != findtree) {
			if (nullptr != (*findtree)->left) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->left, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
			if (index == noden++) {
				return findtree;
			}
			nodenf = noden;
			if (nullptr != (*findtree)->right) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->right, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
		}
		return nullptr;
	}
	void del_node(node** delnode) {
		node** findnode = (*delnode)->right;
		if (nullptr == findnode) {
			node** leftnode = (*delnode)->left;
			delete *delnode;
			*delnode = *leftnode;
		}
		else if (nullptr == (*findnode)->left) {
			(*delnode)->t = (*findnode)->t;
			delete *findnode;
			(*delnode)->right = nullptr;
		}
		else {
			while (nullptr != (*findnode)->left->left) {
				findnode = &(*findnode)->left;
			}
			(*delnode)->t = (*findnode)->left->t;
			delete (*findnode)->left;
			(*findnode)->left = nullptr;
		}
		ic--;
	}
public:
	mylist() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int itemfind(T t) {
		for (int i = 0; i < ic; i++) {
			if ((*get_node(i, &root))->t == t) {
				return i;
			}
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		root = new node;
		root->set();
		for (int i = 0; i < has; i++) {
			push_back(arr[i]);
		}
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mylist() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
			ic--;
		}
		else if (ic){
			node** findnode = root->right;
			if (nullptr == findnode) {
				node** leftnode = root->left;
				delete root;
				root = *leftnode;
			}
			else if(nullptr == (*findnode)->left){
				root->t = (*findnode)->t;
				delete* findnode;
				root->right = nullptr;
			}
			else {
				while (nullptr != (*findnode)->left->left) {
					findnode = &(*findnode)->left;
				}
				root->t = (*findnode)->left->t;
				delete (*findnode)->left;
				(*findnode)->left = nullptr;
			}
			ic--;
		}
	}
	void del_index(int index) {
		del_node(get_node(index, &root));
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		return (*get_node(i, &root))->t;
	}
	T operator[](int i) {
		return at(i);
	}
	void printtree(void (*printfun)(T item, bool b)) {
		for (int i = 0; i < ic; i++) {
			printfun((*get_node(i, &root))->t, ic - 1 != i);
		}
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///mybintree二叉树的有参构造方法已构建完成^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mybintree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	node** returnnode;
	node** get_node(int index, node** findtree, int noden = 0) {
		if (ic >= 0 && index < ic && nullptr != findtree) {
			if (nullptr != (*findtree)->left) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->left, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
			if (index == noden++) {
				return findtree;
			}
			nodenf = noden;
			if (nullptr != (*findtree)->right) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->right, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
		}
		return nullptr;
	}
	void del_node(node** delnode) {
		node** findnode = (*delnode)->right;
		if (nullptr == findnode) {
			node** leftnode = (*delnode)->left;
			delete *delnode;
			*delnode = *leftnode;
		}
		else if (nullptr == (*findnode)->left) {
			(*delnode)->t = (*findnode)->t;
			delete *findnode;
			(*delnode)->right = nullptr;
		}
		else {
			while (nullptr != (*findnode)->left->left) {
				findnode = &(*findnode)->left;
			}
			(*delnode)->t = (*findnode)->left->t;
			delete (*findnode)->left;
			(*findnode)->left = nullptr;
		}
		ic--;
	}
public:
	mybintree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
	}
	void insert(T t, node** rootf = nullptr) {
		if (ic) {
			(*rootf)->t = t;
		}
		else if (nullptr != rootf){
			if (t > (*rootf)->t) {
				insert(t, &(*rootf)->right);
			}
			else {
				insert(t, &(*rootf)->left);
			}
		}
		else {
			*rootf = new node;
			(*rootf)->set(t);
			ic++;
		}
	}
	int itemfind(T t) {
		for (int i = 0; i < ic; i++) {
			if ((*get_node(i, &root))->t == t) {
				return i;
			}
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mybintree& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mybintree(mybintree& ml) {
		*this = ml;
	}
	mybintree(const T tarr[], int has) {
		root = new node;
		root->set();
		for (int i = 0; i < has; i++) {
			push_back(arr[i]);
		}
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mybintree() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
			ic--;
		}
		else if (ic){
			node** findnode = root->right;
			if (nullptr == findnode) {
				node** leftnode = root->left;
				delete root;
				root = *leftnode;
			}
			else if(nullptr == (*findnode)->left){
				root->t = (*findnode)->t;
				delete* findnode;
				root->right = nullptr;
			}
			else {
				while (nullptr != (*findnode)->left->left) {
					findnode = &(*findnode)->left;
				}
				root->t = (*findnode)->left->t;
				delete (*findnode)->left;
				(*findnode)->left = nullptr;
			}
			ic--;
		}
	}
	void del_index(int index) {
		del_node(get_node(index, &root));
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		return (*get_node(i, &root))->t;
	}
	T operator[](int i) {
		return at(i);
	}
	void printtree(void (*printfun)(T item, bool b)) {
		for (int i = 0; i < ic; i++) {
			printfun((*get_node(i, &root))->t, ic - 1 != i);
		}
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
}
*///mybintree.hpp中的多处“mylist”已改为“mybintree”^
/*
//meiri.cpp
#include <iostream>
#include "mybintree.hpp"
using namespace std;

int main() {
	mybintree<int>m;
	cout << m.IsEmpty() << " " << m.capacity() << endl;
	m.insert(1);
	m.insert(0);
	m.insert(2);
	cout << m.max() << " " << m.min() << " " << m.IsEmpty() << endl;
	return 0;
}
*///mybintree二叉树要测试的第一测试代码^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mybintree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	node** returnnode;
	node** get_node(int index, node** findtree, int noden = 0) {
		if (ic >= 0 && index < ic && nullptr != findtree) {
			if (nullptr != (*findtree)->left) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->left, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
			if (index == noden++) {
				return findtree;
			}
			nodenf = noden;
			if (nullptr != (*findtree)->right) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->right, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
		}
		return nullptr;
	}
	void del_node(node** delnode) {
		node** findnode = (*delnode)->right;
		if (nullptr == findnode) {
			node** leftnode = (*delnode)->left;
			delete *delnode;
			*delnode = *leftnode;
		}
		else if (nullptr == (*findnode)->left) {
			(*delnode)->t = (*findnode)->t;
			delete *findnode;
			(*delnode)->right = nullptr;
		}
		else {
			while (nullptr != (*findnode)->left->left) {
				findnode = &(*findnode)->left;
			}
			(*delnode)->t = (*findnode)->left->t;
			delete (*findnode)->left;
			(*findnode)->left = nullptr;
		}
		ic--;
	}
	void insert(T t, node** rootf) {
		if (!ic) {
			root->t = t;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node;
					(*rootf)->right->set(t);
				}
				else {
					insert(t, &(*rootf)->right);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node;
					(*rootf)->left->set(t);
				}
				else {
					insert(t, &(*rootf)->left);
				}
			}
		}
		ic++;
	}
public:
	mybintree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int itemfind(T t) {
		for (int i = 0; i < ic; i++) {
			if ((*get_node(i, &root))->t == t) {
				return i;
			}
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mybintree& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mybintree(mybintree& ml) {
		*this = ml;
	}
	mybintree(const T tarr[], int has) {
		root = new node;
		root->set();
		for (int i = 0; i < has; i++) {
			insert(tarr[i]);
		}
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mybintree() {
		clear();
		delete root;
	}
	void del_front(int index) {
		if (1 == ic) {
			root->t = NULL;
			ic--;
		}
		else if (ic){
			node** findnode = root->right;
			if (nullptr == findnode) {
				node** leftnode = root->left;
				delete root;
				root = *leftnode;
			}
			else if(nullptr == (*findnode)->left){
				root->t = (*findnode)->t;
				delete* findnode;
				root->right = nullptr;
			}
			else {
				while (nullptr != (*findnode)->left->left) {
					findnode = &(*findnode)->left;
				}
				root->t = (*findnode)->left->t;
				delete (*findnode)->left;
				(*findnode)->left = nullptr;
			}
			ic--;
		}
	}
	void del_index(int index) {
		del_node(get_node(index, &root));
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		return (*get_node(i, &root))->t;
	}
	T operator[](int i) {
		return at(i);
	}
	void printtree(void (*printfun)(T item, bool b)) {
		for (int i = 0; i < ic; i++) {
			printfun((*get_node(i, &root))->t, ic - 1 != i);
		}
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///修正之后的mybintree二叉树^
/*
//meiri.cpp
#include <iostream>
#include "mybintree.hpp"
using namespace std;

int main() {
	mybintree<int>m;
	cout << m.IsEmpty() << " " << m.capacity() << endl;
	m.insert(1);
	m.insert(0);
	m.insert(2);
	m.insert(3);
	m.del_back();
	m.del_front();
	m.del_index(0);
	cout << m.IsEmpty() << " " << m.capacity() << " " << m[0] << " " << m[1] << endl;
	return 0;
}
*///mybintree二叉树要测试的第二测试代码^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mybintree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	node** returnnode;
	node** get_node(int index, node** findtree, int noden = 0) {
		if (ic >= 0 && index < ic && nullptr != *findtree) {
			if (nullptr != (*findtree)->left) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->left, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
			if (index == noden++) {
				return findtree;
			}
			nodenf = noden;
			if (nullptr != (*findtree)->right) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->right, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
		}
		return nullptr;
	}
	void del_node(node** delnode) {
		node** findnode = &(*delnode)->right;
		if (nullptr == *findnode) {
			node* lefttree = (*delnode)->left;
			delete *delnode;
			*delnode = lefttree;
		}
		else if (nullptr == (*findnode)->left) {
			node* righttree = (*delnode)->right;
			delete *delnode;
			*delnode = righttree;
		}
		else {
			while (nullptr != (*findnode)->left->left) {
				findnode = &(*findnode)->left;
			}
			(*delnode)->t = (*findnode)->left->t;
			delete (*findnode)->left;
			(*findnode)->left = nullptr;
		}
		ic--;
	}
	void insert(T t, node** rootf) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node;
					(*rootf)->right->set(t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node;
					(*rootf)->left->set(t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left);
				}
			}
		}
	}
public:
	mybintree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int itemfind(T t) {
		for (int i = 0; i < ic; i++) {
			if ((*get_node(i, &root))->t == t) {
				return i;
			}
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mybintree& ml) {
		int ia = 0;
		node* findnode = ml.root;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->insert(findnode->t);
		}
	}
	mybintree(mybintree& ml) {
		*this = ml;
	}
	mybintree(const T tarr[], int has) {
		root = new node;
		root->set();
		for (int i = 0; i < has; i++) {
			insert(tarr[i]);
		}
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mybintree() {
		clear();
		delete root;
	}
	void del_front() {
		del_node(get_node(0, &root));
	}
	void del_index(int index) {
		del_node(get_node(index, &root));
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		if (i >= 0 && ic > i) {
			return (*get_node(i, &root))->t;
		}
		else {
			return NULL;
		}
	}
	T operator[](int i) {
		return at(i);
	}
	void printtree(void (*printfun)(T item, bool b)) {
		for (int i = 0; i < ic; i++) {
			printfun((*get_node(i, &root))->t, ic - 1 != i);
		}
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///再一次修正之后的mybintree二叉树^
/*
//meiri.cpp
#include <iostream>
#include "mybintree.hpp"
using namespace std;

void print(int item, bool b) {
	cout << item;
	b && cout << ", ";
}

int main() {
	mybintree<int>m;
	m.insert(1);
	m.insert(0);
	m.insert(2);
	m.insert(3);
	m.printtree(print);
	return 0;
}
*///没有任何问题的printtree方法^
/*
//meiri.cpp
#include <iostream>
#include "mybintree.hpp"
using namespace std;

void print(int item, bool b) {
	cout << item;
	b && cout << ", ";
}

int main() {
	int arr[5] = { 1, 42, 4, 23, 5 };
	mybintree<int>m(arr, 5);
	m.printtree(print);
	return 0;
}
*///也没有任何问题的有参构造函数^
/*
//meiri.cpp
#include <iostream>
#include "mybintree.hpp"
using namespace std;

void print(int item, bool b) {
	cout << item;
	b && cout << ", ";
}

int main() {
	int arr[5] = { 1, 4, 4, 3, 5 };
	mybintree<int>m(arr, 5);
	mybintree<int>ma = m;
	ma.printtree(print);
	return 0;
}
*///mybintree二叉树要测试的第五测试代码^
/*
//mybintree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class mybintree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	node** returnnode;
	node** get_node(int index, node** findtree, int noden = 0) {
		if (ic >= 0 && index < ic && nullptr != *findtree) {
			if (nullptr != (*findtree)->left) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->left, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
			if (index == noden++) {
				return findtree;
			}
			nodenf = noden;
			if (nullptr != (*findtree)->right) {
				if (nullptr != (returnnode = get_node(index, &(*findtree)->right, noden))) {
					return returnnode;
				}
				noden = nodenf;
			}
		}
		return nullptr;
	}
	void del_node(node** delnode) {
		node** findnode = &(*delnode)->right;
		if (nullptr == *findnode) {
			node* lefttree = (*delnode)->left;
			delete *delnode;
			*delnode = lefttree;
		}
		else if (nullptr == (*findnode)->left) {
			node* righttree = (*delnode)->right;
			delete *delnode;
			*delnode = righttree;
		}
		else {
			while (nullptr != (*findnode)->left->left) {
				findnode = &(*findnode)->left;
			}
			(*delnode)->t = (*findnode)->left->t;
			delete (*findnode)->left;
			(*findnode)->left = nullptr;
		}
		ic--;
	}
	void insert(T t, node** rootf) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node;
					(*rootf)->right->set(t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node;
					(*rootf)->left->set(t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left);
				}
			}
		}
	}
public:
	mybintree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int itemfind(T t) {
		for (int i = 0; i < ic; i++) {
			if ((*get_node(i, &root))->t == t) {
				return i;
			}
		}
		return -1;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mybintree& ml) {
		queue<node*>q;
		node* addnode = nullptr;
		q.push(ml.root);
		while (q.size()) {
			addnode = q.front();
			if (nullptr != addnode->left) {
				q.push(addnode->left);
			}
			if (nullptr != addnode->right) {
				q.push(addnode->right);
			}
			this->insert(q.front()->t);
			q.pop();
		}
	}
	mybintree(mybintree& ml) {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
		*this = ml;
	}
	mybintree(const T tarr[], int has) {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
		for (int i = 0; i < has; i++) {
			insert(tarr[i]);
		}
	}
	void del_back() {
		if (ic) {
			if (nullptr == root->right) {
				root->t = NULL;
			}
			else {
				node** findnode = &root;
				while (nullptr != (*findnode)->right->right) {
					findnode = &(*findnode)->right;
				}
				node** delnode = &(*findnode)->right;
				(*findnode)->right = nullptr;
				delete* delnode;
			}
			ic--;
		}
	}
	void clear() {
		while (ic) {
			del_back();
		}
	}
	~mybintree() {
		clear();
		delete root;
	}
	void del_front() {
		del_node(get_node(0, &root));
	}
	void del_index(int index) {
		del_node(get_node(index, &root));
	}
	bool IsEmpty() const {
		return !ic;
	}
	T at(int i) {
		if (i >= 0 && ic > i) {
			return (*get_node(i, &root))->t;
		}
		else {
			return NULL;
		}
	}
	T operator[](int i) {
		return at(i);
	}
	void printtree(void (*printfun)(T item, bool b)) {
		for (int i = 0; i < ic; i++) {
			printfun((*get_node(i, &root))->t, ic - 1 != i);
		}
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///最后一次修正之后的mybintree二叉树^
/*
//meiri.cpp
#include <iostream>
#include "mybintree.hpp"
using namespace std;

void print(int item, bool b) {
	cout << item;
	b && cout << ", ";
}

int main() {
	int arr[5] = { 1, 4, 4, 3, 5 };
	int i = 0;
	cout << "排序前的元素：";
	for (; i < 5; i++) {
		cout << arr[i];
		if (4 != i) {
			cout << ", ";
		}
		else {
			cout << endl;
		}
	}
	cout << "排序后的元素：";
	mybintree<int>m(arr, 5);
	m.printtree(print);
	return 0;
}
*///给元素进行排序的二叉树^
/*
//meiri.cpp
#include <iostream>
#include "mybintree.hpp"
using namespace std;

void print(int item, bool b) {
	cout << item;
	b && cout << ", ";
}

int main() {
	int arr[5] = { 1, 4, 4, 3, 5 };
	mybintree<int>m(arr, 5);
	cout << "请输入要查询的元素 -> ";
	int i = 0;
	int index = 0;
	cin >> i;
	if (-1 == (index = m.itemfind(i))) {
		cout << endl << endl << "你所查询的元素不存在" << endl;
	}
	else {
		cout << endl << endl << "你所查询的元素在mybintree二叉树m的第" << index << "项" << endl;
	}
	return 0;
}
*///查询元素是否存在的二叉树^
/*
//mybintree.hpp
#include <iostream>
#include "mybintree.hpp"
using namespace std;

int main() {
	int arr[5] = { 1, 4, 4, 3, 5 };
	mybintree<int>m(arr, 5);
	cout << "arr中最大数为" << m.max() << "，最小数为" << m.min() << endl;
	return 0;
}
*///查询最大值与最小值的二叉树^
/*
//mygraph.h
#pragma once
#include <iostream>
#include <queue>
using namespace std;
class graph {
private:
	queue<int>*adj;
	int inodes;
	int iedges;
public:
	graph(int inodes);
	graph(graph& g);
	~graph();
	void link(int nodea, int nodeb);
	void dellink(int nodea, int nodeb);
	queue<int> getlink(int node);
	bool islink(int nodea, int nodeb);
};
*///已创建mygraph.h头文件^
/*
//mygraph.cpp
#include "mygraph.h"
graph::graph(int inodes){

}
graph::graph(graph& g){

}
graph::~graph(){

}
void graph::link(int nodea, int nodeb){

}
void graph::dellink(int nodea, int nodeb){

}
queue<int> graph::getlink(int node){

}
bool graph::islink(int nodea, int nodeb){

}
*///已创建mygraph.cpp源文件^
/*
//mygraph.cpp
#include "mygraph.h"
graph::graph(int inodesf){
	inodes = inodesf;
	iedges = 0;
	adj = new queue<int>[inodes];
}
graph::graph(graph& g){

}
graph::~graph(){
	delete[] adj;
}
void graph::link(int nodea, int nodeb){

}
void graph::dellink(int nodea, int nodeb){

}
queue<int> graph::getlink(int node){

}
bool graph::islink(int nodea, int nodeb){

}
*///已构建出mygraph无向图的构造方法及析构方法^
/*
//mygraph.cpp
#include "mygraph.h"
graph::graph(int inodesf){
	inodes = inodesf;
	iedges = 0;
	adj = new queue<int>[inodes];
}
graph::graph(graph& g){
	inodes = g.inodes;
	iedges = g.iedges;
	adj = new queue<int>[inodes];
}
graph::~graph(){
	delete[] adj;
}
void graph::link(int nodea, int nodeb){

}
void graph::dellink(int nodea, int nodeb){

}
queue<int> graph::getlink(int node){

}
bool graph::islink(int nodea, int nodeb){

}
*///已构建出mygraph图中的拷贝构造方法^
/*
//mygraph.cpp
#include "mygraph.h"
graph::graph(int inodesf){
	inodes = inodesf;
	iedges = 0;
	adj = new vector<int>[inodes];
}
graph::graph(graph& g){
	inodes = g.inodes;
	iedges = g.iedges;
	adj = new vector<int>[inodes];
}
graph::~graph(){
	delete[] adj;
}
void graph::link(int nodea, int nodeb){
	for (vector<int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			return;
		}
	}
	adj[nodea].push_back(nodeb);
	adj[nodeb].push_back(nodea);
}
void graph::dellink(int nodea, int nodeb){
	for (vector<int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			adj[nodea].erase(it);
			break;
		}
	}
	for (vector<int>::iterator it = adj[nodeb].begin(); adj[nodeb].end() != it; it++) {
		if (*it == nodea) {
			adj[nodeb].erase(it);
			break;
		}
	}
}
vector<int> graph::getlink(int node){

}
bool graph::islink(int nodea, int nodeb){

}
*///已实现mygraph图的link和dellink方法^
/*
//mygraph.h
#pragma once
#include <iostream>
#include <vector>
#include <map>
using namespace std;
class graph {
private:
	vector<int>* adj;
	int inodes;
	int iedges;
public:
	graph(int inodes);
	graph(graph& g);
	graph(vector<pair<int, int>> edges);
	graph(multimap<int, int> edges);
	~graph();
	void link(int nodea, int nodeb);
	void dellink(int nodea, int nodeb);
	vector<int> getlink(int node);
	bool islink(int nodea, int nodeb);
	vector<pair<int, int>> graphlink();
	void printlink(void (*printfun)(int nodea, int nodeb, bool isNotEnd));
};
*///已在mygraph.h里面新增了两个有参构造方法及两个方法^
/*
//mygraph.cpp
#pragma once
#include <iostream>
#include <vector>
#include <map>
using namespace std;
class graph {
private:
	vector<int>* adj;
	int inodes;
	int iedges;
public:
	graph(const int inodes);
	graph(const graph& g);
	~graph();
	void link(const int nodea, const int nodeb);
	void dellink(const int nodea, const int nodeb);
	vector<int> getlink (const int node) const;
	bool islink(const int nodea, const int nodeb) const;
	vector<pair<int, int>> graphlink();
	void printlink(const void (*printfun)(const int nodea, const int nodeb, const bool isNotEnd)) const;
};
//mygraph.cpp
#include "mygraph.h"
graph::graph(const int inodesf){
	inodes = inodesf;
	iedges = 0;
	adj = new vector<int>[inodes];
}
graph::graph(const graph& g){
	inodes = g.inodes;
	iedges = g.iedges;
	adj = new vector<int>[inodes];
}
graph::~graph(){
	delete[] adj;
}
void graph::link(const int nodea, const int nodeb){
	for (vector<int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			return;
		}
	}
	adj[nodea].push_back(nodeb);
	adj[nodeb].push_back(nodea);
}
void graph::dellink(const int nodea, const int nodeb){
	for (vector<int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			adj[nodea].erase(it);
			break;
		}
	}
	for (vector<int>::iterator it = adj[nodeb].begin(); adj[nodeb].end() != it; it++) {
		if (*it == nodea) {
			adj[nodeb].erase(it);
			break;
		}
	}
}
vector<int> graph::getlink(const int node) const{

}
bool graph::islink(int nodea, int nodeb) const{

}
vector<pair<int, int>> graph::graphlink() {

}
void graph::printlink(const void (*printfun)(const int nodea, const int nodeb, const bool isNotEnd)) const {

}
*///已让大多数方法中的参数变为常量，并让大多数方法变为常方法，且删除了两个构造方法^
/*
//mygraph.cpp
#include "mygraph.h"
graph::graph(const int inodesf){
	inodes = inodesf;
	iedges = 0;
	adj = new vector<int>[inodes];
}
graph::graph(const graph& g){
	inodes = g.inodes;
	iedges = g.iedges;
	adj = new vector<int>[inodes];
}
graph::~graph(){
	delete[] adj;
}
void graph::link(const int nodea, const int nodeb){
	for (vector<int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			return;
		}
	}
	adj[nodea].push_back(nodeb);
	adj[nodeb].push_back(nodea);
}
void graph::dellink(const int nodea, const int nodeb){
	for (vector<int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			adj[nodea].erase(it);
			break;
		}
	}
	for (vector<int>::iterator it = adj[nodeb].begin(); adj[nodeb].end() != it; it++) {
		if (*it == nodea) {
			adj[nodeb].erase(it);
			break;
		}
	}
}
vector<int> graph::getlink(const int node) const{
	return adj[node];
}
bool graph::islink(const int nodea, const int nodeb) const{

}
vector<pair<int, int>> graph::graphlink() {

}
void graph::printlink(const void (*printfun)(const int nodea, const int nodeb, const bool isNotEnd)) const {

}
*///已实现mygraph图中的getlink方法^
/*
//mygraph.cpp
#include "mygraph.h"
graph::graph(const int inodesf){
	inodes = inodesf;
	iedges = 0;
	adj = new vector<int>[inodes];
}
graph::graph(const graph& g){
	inodes = g.inodes;
	iedges = g.iedges;
	adj = new vector<int>[inodes];
}
graph::~graph(){
	delete[] adj;
}
void graph::link(const int nodea, const int nodeb){
	for (vector<int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			return;
		}
	}
	adj[nodea].push_back(nodeb);
	adj[nodeb].push_back(nodea);
}
void graph::dellink(const int nodea, const int nodeb){
	for (vector<int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			adj[nodea].erase(it);
			break;
		}
	}
	for (vector<int>::iterator it = adj[nodeb].begin(); adj[nodeb].end() != it; it++) {
		if (*it == nodea) {
			adj[nodeb].erase(it);
			break;
		}
	}
}
vector<int> graph::getlink(const int node) const{
	return adj[node];
}
bool graph::islink(const int nodea, const int nodeb) const{

}
vector<pair<int, int>> graph::graphlink() {
	vector<pair<int, int>> v;
	int i = 0;
	int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				v.push_back({ i, adj[i][ia] });
			}
		}
	}
	return v;
}
void graph::printlink(const void (*printfun)(const int nodea, const int nodeb, const bool isNotEnd)) const {

}
*///已实现mygraph图中的graphlink方法^
/*
//mygraph.cpp
#include "mygraph.h"
graph::graph(const int inodesf){
	inodes = inodesf;
	iedges = 0;
	adj = new vector<int>[inodes];
}
graph::graph(const graph& g){
	inodes = g.inodes;
	iedges = g.iedges;
	adj = new vector<int>[inodes];
}
graph::~graph(){
	delete[] adj;
}
void graph::link(const int nodea, const int nodeb){
	for (vector<int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			return;
		}
	}
	adj[nodea].push_back(nodeb);
	adj[nodeb].push_back(nodea);
}
void graph::dellink(const int nodea, const int nodeb){
	for (vector<int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			adj[nodea].erase(it);
			break;
		}
	}
	for (vector<int>::iterator it = adj[nodeb].begin(); adj[nodeb].end() != it; it++) {
		if (*it == nodea) {
			adj[nodeb].erase(it);
			break;
		}
	}
}
vector<int> graph::getlink(const int node) const{
	return adj[node];
}
bool graph::islink(const int nodea, const int nodeb) const{

}
vector<pair<int, int>> graph::graphlink() {
	vector<pair<int, int>> v;
	int i = 0;
	int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				v.push_back({ i, adj[i][ia] });
			}
		}
	}
	return v;
}
void graph::printlink(const void (*printfun)(const int nodea, const int nodeb, const bool isNotEnd)) const {
	int i = 0;
	int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				printfun(i, adj[i][ia], inodes - 1 != i || adj[i].size() - 1 != ia);
			}
		}
	}
}
*///已实现mygraph图的printlink方法^
/*
//mygraph.h
#pragma once
#include <iostream>
#include <vector>
#include <map>
using namespace std;
class graph {
private:
	vector<int>* adj;
	int inodes;
	int iedges;
public:
	graph(const int inodes);
	graph(const graph& g);
	~graph();
	void link(const int nodea, const int nodeb);
	void dellink(const int nodea, const int nodeb);
	vector<int> getlink (const int node) const;
	bool islink(const int nodea, const int nodeb) const;
	bool islink(const int nodea, const int nodeb, vector<int> linknodes) const;
	vector<pair<int, int>> graphlink();
	void printlink(const void (*printfun)(const int nodea, const int nodeb, const bool isNotEnd)) const;
};
//mygraph.cpp
#include "mygraph.h"
graph::graph(const int inodesf){
	inodes = inodesf;
	iedges = 0;
	adj = new vector<int>[inodes];
}
graph::graph(const graph& g){
	inodes = g.inodes;
	iedges = g.iedges;
	adj = new vector<int>[inodes];
}
graph::~graph(){
	delete[] adj;
}
void graph::link(const int nodea, const int nodeb){
	for (vector<int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			return;
		}
	}
	adj[nodea].push_back(nodeb);
	adj[nodeb].push_back(nodea);
}
void graph::dellink(const int nodea, const int nodeb){
	for (vector<int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			adj[nodea].erase(it);
			break;
		}
	}
	for (vector<int>::iterator it = adj[nodeb].begin(); adj[nodeb].end() != it; it++) {
		if (*it == nodea) {
			adj[nodeb].erase(it);
			break;
		}
	}
}
vector<int> graph::getlink(const int node) const{
	return adj[node];
}
bool graph::islink(const int nodea, const int nodeb) const{

}
bool graph::islink(const int nodea, const int nodeb, vector<int> linknodes) const {

}
vector<pair<int, int>> graph::graphlink() {
	vector<pair<int, int>> v;
	int i = 0;
	int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				v.push_back({ i, adj[i][ia] });
			}
		}
	}
	return v;
}
void graph::printlink(const void (*printfun)(const int nodea, const int nodeb, const bool isNotEnd)) const {
	int i = 0;
	int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				printfun(i, adj[i][ia], inodes - 1 != i || adj[i].size() - 1 != ia);
			}
		}
	}
}
*///已新增一个islink的重载方法^
/*
//mygraph.h
#pragma once
#include <iostream>
#include <vector>
#include <map>
using namespace std;
class graph {
private:
	vector<int>* adj;
	int inodes;
	int iedges;
	bool islink(const int nodea, const int nodeb, bool linknodes[]) const;
public:
	graph(const int inodes);
	graph(const graph& g);
	~graph();
	void link(const int nodea, const int nodeb);
	void dellink(const int nodea, const int nodeb);
	vector<int> getlink (const int node) const;
	bool islink(const int nodea, const int nodeb) const;
	vector<pair<int, int>> graphlink();
	void printlink(const void (*printfun)(const int nodea, const int nodeb, const bool isNotEnd)) const;
};
*///已将一个方法转为私有方法^
/*
//mygraph.h
#pragma once
#include <iostream>
#include <vector>
#include <map>
using namespace std;
class graph {
private:
	vector<int>* adj;
	int inodes;
	int iedges;
	bool islink(const int nodea, const int nodeb, bool** linknodes);
public:
	graph(const int inodes);
	graph(const graph& g);
	~graph();
	void link(const int nodea, const int nodeb);
	void dellink(const int nodea, const int nodeb);
	vector<int> getlink (const int node) const;
	bool islink(const int nodea, const int nodeb);
	vector<pair<int, int>> graphlink();
	void printlink(const void (*printfun)(const int nodea, const int nodeb, const bool isNotEnd)) const;
};
//mygraph.cpp
#include "mygraph.h"
graph::graph(const int inodesf){
	inodes = inodesf;
	iedges = 0;
	adj = new vector<int>[inodes];
}
graph::graph(const graph& g){
	inodes = g.inodes;
	iedges = g.iedges;
	adj = new vector<int>[inodes];
}
graph::~graph(){
	delete[] adj;
}
void graph::link(const int nodea, const int nodeb){
	for (vector<int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			return;
		}
	}
	adj[nodea].push_back(nodeb);
	adj[nodeb].push_back(nodea);
}
void graph::dellink(const int nodea, const int nodeb){
	for (vector<int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			adj[nodea].erase(it);
			break;
		}
	}
	for (vector<int>::iterator it = adj[nodeb].begin(); adj[nodeb].end() != it; it++) {
		if (*it == nodea) {
			adj[nodeb].erase(it);
			break;
		}
	}
}
vector<int> graph::getlink(const int node) const {
	return adj[node];
}
bool graph::islink(const int nodea, const int nodeb) {
	bool* linknodes = new bool[inodes];
	islink(nodea, nodeb, &linknodes);
	delete linknodes;
}
bool graph::islink(const int nodea, const int nodeb, bool** linknodes) {
	(*linknodes)[nodea] = 1;
	for (vector<int>::const_iterator it = adj[nodea].cbegin(); adj[nodea].cend() != it; it++) {
		if (!(*linknodes)[*it] && (*it == nodeb || islink(*it, nodeb, linknodes))) {
			return 1;
		}
	}
	return 0;
}
vector<pair<int, int>> graph::graphlink() {
	vector<pair<int, int>> v;
	int i = 0;
	int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				v.push_back({ i, adj[i][ia] });
			}
		}
	}
	return v;
}
void graph::printlink(const void (*printfun)(const int nodea, const int nodeb, const bool isNotEnd)) const {
	int i = 0;
	int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				printfun(i, adj[i][ia], inodes - 1 != i || adj[i].size() - 1 != ia);
			}
		}
	}
}
*///已改变mygraph图中islink私有重载方法的参数与islink公开方法的实现，并实现好了islink私有重载方法^
/*
//mygraph.h
#pragma once
#include <iostream>
#include <vector>
#include <map>
using namespace std;
class graph {
private:
	vector<unsigned int>* adj;
	int inodes;
	int iedges;
	bool islink(const unsigned int nodea, const unsigned int nodeb, bool** linknodes);
public:
	graph(const unsigned int inodes);
	graph(const graph& g);
	~graph();
	void link(const unsigned int nodea, const unsigned int nodeb);
	void dellink(const unsigned int nodea, const unsigned int nodeb);
	vector<unsigned int> getlink (const unsigned int node) const;
	bool islink(const unsigned int nodea, const unsigned int nodeb);
	vector<pair<unsigned int, unsigned int>> graphlink();
	void printlink(const void (*printfun)(const unsigned int nodea, const unsigned int nodeb, const bool isNotEnd)) const;
};
//mygraph.cpp
#include "mygraph.h"
graph::graph(const unsigned int inodesf){
	inodes = inodesf;
	iedges = 0;
	adj = new vector<unsigned int>[inodes];
}
graph::graph(const graph& g){
	inodes = g.inodes;
	iedges = g.iedges;
	adj = new vector<unsigned int>[inodes];
}
graph::~graph(){
	delete[] adj;
}
void graph::link(const unsigned int nodea, const unsigned int nodeb){
	for (vector<unsigned int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			return;
		}
	}
	adj[nodea].push_back(nodeb);
	adj[nodeb].push_back(nodea);
}
void graph::dellink(const unsigned int nodea, const unsigned int nodeb){
	for (vector<unsigned int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			adj[nodea].erase(it);
			break;
		}
	}
	for (vector<unsigned int>::iterator it = adj[nodeb].begin(); adj[nodeb].end() != it; it++) {
		if (*it == nodea) {
			adj[nodeb].erase(it);
			break;
		}
	}
}
vector<unsigned int> graph::getlink(const unsigned int node) const {
	return adj[node];
}
bool graph::islink(const unsigned int nodea, const unsigned int nodeb) {
	bool* linknodes = new bool[inodes];
	islink(nodea, nodeb, &linknodes);
	delete[] linknodes;
}
bool graph::islink(const unsigned int nodea, const unsigned int nodeb, bool** linknodes) {
	(*linknodes)[nodea] = 1;
	for (vector<unsigned int>::const_iterator it = adj[nodea].cbegin(); adj[nodea].cend() != it; it++) {
		if (!(*linknodes)[*it] && (*it == nodeb || islink(*it, nodeb, linknodes))) {
			return 1;
		}
	}
	return 0;
}
vector<pair<unsigned int, unsigned int>> graph::graphlink() {
	vector<pair<unsigned int, unsigned int>> v;
	unsigned int i = 0;
	unsigned int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				v.push_back({ i, adj[i][ia] });
			}
		}
	}
	return v;
}
void graph::printlink(const void (*printfun)(const unsigned int nodea, const unsigned int nodeb, const bool isNotEnd)) const {
	unsigned int i = 0;
	unsigned int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				printfun(i, adj[i][ia], inodes - 1 != i || adj[i].size() - 1 != ia);
			}
		}
	}
}
*///已将mygrpah.h及mygraph.cpp中的多处“int”改为“unsigned int”^
/*
//mygraph.h
#pragma once
#include <iostream>
#include <vector>
#include <map>
using namespace std;
class graph {
private:
	vector<unsigned int>* adj;
	unsigned int inodes;
	unsigned int iedges;
	bool islink(const unsigned int nodea, const unsigned int nodeb, bool** linknodes);
public:
	graph(const unsigned int inodes);
	graph(const graph& g);
	~graph();
	void link(const unsigned int nodea, const unsigned int nodeb);
	void dellink(const unsigned int nodea, const unsigned int nodeb);
	vector<unsigned int> getlink (const unsigned int node) const;
	bool islink(const unsigned int nodea, const unsigned int nodeb);
	vector<pair<unsigned int, unsigned int>> graphlink();
	void printlink(const void (*printfun)(const unsigned int nodea, const unsigned int nodeb, const bool isNotEnd)) const;
};
//mygraph.cpp
#include "mygraph.h"
graph::graph(const unsigned int inodesf){
	inodes = inodesf;
	iedges = 0;
	adj = new vector<unsigned int>[inodes];
}
graph::graph(const graph& g){
	inodes = g.inodes;
	iedges = g.iedges;
	adj = new vector<unsigned int>[inodes];
}
graph::~graph(){
	delete[] adj;
}
void graph::link(const unsigned int nodea, const unsigned int nodeb){
	for (vector<unsigned int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			return;
		}
	}
	adj[nodea].push_back(nodeb);
	adj[nodeb].push_back(nodea);
}
void graph::dellink(const unsigned int nodea, const unsigned int nodeb){
	for (vector<unsigned int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			adj[nodea].erase(it);
			break;
		}
	}
	for (vector<unsigned int>::iterator it = adj[nodeb].begin(); adj[nodeb].end() != it; it++) {
		if (*it == nodea) {
			adj[nodeb].erase(it);
			break;
		}
	}
}
vector<unsigned int> graph::getlink(const unsigned int node) const {
	return adj[node];
}
bool graph::islink(const unsigned int nodea, const unsigned int nodeb) {
	bool* linknodes = new bool[inodes];
	bool b = islink(nodea, nodeb, &linknodes);
	delete[] linknodes;
	return b;
}
bool graph::islink(const unsigned int nodea, const unsigned int nodeb, bool** linknodes) {
	(*linknodes)[nodea] = 1;
	for (vector<unsigned int>::const_iterator it = adj[nodea].cbegin(); adj[nodea].cend() != it; it++) {
		if (!(*linknodes)[*it] && (*it == nodeb || islink(*it, nodeb, linknodes))) {
			return 1;
		}
	}
	return 0;
}
vector<pair<unsigned int, unsigned int>> graph::graphlink() {
	vector<pair<unsigned int, unsigned int>> v;
	unsigned int i = 0;
	unsigned int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				v.push_back({ i, adj[i][ia] });
			}
		}
	}
	return v;
}
void graph::printlink(const void (*printfun)(const unsigned int nodea, const unsigned int nodeb, const bool isNotEnd)) const {
	unsigned int i = 0;
	unsigned int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				printfun(i, adj[i][ia], inodes - 1 != i || adj[i].size() - 1 != ia);
			}
		}
	}
}
*///已在mygraph图中改变某些私有变量的类型，并在mygraph.cpp中修正了islink公开方法无返回值的bug^
/*
//meiri.cpp
#include <iostream>
#include "mygraph.h"
using namespace std;

int main() {
	graph g(5);
	g.link(0, 1);
	cout << "0 - " << g.getlink(0)[0] << ", 1 - " << g.getlink(1)[0];
	return 0;
}
*///已测试mygraph图中的link与getlink方法^
/*
//mygraph.cpp
#include "mygraph.h"
graph::graph(const unsigned int inodesf){
	inodes = inodesf;
	iedges = 0;
	adj = new vector<unsigned int>[inodes];
	linknodes = new bool[inodes];
}
graph::graph(const graph& g){
	inodes = g.inodes;
	iedges = g.iedges;
	adj = new vector<unsigned int>[inodes];
	linknodes = new bool[inodes];
}
graph::~graph(){
	delete[] adj;
	delete[] linknodes;
}
void graph::link(const unsigned int nodea, const unsigned int nodeb){
	for (vector<unsigned int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			return;
		}
	}
	adj[nodea].push_back(nodeb);
	adj[nodeb].push_back(nodea);
}
void graph::dellink(const unsigned int nodea, const unsigned int nodeb){
	for (vector<unsigned int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			adj[nodea].erase(it);
			break;
		}
	}
	for (vector<unsigned int>::iterator it = adj[nodeb].begin(); adj[nodeb].end() != it; it++) {
		if (*it == nodea) {
			adj[nodeb].erase(it);
			break;
		}
	}
}
vector<unsigned int> graph::getlink(const unsigned int node) const {
	return adj[node];
}
bool graph::islink(const unsigned int nodea, const unsigned int nodeb) {
	for (int i = 0; i < inodes; i++) {
		linknodes[i] = 0;
	}
	return islink(nodea, nodeb, 0);
}
bool graph::islink(const unsigned int nodea, const unsigned int nodeb, bool) {
	linknodes[nodea] = 1;
	for (vector<unsigned int>::const_iterator it = adj[nodea].cbegin(); adj[nodea].cend() != it; it++) {
		if (!linknodes[*it] && (*it == nodeb || islink(*it, nodeb, 0))) {
			return 1;
		}
	}
	return 0;
}
vector<pair<unsigned int, unsigned int>> graph::graphlink() {
	vector<pair<unsigned int, unsigned int>> v;
	unsigned int i = 0;
	unsigned int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				v.push_back({ i, adj[i][ia] });
			}
		}
	}
	return v;
}
void graph::printlink(const void (*printfun)(const unsigned int nodea, const unsigned int nodeb, const bool isNotEnd)) const {
	unsigned int i = 0;
	unsigned int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				printfun(i, adj[i][ia], inodes - 1 != i || adj[i].size() - 1 != ia);
			}
		}
	}
}
//meiri.cpp
#include <iostream>
#include "mygraph.h"
using namespace std;

int main() {
	graph g(5);
	g.link(0, 1);
	g.link(1, 4);
	g.link(0, 4);
	g.link(1, 2);
	vector<pair<unsigned int, unsigned int>>v = g.graphlink();
	for (auto it = v.begin(); v.end() != it; it++) {
		cout << it->first << "-" << it->second << endl;
	}
	cout << endl;
	for (int i = 1; i < 5; i++) {
		cout << "0 -> " << i << "?  --------  " << (g.islink(0, i) ? "true" : "false") << endl;
	}
	return 0;
}
*///已测试mygraph图中的graphlink与islink方法，并修正了gpaphlink方法^
/*
//mygraph.h
#pragma once
#include <iostream>
#include <vector>
#include <map>
using namespace std;
class graph {
private:
	vector<unsigned int>* adj;
	bool* linknodes;
	unsigned int inodes;
	unsigned int iedges;
	bool islink(const unsigned int nodea, const unsigned int nodeb, bool);
public:
	graph(const unsigned int inodes);
	graph(const graph& g);
	~graph();
	void link(const unsigned int nodea, const unsigned int nodeb);
	void dellink(const unsigned int nodea, const unsigned int nodeb);
	vector<unsigned int> getlink (const unsigned int node) const;
	bool islink(const unsigned int nodea, const unsigned int nodeb);
	vector<pair<unsigned int, unsigned int>> graphlink();
	void printlink(void (*printfun)(const unsigned int nodea, const unsigned int nodeb, const bool isNotEnd)) const;
};
//mygraph.cpp
#include "mygraph.h"
graph::graph(const unsigned int inodesf){
	inodes = inodesf;
	iedges = 0;
	adj = new vector<unsigned int>[inodes];
	linknodes = new bool[inodes];
}
graph::graph(const graph& g){
	inodes = g.inodes;
	iedges = g.iedges;
	adj = new vector<unsigned int>[inodes];
	linknodes = new bool[inodes];
}
graph::~graph(){
	delete[] adj;
	delete[] linknodes;
}
void graph::link(const unsigned int nodea, const unsigned int nodeb){
	for (vector<unsigned int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			return;
		}
	}
	adj[nodea].push_back(nodeb);
	adj[nodeb].push_back(nodea);
}
void graph::dellink(const unsigned int nodea, const unsigned int nodeb){
	for (vector<unsigned int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			adj[nodea].erase(it);
			break;
		}
	}
	for (vector<unsigned int>::iterator it = adj[nodeb].begin(); adj[nodeb].end() != it; it++) {
		if (*it == nodea) {
			adj[nodeb].erase(it);
			break;
		}
	}
}
vector<unsigned int> graph::getlink(const unsigned int node) const {
	return adj[node];
}
bool graph::islink(const unsigned int nodea, const unsigned int nodeb) {
	for (int i = 0; i < inodes; i++) {
		linknodes[i] = 0;
	}
	return islink(nodea, nodeb, 0);
}
bool graph::islink(const unsigned int nodea, const unsigned int nodeb, bool) {
	linknodes[nodea] = 1;
	for (vector<unsigned int>::const_iterator it = adj[nodea].cbegin(); adj[nodea].cend() != it; it++) {
		if (!linknodes[*it] && (*it == nodeb || islink(*it, nodeb, 0))) {
			return 1;
		}
	}
	return 0;
}
vector<pair<unsigned int, unsigned int>> graph::graphlink() {
	vector<pair<unsigned int, unsigned int>> v;
	unsigned int i = 0;
	unsigned int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				v.push_back({ i, adj[i][ia] });
			}
		}
	}
	return v;
}
void graph::printlink(void (*printfun)(const unsigned int nodea, const unsigned int nodeb, const bool isNotEnd)) const {
	unsigned int i = 0;
	unsigned int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				printfun(i, adj[i][ia], inodes - 1 != i || adj[i].size() - 1 != ia);
			}
		}
	}
}
//meiri.cpp
#include <iostream>
#include "mygraph.h"
using namespace std;

void print(unsigned int i, unsigned int ia, bool b) {
	cout << i << " - " << ia << endl;
}

int main() {
	graph g(2);
	graph ga = g;
	cout << g.graphlink().size() << " ";
	g.dellink(0, 1);
	g.dellink(1, 0);
	ga.link(0, 1);
	cout << ga.graphlink().size() << " ";
	ga.dellink(0, 1);
	ga.dellink(1, 0);
	cout << ga.graphlink().size() << " ";
	ga.printlink(print);
	return 0;
}
*///已测试mygraph图中的dellink方法，printlink方法与拷贝方法，并使printlink方法的形参重新修正过来了^
/*
//mygraph.cpp
#include "mygraph.h"
graph::graph(const unsigned int inodesf){
	inodes = inodesf;
	iedges = 0;
	adj = new vector<unsigned int>[inodes];
	linknodes = new bool[inodes];
}
graph::graph(const graph& g){
	inodes = g.inodes;
	iedges = g.iedges;
	adj = new (vector<unsigned int>[inodes]);
	linknodes = new bool[inodes];
}
graph::~graph(){
	delete[] adj;
	delete[] linknodes;
}
void graph::link(const unsigned int nodea, const unsigned int nodeb){
	for (vector<unsigned int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			return;
		}
	}
	adj[nodea].push_back(nodeb);
	adj[nodeb].push_back(nodea);
}
void graph::dellink(const unsigned int nodea, const unsigned int nodeb){
	for (vector<unsigned int>::iterator it = adj[nodea].begin(); adj[nodea].end() != it; it++) {
		if (*it == nodeb) {
			adj[nodea].erase(it);
			break;
		}
	}
	for (vector<unsigned int>::iterator it = adj[nodeb].begin(); adj[nodeb].end() != it; it++) {
		if (*it == nodea) {
			adj[nodeb].erase(it);
			break;
		}
	}
}
vector<unsigned int> graph::getlink(const unsigned int node) const {
	return adj[node];
}
bool graph::islink(const unsigned int nodea, const unsigned int nodeb) {
	for (int i = 0; i < inodes; i++) {
		linknodes[i] = 0;
	}
	return islink(nodea, nodeb, 0);
}
bool graph::islink(const unsigned int nodea, const unsigned int nodeb, bool) {
	linknodes[nodea] = 1;
	for (vector<unsigned int>::const_iterator it = adj[nodea].cbegin(); adj[nodea].cend() != it; it++) {
		if (!linknodes[*it] && (*it == nodeb || islink(*it, nodeb, 0))) {
			return 1;
		}
	}
	return 0;
}
vector<pair<unsigned int, unsigned int>> graph::graphlink() {
	vector<pair<unsigned int, unsigned int>> v;
	unsigned int i = 0;
	unsigned int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				v.push_back({ i, adj[i][ia] });
			}
		}
	}
	return v;
}
void graph::printlink(void (*printfun)(const unsigned int nodea, const unsigned int nodeb, const bool isNotEnd)) const {
	vector<pair<unsigned int, unsigned int>> v;
	unsigned int i = 0;
	unsigned int ia = 0;
	for (; i < inodes; i++) {
		for (ia = 0; ia < adj[i].size(); ia++) {
			if (i < adj[i][ia]) {
				v.push_back({ i, adj[i][ia] });
			}
		}
	}
	for (auto it = v.cbegin(); v.cend() != it; it++) {
		printfun(it->first, it->second, v.cend() - 1 != it);
	}
}
//meiri.cpp
#include <iostream>
#include "mygraph.h"
using namespace std;

void print(unsigned int i, unsigned int ia, bool b) {
	cout << i << " - " << ia << endl;
}

void printa(unsigned int i, unsigned int ia, bool b) {
	cout << i << " - " << ia;
	b && (cout << ", "), b || (cout << endl);
}

int main() {
	graph g(5);
	g.link(0, 4);
	g.link(1, 2);
	g.link(0, 1);
	g.link(3, 2);
	g.link(2, 4);
	g.link(0, 2);
	g.link(3, 4);
	g.printlink(print);
	cout << endl;
	g.printlink(printa);
	return 0;
}
*///已深度测试mygraph图中的printlink方法，并修正了printlink方法的实现^
/*
//mystack.hpp
#pragma once
#include <iostream>
#include <stack>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
		this->ic = 0;
	}
	void push(T t) {
		
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.head;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->push(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		head = new node;
		head->set();
		if (sizeof * tarr) {
			const T* tp = tarr;
			for (int i = 0; i < has; i++) {
				push(*tp++);
			}
		}
	}
	void pop() {
		if (ic) {
			
			ic--;
		}
	}
	void clear() {
		while (ic) {
			pop();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printlist(void (*printfun)(T item, bool b)) {
		if (ic) {
			
		}
	}
};
*///已创建mystack.hpp文件^
/*
//mystack.hpp
#pragma once
#include <iostream>
#include <stack>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
		this->ic = 0;
	}
	T push(T t) {
		node* addnode = new node;
		addnode->set(t, head->next);
		head->next = addnode;
		ic++;
		return t;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.head;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->push(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		head = new node;
		head->set();
		if (sizeof * tarr) {
			const T* tp = tarr;
			for (int i = 0; i < has; i++) {
				push(*tp++);
			}
		}
	}
	T pop() {
		if (ic) {
			T tpop = NULL;
			node* newnode = head->next->next;
			tpop = head->next->item;
			delete head->next;
			head->next = newnode;
			ic--;
			return tpop;
		}
		else {
			return NULL;
		}
	}
	void clear() {
		while (ic) {
			pop();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printlist(void (*printfun)(T item, bool b)) {
		if (ic) {
			
		}
	}
};
*///已实现mystack栈中的push与pop方法^
/*
//mystack.hpp
#pragma once
#include <iostream>
#include <stack>
using namespace std;
template<class T>
class mylist {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mylist() {
		head = new node;
		head->set();
		this->ic = 0;
	}
	T push(T t) {
		node* addnode = new node;
		addnode->set(t, head->next);
		head->next = addnode;
		ic++;
		return t;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mylist& ml) {
		int ia = 0;
		node* findnode = ml.head;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->push(findnode->t);
		}
	}
	mylist(mylist& ml) {
		*this = ml;
	}
	mylist(const T tarr[], int has) {
		head = new node;
		head->set();
		if (sizeof * tarr) {
			const T* tp = tarr;
			for (int i = 0; i < has; i++) {
				push(*tp++);
			}
		}
	}
	T pop() {
		if (ic) {
			T tpop = NULL;
			node* newnode = head->next->next;
			tpop = head->next->item;
			delete head->next;
			head->next = newnode;
			ic--;
			return tpop;
		}
		else {
			return NULL;
		}
	}
	void clear() {
		while (ic) {
			pop();
		}
	}
	~mylist() {
		clear();
		delete head;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printlist(void (*printfun)(T item, bool IsNotEnd)) {
		if (ic) {
			node* printnode = root->next;
			while (nullptr != printnode) {
				printfun(printnode->t, nullptr != printnode->next);
				printnode = printnode->next;
			}
		}
	}
};
*///已实现mystack栈中的printlist方法^
/*
//mystack.hpp
#pragma once
#include <iostream>
#include <stack>
using namespace std;
template<class T>
class mystack {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mystack() {
		head = new node;
		head->set();
		this->ic = 0;
	}
	T push(T t) {
		node* addnode = new node;
		addnode->set(t, head->next);
		head->next = addnode;
		ic++;
		return t;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mystack& ml) {
		int ia = 0;
		node* findnode = ml.head;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->push(findnode->t);
		}
	}
	mystack(mystack& ml) {
		*this = ml;
	}
	mystack(const T tarr[], int has) {
		head = new node;
		head->set();
		if (sizeof * tarr) {
			const T* tp = tarr;
			for (int i = 0; i < has; i++) {
				push(*tp++);
			}
		}
	}
	T pop() {
		if (ic) {
			T tpop = NULL;
			node* newnode = head->next->next;
			tpop = head->next->item;
			delete head->next;
			head->next = newnode;
			ic--;
			return tpop;
		}
		else {
			return NULL;
		}
	}
	T top() {
		if (ic) {
			return head->next->item;
		}
		else {
			return NULL;
		}
	}
	void clear() {
		while (ic) {
			pop();
		}
	}
	~mystack() {
		clear();
		delete head;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printstack(void (*printfun)(T item, bool IsNotEnd)) {
		if (ic) {
			node* printnode = root->next;
			while (nullptr != printnode) {
				printfun(printnode->t, nullptr != printnode->next);
				printnode = printnode->next;
			}
		}
	}
};
*///已新建并实现了mystack栈的top方法^
/*
//mystack.hpp
#pragma once
#include <iostream>
#include <stack>
using namespace std;
template<class T>
class mystack {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mystack() {
		head = new node;
		head->set();
		this->ic = 0;
	}
	T push(T t) {
		node* addnode = new node;
		addnode->set(t, head->next);
		head->next = addnode;
		ic++;
		return t;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mystack& ml) {
		int ia = 0;
		node* findnode = ml.head;
		for (int i = 0; i < ml.ic; i++) {
			findnode = findnode->next;
			this->push(findnode->t);
		}
	}
	mystack(mystack& ml) {
		*this = ml;
	}
	mystack(const T tarr[], int has) {
		head = new node;
		head->set();
		if (sizeof * tarr) {
			const T* tp = tarr;
			for (int i = 0; i < has; i++) {
				push(*tp++);
			}
		}
	}
	T pop() {
		if (ic) {
			T tpop = NULL;
			node* nextnode = head->next->next;
			tpop = head->next->t;
			delete head->next;
			head->next = nextnode;
			ic--;
			return tpop;
		}
		else {
			return NULL;
		}
	}
	T top() {
		if (ic) {
			return head->next->t;
		}
		else {
			return NULL;
		}
	}
	void clear() {
		while (ic) {
			pop();
		}
	}
	~mystack() {
		clear();
		delete head;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printstack(void (*printfun)(T t, bool IsNotEnd)) {
		if (ic) {
			node* printnode = head->next;
			while (nullptr != printnode) {
				printfun(printnode->t, nullptr != printnode->next);
				printnode = printnode->next;
			}
		}
	}
};
//meiri.cpp
#include <iostream>
#include "mystack.hpp"
#include <stack>
using namespace std;

int main() {
	mystack<int>s;
	stack<int>ss;
	int i = 1234;
	cout << s.capacity() << endl << endl << "反转前：";
	while (i) {
		cout << s.push(i) << " ";
		i /= 10;
	}
	cout << endl << s.capacity() << endl << endl << "反转后：";
	while (!s.IsEmpty()) {
		cout << s.pop() << " ";
	}
	cout << endl << s.capacity() << endl;
	return 0;
}
*///已测试好mystack栈的capacity方法，push方法，IsEmpty方法与pop方法^
/*
//mystack.hpp
#pragma once
#include <iostream>
#include <stack>
using namespace std;
template<class T>
class mystack {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	mystack() {
		head = new node;
		head->set();
		this->ic = 0;
	}
	T push(T t) {
		node* addnode = new node;
		addnode->set(t, head->next);
		head->next = addnode;
		ic++;
		return t;
	}
	int capacity() const {
		return ic;
	}
	void operator=(mystack& ml) {
		this->clear();
		T* arr = new T[ml.ic];
		node* addnode = ml.head->next;
		for (int i = 0; i < ml.ic; i++) {
			arr[i] = addnode->t;
			addnode = addnode->next;
		}
		for (int i = ml.ic - 1; i >= 0; i--) {
			this->push(arr[i]);
		}
	}
	mystack(mystack& ml) {
		head = new node;
		head->set();
		this->ic = 0;
		*this = ml;
	}
	mystack(const T tarr[], int has) {
		head = new node;
		head->set();
		this->ic = 0;
		if (sizeof * tarr) {
			const T* tp = tarr;
			for (int i = 0; i < has; i++) {
				push(*tp++);
			}
		}
	}
	T pop() {
		if (ic) {
			T tpop = NULL;
			node* nextnode = head->next->next;
			tpop = head->next->t;
			delete head->next;
			head->next = nextnode;
			ic--;
			return tpop;
		}
		else {
			return NULL;
		}
	}
	T top() {
		if (ic) {
			return head->next->t;
		}
		else {
			return NULL;
		}
	}
	void clear() {
		while (ic) {
			pop();
		}
	}
	~mystack() {
		clear();
		delete head;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printstack(void (*printfun)(T t, bool IsNotEnd)) {
		if (ic) {
			node* printnode = head->next;
			while (nullptr != printnode) {
				printfun(printnode->t, nullptr != printnode->next);
				printnode = printnode->next;
			}
		}
	}
};
//meiri.cpp
#include <iostream>
#include "mystack.hpp"
#include <stack>
using namespace std;

void print(int i, bool b) {
	cout << i << " ";
}

int main() {
	int arr[4] = { 1234, 123, 12, 1 };
	mystack<int>sa(arr, 4);
	mystack<int>s = sa;
	cout << s.capacity() << endl << endl << "反转后：";
	s.printstack(print);
	cout << endl << s.top() << endl;
	s.clear();
	cout << s.top() << endl;
	cout << endl << s.capacity() << endl;
	return 0;
}
*///已测试好mystack的拷贝构造方法，有参构造方法，printstack方法，top方法与clear方法0，并修正了拷贝构造方法的实现^
/*
//meiri.cpp
#include <iostream>
#include "mystack.hpp"
#include <stack>
using namespace std;

void print(int i, bool b) {
	cout << i;
	if (b) {
		cout << ", ";
	}
}

int main() {
	int arr[4] = { 1234, 123, 12, 1 };
	mystack<int>s(arr, 4);
	s.printstack(print);
	return 0;
}*
*///已测试好mystack栈的所有方法^
/*
//myqueue.hpp
#pragma once
#include <iostream>
using namespace std;
template<class T>
class myqueue {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	myqueue() {
		head = new node;
		head->set();
		this->ic = 0;
	}
	T push(T t) {
		node* addnode = new node;
		addnode->set(t, nullptr);
		node** lastnode = &head;
		while (nullptr != (*lastnode)->next) {
			lastnode = &(*lastnode)->next;
		}
		(*lastnode)->next = addnode;
		ic++;
		return t;
	}
	int capacity() const {
		return ic;
	}
	void operator=(myqueue& ml) {
		this->clear();
		T* arr = new T[ml.ic];
		node* addnode = ml.head->next;
		for (int i = 0; i < ml.ic; i++) {
			arr[i] = addnode->t;
			addnode = addnode->next;
		}
		for (int i = ml.ic - 1; i >= 0; i--) {
			this->push(arr[i]);
		}
	}
	myqueue(myqueue& ml) {
		head = new node;
		head->set();
		this->ic = 0;
		*this = ml;
	}
	myqueue(const T tarr[], int has) {
		head = new node;
		head->set();
		this->ic = 0;
		if (sizeof * tarr) {
			const T* tp = tarr;
			for (int i = 0; i < has; i++) {
				push(*tp++);
			}
		}
	}
	T pop() {
		if (ic) {
			T tfront = NULL;
			node* nextnode = head->next->next;
			tfront = head->next->t;
			delete head->next;
			head->next = nextnode;
			ic--;
			return tfront;
		}
		else {
			return NULL;
		}
	}
	T front() {
		if (ic) {
			return head->next->t;
		}
		else {
			return NULL;
		}
	}
	void clear() {
		while (ic) {
			pop();
		}
	}
	~myqueue() {
		clear();
		delete head;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printqueue(void (*printfun)(T t, bool IsNotEnd)) {
		if (ic) {
			node* printnode = head->next;
			while (nullptr != printnode) {
				printfun(printnode->t, nullptr != printnode->next);
				printnode = printnode->next;
			}
		}
	}
};
*///已实现myqueue队列的入队方法^
/*
//myqueue.hpp
#pragma once
#include <iostream>
using namespace std;
template<class T>
class myqueue {
private:
	int ic;
	class node {
	public:
		T t;
		node* next;
		void set() {
			this->t = NULL;
			this->next = nullptr;
		}
		void set(T tf, node* nextf) {
			this->t = tf;
			this->next = nextf;
		}
	};
	node* head;
public:
	myqueue() {
		head = new node;
		head->set();
		this->ic = 0;
	}
	T push(T t) {
		node* addnode = new node;
		addnode->set(t, nullptr);
		node** lastnode = &head;
		while (nullptr != (*lastnode)->next) {
			lastnode = &(*lastnode)->next;
		}
		(*lastnode)->next = addnode;
		ic++;
		return t;
	}
	int capacity() const {
		return ic;
	}
	void operator=(myqueue& ml) {
		this->clear();
		node* addnode = ml.head;
		while (nullptr != addnode->next) {
			addnode = addnode->next;
			this->push(addnode->t);
		}
	}
	myqueue(myqueue& ml) {
		head = new node;
		head->set();
		this->ic = 0;
		*this = ml;
	}
	myqueue(const T tarr[], int has) {
		head = new node;
		head->set();
		this->ic = 0;
		if (sizeof * tarr) {
			const T* tp = tarr;
			for (int i = 0; i < has; i++) {
				push(*tp++);
			}
		}
	}
	T pop() {
		if (ic) {
			T tfront = NULL;
			node* nextnode = head->next->next;
			tfront = head->next->t;
			delete head->next;
			head->next = nextnode;
			ic--;
			return tfront;
		}
		else {
			return NULL;
		}
	}
	T front() {
		if (ic) {
			return head->next->t;
		}
		else {
			return NULL;
		}
	}
	void clear() {
		while (ic) {
			pop();
		}
	}
	~myqueue() {
		clear();
		delete head;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printqueue(void (*printfun)(T t, bool IsNotEnd)) {
		if (ic) {
			node* printnode = head->next;
			while (nullptr != printnode) {
				printfun(printnode->t, nullptr != printnode->next);
				printnode = printnode->next;
			}
		}
	}
};
*///已修正myqueue队列的拷贝构造方法^
/*
//meiri.cpp
#include <iostream>
#include "myqueue.hpp"
using namespace std;

void print(int i, bool b) {
	cout << i;
	if (b) {
		cout << ", ";
	}
	else {
		cout << endl;
	}
}

int main() {
	int arr[4] = { 1234, 123, 12, 1 };
	myqueue<int>qa(arr, 4);
	myqueue<int>q = qa;
	q.printqueue(print);
	q.pop();
	q.printqueue(print);
	q.clear();
	q.printqueue(print);
	return 0;
}
*///已测试好queue队列的printqueue方法，pop方法，push方法，拷贝构造方法与clear方法^
/*
//myheap.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myheap {
private:
	int ic;
	int inodenum;
	T* nodearr;
public:
	myheap(int icapacity) {
		this->ic = icapacity;
		this->inodenum = 0;
		this->nodearr = new T[icapacity];
	}
	myheap(const T tarr[], int has) {

	}
	myheap(myheap& heap) {

	}
	T insert(T item) {

	}
	T getMax() {

	}
	T delMax() {

	}
	void clear() {

	}
	int capacity() {
		return ic;
	}
	int nodenum() {
		return inodenum;
	}
	void swim(int inode) {

	}
	void sink(int inode) {

	}
	void printheap() {
		
	}
	~myheap() {
		delete[] nodearr;
	}
};
*///已创建myheap.hpp类文件^
/*
//myheap.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myheap {
private:
	int ic;
	int inodenum;
	T* nodearr;
	void swap(int nodea, int nodeb) {
		int nodetemp = nodea;
		nodea = nodeb;
		nodeb = nodetemp;
	}
public:
	myheap(int icapacity) {
		this->ic = icapacity;
		this->inodenum = 0;
		this->nodearr = new T[icapacity];
	}
	myheap(const T tarr[], int has) {

	}
	myheap(myheap& heap) {

	}
	T insert(T item) {

	}
	T getMax() {

	}
	T delMax() {

	}
	void clear() {

	}
	int capacity() {
		return ic;
	}
	int nodenum() {
		return inodenum;
	}
	void swim(int inode) {

	}
	void sink(int inode) {

	}
	void printheap() {
		
	}
	~myheap() {
		delete[] nodearr;
	}
};
*///已声明并实现出myheap堆的swap方法^
/*
//myheap.cpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myheap {
private:
	int ic;
	int inodenum;
	T* nodearr;
	void swap(int nodea, int nodeb) {
		int nodetemp = nodea;
		nodea = nodeb;
		nodeb = nodetemp;
	}
public:
	myheap(int icapacity) {
		this->ic = icapacity;
		this->inodenum = 0;
		this->nodearr = new T[icapacity];
	}
	myheap(const T tarr[], int has) {

	}
	myheap(myheap& heap) {

	}
	T insert(T item) {

	}
	T getMax() {

	}
	T delMax() {

	}
	void clear() {
		for (int i = 0; i < ic; i++) {
			nodearr[i] = NULL;
		}
		inodenum = 0;
	}
	int capacity() {
		return ic;
	}
	int nodenum() {
		return inodenum;
	}
	void swim(int inode) {

	}
	void sink(int inode) {

	}
	void printheap() {
		
	}
	~myheap() {
		delete[] nodearr;
	}
};
*///已实现myheap堆的clear清空方法^
/*
//myheap.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myheap {
private:
	int ic;
	int inodenum;
	T* nodearr;
	void swap(int nodea, int nodeb) {
		int nodetemp = nodea;
		nodea = nodeb;
		nodeb = nodetemp;
	}
public:
	myheap(int icapacity) {
		this->ic = icapacity;
		this->inodenum = 0;
		this->nodearr = new T[icapacity];
	}
	myheap(const T tarr[], int has) {

	}
	myheap(myheap& heap) {

	}
	T insert(T item) {

	}
	T getMax() {
		return tarr[0];
	}
	T delMax() {

	}
	void clear() {
		for (int i = 0; i < ic; i++) {
			nodearr[i] = NULL;
		}
		inodenum = 0;
	}
	int capacity() {
		return ic;
	}
	int nodenum() {
		return inodenum;
	}
	void swim(int inode) {

	}
	void sink(int inode) {

	}
	void printheap() {
		
	}
	~myheap() {
		delete[] nodearr;
	}
};
*///已实现myheap堆的getMax方法^
/*
//myheap.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myheap {
private:
	int ic;
	int inodenum;
	T* nodearr;
	void swap(int nodea, int nodeb) {
		int nodetemp = nodea;
		nodea = nodeb;
		nodeb = nodetemp;
	}
public:
	myheap(int icapacity) {
		this->ic = icapacity;
		this->inodenum = 0;
		this->nodearr = new T[icapacity + 1];
	}
	myheap(const T tarr[], int has) {

	}
	myheap(myheap& heap) {

	}
	T insert(T item) {
		nodearr[++inodenum] = item;
		swim(inodenum);
	}
	T getMax() {
		return nodearr[0];
	}
	T delMax() {

	}
	void clear() {
		for (int i = 0; i < ic; i++) {
			nodearr[i] = NULL;
		}
		inodenum = 0;
	}
	int capacity() {
		return ic;
	}
	int nodenum() {
		return inodenum;
	}
	void swim(int inode) {
		if (inode / 2 && nodearr[inode / 2] < nodearr[inode]) {
			swap(inode / 2, inode);
			swim(inode / 2);
		}
	}
	void sink(int inode) {

	}
	void printheap() {
		
	}
	~myheap() {
		delete[] nodearr;
	}
};
*///已实现myheap堆的swim方法与insert方法^
/*
//myheap.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myheap {
private:
	int ic;
	int inodenum;
	T* nodearr;
	void swap(int nodea, int nodeb) {
		int nodetemp = nodea;
		nodea = nodeb;
		nodeb = nodetemp;
	}
public:
	myheap(int icapacity) {
		this->ic = icapacity;
		this->inodenum = 0;
		this->nodearr = new T[icapacity + 1];
	}
	myheap(const T tarr[], int has) {

	}
	myheap(myheap& heap) {

	}
	T insert(T item) {
		nodearr[++inodenum] = item;
		swim(inodenum);
	}
	T getMax() {
		return nodearr[0];
	}
	T delMax() {
		if (inodenum) {
			nodearr[0] = nodearr[inodenum--];
			nodearr[inodenum + 1] = NULL;
			inodenum--;
			sink(0);
		}
	}
	void clear() {
		for (int i = 0; i < ic; i++) {
			nodearr[i] = NULL;
		}
		inodenum = 0;
	}
	int capacity() {
		return ic;
	}
	int nodenum() {
		return inodenum;
	}
	void swim(int inode) {
		if (inode / 2 && nodearr[inode / 2] < nodearr[inode]) {
			swap(inode / 2, inode);
			swim(inode / 2);
		}
	}
	void sink(int inode) {
		if (inode * 2 < inodenum && nodearr[inode * 2] >= nodearr[inode] && (inode * 2 + 1 >= inodenum || nodearr[inode * 2] >= nodearr[inode * 2 + 1])) {
			swap(inode * 2, inode);
			sink(inode * 2);
		}
		else if (inode * 2 + 1 < inodenum && nodearr[inode * 2 + 1] >= nodearr[inode] && nodearr[inode * 2] <= nodearr[inode * 2 + 1]) {
			swap(inode * 2 + 1, inode);
			sink(inode * 2 + 1);
		}
	}
	void printheap() {
		
	}
	~myheap() {
		delete[] nodearr;
	}
};
*///已实现myheap堆的delMax方法与sink方法^
/*
//myheap.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myheap {
private:
	int ic;
	int inodenum;
	T* nodearr;
	void swap(int nodea, int nodeb) {
		int nodetemp = nodea;
		nodea = nodeb;
		nodeb = nodetemp;
	}
public:
	myheap(int icapacity) {
		this->ic = icapacity;
		this->inodenum = 0;
		this->nodearr = new T[icapacity + 1];
	}
	myheap(const T tarr[], int has) {

	}
	myheap(myheap& heap) {

	}
	T insert(T item) {
		if (inodenum >= ic) {
			return NULL;
		}
		nodearr[++inodenum] = item;
		swim(inodenum);
		return item;
	}
	T getMax() {
		return nodearr[0];
	}
	T delMax() {
		t max = NULL;
		if (inodenum) {
			nodearr[0] = nodearr[inodenum--];
			max = nodearr[0];
			nodearr[inodenum + 1] = NULL;
			inodenum--;
			sink(0);
		}
		return max;
	}
	void clear() {
		for (int i = 0; i < ic; i++) {
			nodearr[i] = NULL;
		}
		inodenum = 0;
	}
	int capacity() {
		return ic;
	}
	int nodenum() {
		return inodenum;
	}
	void swim(int inode) {
		if (inode / 2 && nodearr[inode / 2] < nodearr[inode]) {
			swap(inode / 2, inode);
			swim(inode / 2);
		}
	}
	void sink(int inode) {
		if (inode * 2 < inodenum && nodearr[inode * 2] >= nodearr[inode] && (inode * 2 + 1 >= inodenum || nodearr[inode * 2] >= nodearr[inode * 2 + 1])) {
			swap(inode * 2, inode);
			sink(inode * 2);
		}
		else if (inode * 2 + 1 < inodenum && nodearr[inode * 2 + 1] >= nodearr[inode] && nodearr[inode * 2] <= nodearr[inode * 2 + 1]) {
			swap(inode * 2 + 1, inode);
			sink(inode * 2 + 1);
		}
	}
	void printheap() {
		
	}
	~myheap() {
		delete[] nodearr;
	}
};
*///已修正myheap堆的insert方法与delMax方法没有返回值的问题，并为insert方法增加了一个限制条件^
/*
//myheap.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myheap {
private:
	int ic;
	int inodenum;
	T* nodearr;
	void swap(int nodea, int nodeb) {
		int nodetemp = nodea;
		nodea = nodeb;
		nodeb = nodetemp;
	}
public:
	myheap(int icapacity) {
		this->ic = icapacity;
		this->inodenum = 0;
		this->nodearr = new T[icapacity + 1];
	}
	myheap(const T tarr[], int has) {
		this->ic = ihas;
		this->inodenum = 0;
		this->nodearr = new T[ic + 1];
		for (int i = 0; i < ihas; i++) {
			this->insert(tarr[i]);
		}
	}
	myheap(myheap& heap) {
		*this = heap;
	}
	void operator=(myheap& heap) {
		static bool bcreate = false;
		if (bcreate) {
			this->clear();
			delete[] this->nodearr;
		}
		this->ic = heap.ic;
		this->inodenum = heap.inodenum;
		this->nodearr = new T[ic + 1];
		for (int i = 0; i < this->ic; i++) {
			this->nodearr[i + 1] = heap->nodearr[i + 1];
		}
		bcreate = true;
	}
	T insert(T item) {
		if (inodenum >= ic) {
			return NULL;
		}
		nodearr[++inodenum] = item;
		swim(inodenum);
		return item;
	}
	T getMax() {
		return nodearr[0];
	}
	T delMax() {
		t max = NULL;
		if (inodenum) {
			nodearr[0] = nodearr[inodenum--];
			max = nodearr[0];
			nodearr[inodenum + 1] = NULL;
			inodenum--;
			sink(0);
		}
		return max;
	}
	void clear() {
		for (int i = 0; i < ic; i++) {
			nodearr[i] = NULL;
		}
		inodenum = 0;
	}
	int capacity() {
		return ic;
	}
	int nodenum() {
		return inodenum;
	}
	void swim(int inode) {
		if (inode / 2 && nodearr[inode / 2] < nodearr[inode]) {
			swap(inode / 2, inode);
			swim(inode / 2);
		}
	}
	void sink(int inode) {
		if (inode * 2 < inodenum && nodearr[inode * 2] >= nodearr[inode] && (inode * 2 + 1 >= inodenum || nodearr[inode * 2] >= nodearr[inode * 2 + 1])) {
			swap(inode * 2, inode);
			sink(inode * 2);
		}
		else if (inode * 2 + 1 < inodenum && nodearr[inode * 2 + 1] >= nodearr[inode] && nodearr[inode * 2] <= nodearr[inode * 2 + 1]) {
			swap(inode * 2 + 1, inode);
			sink(inode * 2 + 1);
		}
	}
	void printheap() {
		
	}
	~myheap() {
		delete[] nodearr;
	}
};
*///已实现myheap堆的有参构造方法和拷贝构造方法，并重载了赋值运算符^
/*
//myheap.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myheap {
private:
	int ic;
	int inodenum;
	T* nodearr;
	void swap(int nodea, int nodeb) {
		int nodetemp = nodea;
		nodea = nodeb;
		nodeb = nodetemp;
	}
public:
	myheap(int icapacity) {
		this->ic = icapacity;
		this->inodenum = 0;
		this->nodearr = new T[icapacity + 1];
	}
	myheap(const T tarr[], int has) {
		this->ic = ihas;
		this->inodenum = 0;
		this->nodearr = new T[ic + 1];
		for (int i = 0; i < ihas; i++) {
			this->insert(tarr[i]);
		}
	}
	myheap(myheap& heap) {
		*this = heap;
	}
	void operator=(myheap& heap) {
		static bool bcreate = false;
		if (bcreate) {
			this->clear();
			delete[] this->nodearr;
		}
		this->ic = heap.ic;
		this->inodenum = heap.inodenum;
		this->nodearr = new T[ic + 1];
		for (int i = 0; i < this->ic; i++) {
			this->nodearr[i + 1] = heap->nodearr[i + 1];
		}
		bcreate = true;
	}
	T insert(T item) {
		if (inodenum >= ic) {
			return NULL;
		}
		nodearr[++inodenum] = item;
		swim(inodenum);
		return item;
	}
	T getMax() {
		return nodearr[0];
	}
	T delMax() {
		t max = NULL;
		if (inodenum) {
			nodearr[0] = nodearr[inodenum--];
			max = nodearr[0];
			nodearr[inodenum + 1] = NULL;
			inodenum--;
			sink(0);
		}
		return max;
	}
	void clear() {
		for (int i = 0; i < ic; i++) {
			nodearr[i + 1] = NULL;
		}
		inodenum = 0;
	}
	int capacity() {
		return ic;
	}
	int nodenum() {
		return inodenum;
	}
	void swim(int inode) {
		if (inode / 2 && nodearr[inode / 2] < nodearr[inode]) {
			swap(inode / 2, inode);
			swim(inode / 2);
		}
	}
	void sink(int inode) {
		if (inode * 2 < inodenum && nodearr[inode * 2] >= nodearr[inode] && (inode * 2 + 1 >= inodenum || nodearr[inode * 2] >= nodearr[inode * 2 + 1])) {
			swap(inode * 2, inode);
			sink(inode * 2);
		}
		else if (inode * 2 + 1 < inodenum && nodearr[inode * 2 + 1] >= nodearr[inode] && nodearr[inode * 2] <= nodearr[inode * 2 + 1]) {
			swap(inode * 2 + 1, inode);
			sink(inode * 2 + 1);
		}
	}
	void printheap(void (*printfun)(T, bool)) {
		for (int i = 0; i < ic; i++) {
			printfun(nodearr[i + 1], i + 1 != ic);
		}
	}
	~myheap() {
		delete[] nodearr;
	}
};
*///已实现了myheap堆的printfun方法^
/*
//myheap.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myheap {
private:
	int ic;
	int inodenum;
	T* nodearr;
	bool bcreate;
	void swap(const int nodea, const int nodeb) {
		int nodetemp = nodearr[nodea];
		nodearr[nodea] = nodearr[nodeb];
		nodearr[nodeb] = nodetemp;
	}
public:
	myheap(const int icapacity) {
		this->bcreate = false;
		this->ic = icapacity;
		this->inodenum = 0;
		this->nodearr = new T[icapacity + 1];
	}
	myheap(const T tarr[], const int ihas) {
		this->bcreate = false;
		this->ic = ihas;
		this->inodenum = 0;
		this->nodearr = new T[ic + 1];
		for (int i = 0; i < ihas; i++) {
			this->insert(tarr[i]);
		}
	}
	myheap(myheap& heap) {
		this->bcreate = false;
		*this = heap;
	}
	void operator=(myheap& heap) {
		if (this->bcreate) {
			this->clear();
			delete[] this->nodearr;
		}
		this->ic = heap.ic;
		this->inodenum = heap.inodenum;
		this->nodearr = new T[ic + 1];
		for (int i = 0; i < this->ic; i++) {
			this->nodearr[i + 1] = heap.nodearr[i + 1];
		}
		this->bcreate = true;
	}
	T insert(const T item) {
		if (inodenum >= ic) {
			return NULL;
		}
		nodearr[++inodenum] = item;
		swim(inodenum);
		return item;
	}
	T getMax() {
		return nodearr[1];
	}
	T delMax() {
		T max = NULL;
		if (inodenum) {
			max = nodearr[1];
			nodearr[1] = nodearr[inodenum--];
			nodearr[inodenum + 1] = NULL;
			sink(1);
		}
		return max;
	}
	void clear() {
		for (int i = 0; i < ic; i++) {
			nodearr[i + 1] = NULL;
		}
		inodenum = 0;
	}
	int capacity() const {
		return ic;
	}
	int nodenum() const {
		return inodenum;
	}
	void swim(int inode) {
		if (0 < inode / 2 && nodearr[inode / 2] < nodearr[inode]) {
			swap(inode / 2, inode);
			swim(inode / 2);
		}
	}
	void sink(int inode) {
		if (inode * 2 < inodenum && nodearr[inode * 2] >= nodearr[inode] && (inode * 2 + 1 >= inodenum || nodearr[inode * 2] >= nodearr[inode * 2 + 1])) {
			swap(inode * 2, inode);
			sink(inode * 2);
		}
		else if (inode * 2 + 1 < inodenum && nodearr[inode * 2 + 1] >= nodearr[inode] && nodearr[inode * 2] <= nodearr[inode * 2 + 1]) {
			swap(inode * 2 + 1, inode);
			sink(inode * 2 + 1);
		}
	}
	void printheap(void (*printfun)(T, bool)) {
		for (int i = 0; i < ic; i++) {
			printfun(nodearr[i + 1], i + 1 != ic);
		}
	}
	~myheap() {
		delete[] nodearr;
	}
};
//meiri.cpp
#include <iostream>
#include "myheap.hpp"
using namespace std;

void print(int i, bool b) {
	cout << i;
	if (b) {
		cout << ", ";
	}
	else {
		cout << endl;
	}
}

int main() {
	int arr[5] = { 1, 2, 3, 4, 5 };
	myheap<int>ha(arr, 5);
	myheap<int>h = ha;
	myheap<int>hb(3);
	hb = h;
	h.printheap(print);
	hb.printheap(print);
	cout << h.getMax() << ", " << (h.getMax() == h.delMax()) << endl;
	cout << h.capacity() << ", " << h.nodenum() << ", " << h.delMax() << endl;
	h.clear();
	cout << h.nodenum() << endl;
	return 0;
}
*///已基本测试了myheap堆的有参构造方法，拷贝构造方法，赋值运算符，printheap方法，getMax方法，delMax方法，capacity方法，insert方法，swim方法，sink方法，nodenum方法和clear方法，并修正了这些方法中的大多数^
/*
#include <iostream>
using namespace std;
int main() {
	int ia = 5;
	int ib = 3;
	bool bifs[3] = { ib < ia, 5 == ia, 4 > ib };
	for (int i = 0; i < 3; i++) {
		switch ((!bifs[i]) * 3 + i) {
		case 0:
			cout << "0" << endl;
			i = 3;
			break;
		case 1:
			cout << "1" << endl;
			i = 3;
			break;
		case 2:
			cout << "2" << endl;
			i = 3;
			break;
		default:
			break;
		}
	}
	return 0;
}
*///奇怪的用switch语句代替if-else语句的程序^
/*
//myheap.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myheap {
private:
	int ic;
	int inodenum;
	T* nodearr;
	bool bcreate;
	void swap(const int nodea, const int nodeb) {
		int nodetemp = nodearr[nodea];
		nodearr[nodea] = nodearr[nodeb];
		nodearr[nodeb] = nodetemp;
	}
public:
	myheap(const int icapacity) {
		this->bcreate = false;
		this->ic = icapacity;
		this->inodenum = 0;
		this->nodearr = new T[icapacity + 1];
		for (int i = 1; i <= this->ic; i++) {
			nodearr[i] = 0;
		}
	}
	myheap(const T tarr[], const int ihas) {
		this->bcreate = false;
		this->ic = ihas;
		this->inodenum = 0;
		this->nodearr = new T[ic + 1];
		for (int i = 0; i < ihas; i++) {
			this->insert(tarr[i]);
		}
	}
	myheap(myheap& heap) {
		this->bcreate = false;
		*this = heap;
	}
	void operator=(myheap& heap) {
		if (this->bcreate) {
			this->clear();
			delete[] this->nodearr;
		}
		this->ic = heap.ic;
		this->inodenum = heap.inodenum;
		this->nodearr = new T[ic + 1];
		for (int i = 0; i < this->ic; i++) {
			this->nodearr[i + 1] = heap.nodearr[i + 1];
		}
		this->bcreate = true;
	}
	T insert(const T item) {
		if (inodenum >= ic) {
			return NULL;
		}
		nodearr[++inodenum] = item;
		swim(inodenum);
		return item;
	}
	T getMax() {
		return nodearr[1];
	}
	T delMax() {
		T max = NULL;
		if (inodenum) {
			max = nodearr[1];
			nodearr[1] = nodearr[inodenum--];
			nodearr[inodenum + 1] = NULL;
			sink(1);
		}
		return max;
	}
	void clear() {
		for (int i = 0; i < ic; i++) {
			nodearr[i + 1] = NULL;
		}
		inodenum = 0;
	}
	int capacity() const {
		return ic;
	}
	int nodenum() const {
		return inodenum;
	}
	void swim(int inode) {
		if (0 < inode / 2 && nodearr[inode / 2] < nodearr[inode]) {
			swap(inode / 2, inode);
			swim(inode / 2);
		}
	}
	void sink(int inode) {
		if (inode * 2 < inodenum && nodearr[inode * 2] >= nodearr[inode] && (inode * 2 + 1 >= inodenum || nodearr[inode * 2] >= nodearr[inode * 2 + 1])) {
			swap(inode * 2, inode);
			sink(inode * 2);
		}
		else if (inode * 2 + 1 < inodenum && nodearr[inode * 2 + 1] >= nodearr[inode] && nodearr[inode * 2] <= nodearr[inode * 2 + 1]) {
			swap(inode * 2 + 1, inode);
			sink(inode * 2 + 1);
		}
	}
	void printheap(void (*printfun)(T, bool)) {
		for (int i = 0; i < ic; i++) {
			printfun(nodearr[i + 1], i + 1 != ic);
		}
	}
	~myheap() {
		delete[] nodearr;
	}
};
//meiri.cpp
#include <iostream>
#include "myheap.hpp"
using namespace std;

void print(int i, bool b) {
	cout << i;
	if (b) {
		cout << ", ";
	}
	else {
		cout << endl;
	}
}

int main() {
	myheap<int>h(1);
	cout << h.getMax() << endl;
    cout << h.delMax() << endl;
	for (int i = 1; i <= 2; i++) {
		cout << h.insert(i) << " ";
	}
	cout << endl;
	return 0;
}
*///已测试myheap堆的按容量构造的构造方法，getMax方法，delMax方法和insert方法的安全性，并修正了按容量构造的构造方法的实现^
/*
//myheap.hpp
#pragma once
#include <iostream>
using namespace std;
template<class T>
class myheap {
private:
	int ic;
	int inodenum;
	T* nodearr;
	bool bcreate;
	T* sortarr;
	void swap(const int nodea, const int nodeb) {
		int nodetemp = nodearr[nodea];
		nodearr[nodea] = nodearr[nodeb];
		nodearr[nodeb] = nodetemp;
	}
public:
	myheap(const int icapacity) {
		this->bcreate = false;
		this->ic = icapacity;
		this->inodenum = 0;
		this->nodearr = new T[icapacity + 1];
		this->sortarr = new T[icapacity];
		for (int i = 1; i <= this->ic; i++) {
			nodearr[i] = 0;
		}
	}
	myheap(const T tarr[], const int ihas) {
		this->bcreate = false;
		this->ic = ihas;
		this->inodenum = 0;
		this->nodearr = new T[this->ic + 1];
		this->sortarr = new T[this->ic];
		for (int i = 0; i < ihas; i++) {
			this->insert(tarr[i]);
		}
	}
	myheap(myheap& heap) {
		this->bcreate = false;
		*this = heap;
	}
	void operator=(myheap& heap) {
		if (this->bcreate) {
			this->clear();
			delete[] this->nodearr;
		}
		this->ic = heap.ic;
		this->inodenum = heap.inodenum;
		this->nodearr = new T[this->ic + 1];
		this->sortarr = new T[this->ic];
		for (int i = 0; i < this->ic; i++) {
			this->nodearr[i + 1] = heap.nodearr[i + 1];
		}
		this->bcreate = true;
	}
	T insert(const T item) {
		if (inodenum >= ic) {
			return NULL;
		}
		nodearr[++inodenum] = item;
		swim(inodenum);
		return item;
	}
	T getMax() {
		return nodearr[1];
	}
	T delMax() {
		T max = NULL;
		if (inodenum) {
			max = nodearr[1];
			nodearr[1] = nodearr[inodenum--];
			nodearr[inodenum + 1] = NULL;
			sink(1);
		}
		return max;
	}
	void clear() {
		for (int i = 0; i < ic; i++) {
			nodearr[i + 1] = NULL;
		}
		inodenum = 0;
	}
	int capacity() const {
		return ic;
	}
	int nodenum() const {
		return inodenum;
	}
	void swim(int inode) {
		if (0 < inode / 2 && nodearr[inode / 2] < nodearr[inode]) {
			swap(inode / 2, inode);
			swim(inode / 2);
		}
	}
	void sink(int inode) {
		if (inode * 2 <= inodenum && nodearr[inode * 2] >= nodearr[inode] && (inode * 2 + 1 > inodenum || nodearr[inode * 2] >= nodearr[inode * 2 + 1])) {
			swap(inode * 2, inode);
			sink(inode * 2);
		}
		else if (inode * 2 + 1 <= inodenum && nodearr[inode * 2 + 1] >= nodearr[inode] && nodearr[inode * 2] <= nodearr[inode * 2 + 1]) {
			swap(inode * 2 + 1, inode);
			sink(inode * 2 + 1);
		}
	}
	void printheap(void (*printfun)(T, bool)) {
		for (int i = 0; i < ic; i++) {
			printfun(nodearr[i + 1], i + 1 != ic);
		}
	}
	T*& heapsort() {
		myheap<T> sortheap = *this;
		int i = 0;
		while (sortheap.nodenum()) {
			this->sortarr[i++] = sortheap.delMax();
		}
		return this->sortarr;
	}
	~myheap() {
		delete[] nodearr;
		delete[] sortarr;
	}
};
//meiri.cpp
#include <iostream>
#include "myheap.hpp"
using namespace std;

void print(int* arr, int isize, int i = 0) {
	if (i < isize) {
		cout << arr[i];
		if (i < isize - 1) {
			cout << ", ";
		}
		print(arr, isize, i + 1);
	}
}

void print(int i, bool isNotEnd) {
	cout << i;
	if (isNotEnd) {
		cout << ", ";
	}
	else {
		cout << endl;
	}
}

int main() {
	int arr[5] = { 1, 2, 3, 4, -6 };
	myheap<int>h(arr, 5);
	h.printheap(print);
	int* sortarr = h.heapsort();
	print(sortarr, 5);
	return 0;
}
*///已新建，测试并修正了heapsort方法^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
		}
	};
	node* root;
	int nodenf;
	void insert(T t, node** rootf) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node;
					(*rootf)->right->set(t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node;
					(*rootf)->left->set(t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left);
				}
			}
		}
	}
public:
	myRedBlackTree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void operator=(myRedBlackTree& ml) {
		queue<node*>q;
		node* addnode = nullptr;
		q.push(ml.root);
		while (q.size()) {
			addnode = q.front();
			if (nullptr != addnode->left) {
				q.push(addnode->left);
			}
			if (nullptr != addnode->right) {
				q.push(addnode->right);
			}
			this->insert(q.front()->t);
			q.pop();
		}
	}
	void clear() {

	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已创建myRedBlackTree.hpp类文件^
/*
//myRedBlacktree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		void set() {
			this->t = NULL;
			this->left = nullptr;
			this->right = nullptr;
			this->isRed = true;
		}
		void set(T tf, node* leftf = nullptr, node* rightf = nullptr, bool isRed = true) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int nodenf;
	void insert(T t, node** rootf) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node;
					(*rootf)->right->set(t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node;
					(*rootf)->left->set(t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left);
				}
			}
		}
	}
public:
	myRedBlackTree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void operator=(myRedBlackTree& ml) {
		queue<node*>q;
		node* addnode = nullptr;
		q.push(ml.root);
		while (q.size()) {
			addnode = q.front();
			if (nullptr != addnode->left) {
				q.push(addnode->left);
			}
			if (nullptr != addnode->right) {
				q.push(addnode->right);
			}
			this->insert(q.front()->t);
			q.pop();
		}
	}
	void clear() {

	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已修正myRedBlackTree红黑树node节点的set方法及set的重载方法^
/*
//mylist2.hpp
#pragma once
#include <iostream>
using namespace std;
template<class T>
class mylist {
private:
	class node {
	public:
		T t;
		node* next;
		node(T t = NULL, node* next = nullptr) {
			this->t = t;
			this->next = next;
		}
	};
	int ic;
	node* head;
	void deletenode(node*& delnode) {
		if (nullptr != delnode->next) {
			deletenode(delnode->next);
		}
		delnode->next = nullptr;
		delete delnode;
	}
public:
	mylist() {
		this->ic = 0;
		this->head = new node;
	}
	mylist(T[] arr, int isize) {
		this->ic = 0;
		this->head = new node;
		node*& addnode = this->head;
		for (int i = 0; i < isize; i++) {
			addnode->next = new node(arr[i]);
			addnode = addnode->next;
		}
	}
	mylist(const mylist& list) {
		this->ic = 0;
		this->head = new node;
		*this = list;
	}
	mylist& operator=(const mylist& list) {
		node* searchnode = list.head;
		node*& addnode = this->head;
		while (nullptr != searchnode->next) {
			searchnode = searchnode->next;
			addnode->next = new node(searchnode->t);
			addnode = addnode->next;
		}
	}
	~mylist() {
		deletenode(this->head);
	}
	T push_back(const T item) {
		node*& addnode = this->head;
		while (nullptr != addnode->next) {
			addnode = addnode->next;
		}
		addnode->next = new node(item);
		this->ic++;
		return item;
	}
	T insert(const T item, unsigned int index) {
		if (index >= this->ic) {
			return NULL;
		}
		node*& addnode = this->head;
		while (index--) {
			addnode = addnode->next;
		}
		node* newnode = new node(item, addnode->next);
		addnode->next = newnode;
		this->ic++;
	}
	T del_back() {
		if (this->ic) {
			return NULL;
		}
		node*& nextIsTailNode = this->head;
		while (nullptr != nextIsTailNode->next->next) {
			nextIsTailNode = nextIsTailNode->next;
		}
		T last = nextIsTailNode->next->t;
		delete nextIsTailNode->next;
		nextIsTailNode->next = nullptr;
		this->ic--;
		return last;
	}
	T del_index(unsigned int index) {
		if (this->ic && index >= this->ic) {
			return NULL;
		}
		node*& searchnode = this->head;
		while (index--) {
			searchnode = searchnode->next;
		}
		T item = searchnode->next->t;
		node* hasnode = searchnode->next->next;
		delete searchnode->next;
		searchnode->next = hasnode;
		this->ic--;
		return item;
	}
};
*///链表新做^
/*
//mylist2.hpp
#pragma once
#include <iostream>
using namespace std;
template<class T>
class mylist {
private:
	class node {
	public:
		T t;
		node* next;
		node(const T t = NULL, const node* next = nullptr) {
			this->t = t;
			this->next = next;
		}
	};
	int ic;
	node* head;
	void deletenode(node*& delnode) {
		if (nullptr != delnode->next) {
			deletenode(delnode->next);
		}
		delnode->next = nullptr;
		delete delnode;
	}
public:
	mylist() {
		this->ic = 0;
		this->head = new node;
	}
	mylist(T[] arr, int isize) {
		this->ic = 0;
		this->head = new node;
		node*& addnode = this->head;
		for (int i = 0; i < isize; i++) {
			addnode->next = new node(arr[i]);
			addnode = addnode->next;
		}
	}
	mylist(const mylist& list) {
		this->ic = 0;
		this->head = new node;
		*this = list;
	}
	mylist& operator=(const mylist& list) {
		node* searchnode = list.head;
		node*& addnode = this->head;
		while (nullptr != searchnode->next) {
			searchnode = searchnode->next;
			addnode->next = new node(searchnode->t);
			addnode = addnode->next;
		}
	}
	~mylist() {
		deletenode(this->head);
	}
	T push_back(const T item) {
		node*& addnode = this->head;
		while (nullptr != addnode->next) {
			addnode = addnode->next;
		}
		addnode->next = new node(item);
		this->ic++;
		return item;
	}
	T insert(const T item, const unsigned int index) {
		if (index >= this->ic) {
			return NULL;
		}
		node*& addnode = this->head;
		while (index--) {
			addnode = addnode->next;
		}
		node* newnode = new node(item, addnode->next);
		addnode->next = newnode;
		this->ic++;
	}
	T del_back() {
		if (this->ic) {
			return NULL;
		}
		node*& nextIsTailNode = this->head;
		while (nullptr != nextIsTailNode->next->next) {
			nextIsTailNode = nextIsTailNode->next;
		}
		T last = nextIsTailNode->next->t;
		delete nextIsTailNode->next;
		nextIsTailNode->next = nullptr;
		this->ic--;
		return last;
	}
	T del_index(const unsigned int index) {
		if (this->ic && index >= this->ic) {
			return NULL;
		}
		node*& searchnode = this->head;
		while (index--) {
			searchnode = searchnode->next;
		}
		T item = searchnode->next->t;
		node* hasnode = searchnode->next->next;
		delete searchnode->next;
		searchnode->next = hasnode;
		this->ic--;
		return item;
	}
};
*///增加某些成员方法的鲁棒性^
/*
//mylist2.hpp
#pragma once
#include <iostream>
using namespace std;
template<class T>
class mylist {
private:
	class node {
	public:
		T t;
		node* next;
		node(const T t = NULL, node* nextTo = nullptr) {
			this->t = t;
			this->next = nextTo;
		}
	};
	unsigned int ic;
	node* head;
	void deletenode(node*& delnode) {
		if (nullptr != delnode->next) {
			deletenode(delnode->next);
		}
		delnode->next = nullptr;
		delete delnode;
	}
	T* arr;
public:
	mylist() {
		this->ic = 0;
		this->head = new node;
		this->arr = new T[0];
	}
	mylist(T* arr, const unsigned int isize) {
		this->ic = 0;
		this->head = new node;
		node*& addnode = this->head;
		this->arr = new T[0];
		for (int i = 0; i < isize; i++) {
			addnode->next = new node(arr[i]);
			addnode = addnode->next;
		}
	}
	mylist(const mylist& list) {
		this->ic = 0;
		this->head = new node;
		this->arr = new T[0];
		*this = list;
	}
	mylist& operator=(const mylist& list) {
		node* searchnode = list.head;
		node*& addnode = this->head;
		while (nullptr != searchnode->next) {
			searchnode = searchnode->next;
			addnode->next = new node(searchnode->t);
			addnode = addnode->next;
		}
	}
	T push_back(const T item) {
		node*& addnode = this->head;
		while (nullptr != addnode->next) {
			addnode = addnode->next;
		}
		addnode->next = new node(item);
		this->ic++;
		return item;
	}
	T insert(const T item, const unsigned int index) {
		if (index >= this->ic) {
			return NULL;
		}
		node*& addnode = this->head;
		while (index--) {
			addnode = addnode->next;
		}
		node* newnode = new node(item, addnode->next);
		addnode->next = newnode;
		this->ic++;
	}
	T del_back() {
		if (this->ic) {
			return NULL;
		}
		node*& nextIsTailNode = this->head;
		while (nullptr != nextIsTailNode->next->next) {
			nextIsTailNode = nextIsTailNode->next;
		}
		T last = nextIsTailNode->next->t;
		delete nextIsTailNode->next;
		nextIsTailNode->next = nullptr;
		this->ic--;
		return last;
	}
	T del_index(const unsigned int index) {
		if (this->ic && index >= this->ic) {
			return NULL;
		}
		node*& searchnode = this->head;
		while (index--) {
			searchnode = searchnode->next;
		}
		T item = searchnode->next->t;
		node* hasnode = searchnode->next->next;
		delete searchnode->next;
		searchnode->next = hasnode;
		this->ic--;
		return item;
	}
	void clear() {
		if (this->ic) {
			this->ic = 0;
			deletenode(this->head->next);
		}
	}
	T& operator[](const unsigned int index) {
		if (index >= this->ic) {
			return NULL;
		}
		node* searchnode = this->head->next;
		while (index--) {
			searchnode = searchnode->next;
		}
		return searchnode->t;
	}
	T& at(const unsigned int index) {
		return *this[index];
	}
	const T* toArray() {
		delete[] this->arr;
		this->arr = new T[this->ic];
		node* searchnode = this->head;
		int i = 0;
		while (nullptr != searchnode->next) {
			searchnode = searchnode->next;
			this->arr[i++];
		}
		return this->arr;
	}
	long long indexOf(const T item) {
		node* searchnode = this->head;
		unsigned int index = 0;
		while (nullptr != searchnode->next) {
			searchnode = searchnode->next;
			if (item == searchnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	bool isEmpty() const {
		return 0 == this->ic;
	}
	unsigned int size() const {
		return this->ic;
	}
	~mylist() {
		deletenode(this->head);
		delete[] this->arr;
	}
};
*///clear方法已新建并实现^
/*
//mylist2.hpp
#pragma once
#include <iostream>
using namespace std;
template<class T>
class mylist {
private:
	class node {
	public:
		T t;
		node* next;
		node(const T t = NULL, node* nextTo = nullptr) {
			this->t = t;
			this->next = nextTo;
		}
	};
	unsigned int ic;
	node* head;
	void deletenode(node*& delnode) {
		if (nullptr != delnode->next) {
			deletenode(delnode->next);
		}
		delnode->next = nullptr;
		delete delnode;
	}
	T* arr;
public:
	mylist() {
		this->ic = 0;
		this->head = new node;
		this->arr = new T[0];
	}
	mylist(T* arr, const unsigned int isize) {
		this->ic = 0;
		this->head = new node;
		node*& addnode = this->head;
		this->arr = new T[0];
		for (int i = 0; i < isize; i++) {
			addnode->next = new node(arr[i]);
			addnode = addnode->next;
		}
	}
	mylist(const mylist& list) {
		this->ic = 0;
		this->head = new node;
		this->arr = new T[0];
		*this = list;
	}
	mylist& operator=(const mylist& list) {
		node* searchnode = list.head;
		node*& addnode = this->head;
		while (nullptr != searchnode->next) {
			searchnode = searchnode->next;
			addnode->next = new node(searchnode->t);
			addnode = addnode->next;
		}
		return *this;
	}
	T push_back(const T item) {
		node*& addnode = this->head;
		while (nullptr != addnode->next) {
			addnode = addnode->next;
		}
		addnode->next = new node(item);
		this->ic++;
		return item;
	}
	T insert(const T item, unsigned int index) {
		if (index >= this->ic) {
			return NULL;
		}
		node*& addnode = this->head;
		while (index--) {
			addnode = addnode->next;
		}
		node* newnode = new node(item, addnode->next);
		addnode->next = newnode;
		this->ic++;
	}
	T del_back() {
		if (!this->ic) {
			return NULL;
		}
		node*& nextIsTailNode = this->head;
		while (nullptr != nextIsTailNode->next->next) {
			nextIsTailNode = nextIsTailNode->next;
		}
		T last = nextIsTailNode->next->t;
		delete nextIsTailNode->next;
		nextIsTailNode->next = nullptr;
		this->ic--;
		return last;
	}
	T del_index(unsigned int index) {
		if (!this->ic || index >= this->ic) {
			return NULL;
		}
		node*& searchnode = this->head;
		while (index--) {
			searchnode = searchnode->next;
		}
		T item = searchnode->next->t;
		node* hasnode = searchnode->next->next;
		delete searchnode->next;
		searchnode->next = hasnode;
		this->ic--;
		return item;
	}
	void clear() {
		if (this->ic) {
			this->ic = 0;
			deletenode(this->head->next);
		}
	}
	T& operator[](unsigned int index) {
		if (index >= this->ic) {
			static T nulldata = NULL;
			return nulldata;
		}
		node* searchnode = this->head->next;
		while (index--) {
			searchnode = searchnode->next;
		}
		return searchnode->t;
	}
	T& at(const unsigned int index) {
		return (*this)[index];
	}
	const T* toArray() {
		delete[] this->arr;
		this->arr = new T[this->ic];
		node* searchnode = this->head;
		int i = 0;
		while (nullptr != searchnode->next) {
			searchnode = searchnode->next;
			this->arr[i++];
		}
		return this->arr;
	}
	long long indexOf(const T item) {
		node* searchnode = this->head;
		unsigned int index = 0;
		while (nullptr != searchnode->next) {
			searchnode = searchnode->next;
			if (item == searchnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	bool isEmpty() const {
		return 0 == this->ic;
	}
	unsigned int size() const {
		return this->ic;
	}
	~mylist() {
		deletenode(this->head);
		delete[] this->arr;
	}
};
*///一些bug已修复^
/*
//meiri.cpp
#pragma once
#include <iostream>
using namespace std;
template<class T>
class mylist {
private:
	class node {
	public:
		T t;
		node* next;
		node(const T t = NULL, node* nextTo = nullptr) {
			this->t = t;
			this->next = nextTo;
		}
	};
	unsigned int ic;
	node* head;
	void deletenode(node*& delnode) {
		if (nullptr != delnode->next) {
			deletenode(delnode->next);
		}
		delnode->next = nullptr;
		delete delnode;
	}
	T* arr;
public:
	mylist() {
		this->ic = 0;
		this->head = new node;
		this->arr = new T[0];
	}
	mylist(T* array, const unsigned int isize) {
		this->ic = isize;
		this->head = new node;
		node** addnode = &this->head;
		this->arr = new T[0];
		for (int i = 0; i < isize; i++) {
			(*addnode)->next = new node(array[i]);
			addnode = &(*addnode)->next;
		}
	}
	mylist(const mylist& list) {
		this->ic = list.ic;
		this->head = new node;
		this->arr = new T[0];
		*this = list;
	}
	mylist& operator=(const mylist& list) {
		node* searchnode = list.head;
		node** addnode = &this->head;
		while (nullptr != searchnode->next) {
			searchnode = searchnode->next;
			(*addnode)->next = new node(searchnode->t);
			addnode = &(*addnode)->next;
		}
		return *this;
	}
	~mylist() {
		deletenode(this->head);
		delete[] this->arr;
	}
	T push_back(const T item) {
		node** addnode = &this->head;
		while (nullptr != (*addnode)->next) {
			addnode = &(*addnode)->next;
		}
		(*addnode)->next = new node(item);
		this->ic++;
		return item;
	}
	T insert(const T item, unsigned int index) {
		if (index >= this->ic) {
			return NULL;
		}
		node** addnode = &this->head;
		while (index--) {
			addnode = &(*addnode)->next;
		}
		node* newnode = new node(item, (*addnode)->next);
		(*addnode)->next = newnode;
		this->ic++;
	}
	T del_back() {
		if (!this->ic) {
			return NULL;
		}
		node** nextIsTailNode = &this->head;
		while (nullptr != (*nextIsTailNode)->next->next) {
			nextIsTailNode = &(*nextIsTailNode)->next;
		}
		T last = (*nextIsTailNode)->next->t;
		delete (*nextIsTailNode)->next;
		(*nextIsTailNode)->next = nullptr;
		this->ic--;
		return last;
	}
	T del_index(unsigned int index) {
		if (!this->ic || index >= this->ic) {
			return NULL;
		}
		node** searchnode = &this->head;
		while (index--) {
			searchnode = &(*searchnode)->next;
		}
		T item = (*searchnode)->next->t;
		node* hasnode = (*searchnode)->next->next;
		delete (*searchnode)->next;
		(*searchnode)->next = hasnode;
		this->ic--;
		return item;
	}
	void clear() {
		if (this->ic) {
			this->ic = 0;
			deletenode(this->head->next);
			this->head->next = nullptr;
		}
	}
	T& operator[](unsigned int index) {
		if (index >= this->ic) {
			static T nulldata = NULL;
			return nulldata;
		}
		node* searchnode = this->head->next;
		while (index--) {
			searchnode = searchnode->next;
		}
		return searchnode->t;
	}
	T& at(const unsigned int index) {
		return (*this)[index];
	}
	T*& toArray() {
 		delete[] this->arr;
		this->arr = new T[this->ic];
		node* searchnode = this->head;
		int i = 0;
		while (nullptr != searchnode->next) {
			searchnode = searchnode->next;
			this->arr[i++] = searchnode->t;
		}
		return this->arr;
	}
	long long indexOf(const T item) {
		node* searchnode = this->head;
		unsigned int index = 0;
		while (nullptr != searchnode->next) {
			searchnode = searchnode->next;
			if (item == searchnode->t) {
				return index;
			}
			index++;
		}
		return -1;
	}
	bool isEmpty() const {
		return 0 == this->ic;
	}
	unsigned int size() const {
		return this->ic;
	}
};
*///新链表完成后的链表类^
/*
//meiri.cpp
#include <iostream>
#include "mylist2.hpp"
using namespace std;

int main() {
	mylist<int>m;
	cout << "原始大小：" << m.size() << "    是否为空：" << (m.isEmpty() ? "true" : "false") << endl;
	m.insert(1, 0);
	m.push_back(1);
	m.push_back(2);
	m.insert(3, 1);
	cout << "链表m增加数据后大小：" << m.size() << "    是否为空：" << (m.isEmpty() ? "true" : "false") << endl;
	m.del_back();
	m.del_index(2);
	m.del_index(1);
	cout << "链表m删除数据后大小：" << m.size() << "    是否为空：" << (m.isEmpty() ? "true" : "false") << endl;
	int arr[5] = { 1, 2, 3, 4, 5 };
	mylist<int>ma(arr, 5);
	mylist<int>mb = ma;
	const int* arra = ma.toArray();
	const int* arrb = mb.toArray();
	int i = 0;
	while (i < 5) {
		cout << "ma[" << i << "] == mb[" << i << "]：" << (arra[i] == arrb[i] ? "true" : "false") << endl;
		i++;
	}
	cout << "ma[1] = " << ma[1] << "    ma[3] == ma.at(3)：" << (ma[3] == ma.at(3) ? "true" : "false") << endl;
	cout << "5 == ma[ma.indexOf(5)]：" << (5 == ma[ma.indexOf(5)] ? "true" : "false") << endl;
	cout << "ma.indexOf(7) = " << ma.indexOf(7) << "    NULL == ma[-1]：" << (NULL == ma[-1] ? "true" : "false") << endl;
	m.clear();
	cout << "链表m清空数据后大小：" << m.size() << "    是否为空：" << (m.isEmpty() ? "true" : "false") << endl;
	return 0;
}
*///新链表完成之后用于测试的测试代码^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(T tf = NULL, bool isRed = true, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int nodenf;
	void insert(T t, node** rootf) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left);
				}
			}
		}
	}
	void leftTurn(node** turnnode) {

	}
	void rightTurn(node** turnnode) {

	}
	void filpColours(node** filpnode) {

	}
public:
	myRedBlackTree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void operator=(myRedBlackTree& ml) {
		queue<node*>q;
		node* addnode = nullptr;
		q.push(ml.root);
		while (q.size()) {
			addnode = q.front();
			if (nullptr != addnode->left) {
				q.push(addnode->left);
			}
			if (nullptr != addnode->right) {
				q.push(addnode->right);
			}
			this->insert(q.front()->t);
			q.pop();
		}
	}
	void clear() {

	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已新建leftTurn方法，rightTurn方法，filpColours方法和节点类的构造方法，并删除了原有的set方法，修正了insert方法的实现^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(T tf = NULL, bool isRed = true, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int nodenf;
	void insert(T t, node** rootf) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left);
				}
			}
		}
	}
	void leftTurn(node** turnnode) {
		//node* midnode = (*turnnode)->right->left;
		//node* rightnode = (*turnnode)->right;
		//(*turnnode)->right = midnode;
		//(*turnnode)->isRed = true;

	}
	void rightTurn(node** turnnode) {

	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
public:
	myRedBlackTree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void operator=(myRedBlackTree& ml) {
		queue<node*>q;
		node* addnode = nullptr;
		q.push(ml.root);
		while (q.size()) {
			addnode = q.front();
			if (nullptr != addnode->left) {
				q.push(addnode->left);
			}
			if (nullptr != addnode->right) {
				q.push(addnode->right);
			}
			this->insert(q.front()->t);
			q.pop();
		}
	}
	void clear() {

	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已实现filpcolours方法^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(T tf = NULL, bool isRed = true, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int nodenf;
	void insert(T t, node** rootf) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left);
				}
			}
		}
	}
	void leftTurn(node** turnnode) {
		T tempitem = turnnode->t;
		turnnode->t = turnnode->right->t;
		turnnode->right->t = tempitem;
		node* maxnode = turnnode->right->right;
		turnnode->left = turnnode->right;
		delete turnnode->right;
		node* tempnode = turnnode->left->left;
		turnnode->left->left = turnnode->left->right;
		turnnode->left->right = tempnode;
		turnnode->right = maxnode;
	}
	void rightTurn(node** turnnode) {

	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
public:
	myRedBlackTree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void operator=(myRedBlackTree& ml) {
		queue<node*>q;
		node* addnode = nullptr;
		q.push(ml.root);
		while (q.size()) {
			addnode = q.front();
			if (nullptr != addnode->left) {
				q.push(addnode->left);
			}
			if (nullptr != addnode->right) {
				q.push(addnode->right);
			}
			this->insert(q.front()->t);
			q.pop();
		}
	}
	void clear() {

	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///红黑树myRedBlackTree的leftTurn方法已实现^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(T tf = NULL, bool isRed = true, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int nodenf;
	void insert(T t, node** rootf) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left);
				}
			}
		}
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap(turnnode->t, turnnode->right->t);
		node* maxnode = turnnode->right->right;
		turnnode->left = turnnode->right;
		delete turnnode->right;
		this->swap(turnnode->left->left, turnnode->left->right);
		turnnode->right = maxnode;
	}
	void rightTurn(node** turnnode) {

	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
public:
	myRedBlackTree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void operator=(myRedBlackTree& ml) {
		queue<node*>q;
		node* addnode = nullptr;
		q.push(ml.root);
		while (q.size()) {
			addnode = q.front();
			if (nullptr != addnode->left) {
				q.push(addnode->left);
			}
			if (nullptr != addnode->right) {
				q.push(addnode->right);
			}
			this->insert(q.front()->t);
			q.pop();
		}
	}
	void clear() {

	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已新建并实现swap私有方法，并简化了leftTurn方法的实现^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(T tf = NULL, bool isRed = true, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int nodenf;
	void insert(T t, node** rootf) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left);
				}
			}
		}
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap(turnnode->t, turnnode->right->t);
		node* maxnode = turnnode->right->right;
		turnnode->left = turnnode->right;
		delete turnnode->right;
		this->swap(turnnode->left->left, turnnode->left->right);
		turnnode->right = maxnode;
	}
	void rightTurn(node** turnnode) {
		this->swap(turnnode->t, turnnode->left->t);
		node* minnode = turnnode->left->left;
		turnnode->right = turnnode->left;
		delete turnnode->left;
		this->swap(turnnode->right->left, turnnode->right->right);
		turnnode->left = minnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
public:
	myRedBlackTree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void operator=(myRedBlackTree& ml) {
		queue<node*>q;
		node* addnode = nullptr;
		q.push(ml.root);
		while (q.size()) {
			addnode = q.front();
			if (nullptr != addnode->left) {
				q.push(addnode->left);
			}
			if (nullptr != addnode->right) {
				q.push(addnode->right);
			}
			this->insert(q.front()->t);
			q.pop();
		}
	}
	void clear() {

	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已实现红黑树myRedBlackTree的rightTurn方法^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(T tf = NULL, bool isRed = true, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int nodenf;
	void insert(T t, node** rootf) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left);
				}
			}
		}
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap(turnnode->t, turnnode->right->t);
		node* maxnode = turnnode->right->right;
		turnnode->left = turnnode->right;
		delete turnnode->right;
		this->swap(turnnode->left->left, turnnode->left->right);
		turnnode->right = maxnode;
	}
	void rightTurn(node** turnnode) {
		this->swap(turnnode->t, turnnode->left->t);
		node* minnode = turnnode->left->left;
		turnnode->right = turnnode->left;
		delete turnnode->left;
		this->swap(turnnode->right->left, turnnode->right->right);
		turnnode->left = minnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
public:
	myRedBlackTree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void operator=(myRedBlackTree& ml) {
		queue<node*>q;
		node* addnode = nullptr;
		q.push(ml.root);
		while (q.size()) {
			addnode = q.front();
			if (nullptr != addnode->left) {
				q.push(addnode->left);
			}
			if (nullptr != addnode->right) {
				q.push(addnode->right);
			}
			this->insert(q.front()->t);
			q.pop();
		}
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已实现红黑树myRedBlackTree的clear方法^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(T tf = NULL, bool isRed = true, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int nodenf;
	void insert(T t, node** rootf) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left);
				}
			}
		}
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap(turnnode->t, turnnode->right->t);
		node* maxnode = turnnode->right->right;
		turnnode->left = turnnode->right;
		delete turnnode->right;
		this->swap(turnnode->left->left, turnnode->left->right);
		turnnode->right = maxnode;
	}
	void rightTurn(node** turnnode) {
		this->swap(turnnode->t, turnnode->left->t);
		node* minnode = turnnode->left->left;
		turnnode->right = turnnode->left;
		delete turnnode->left;
		this->swap(turnnode->right->left, turnnode->right->right);
		turnnode->left = minnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
	void getLRnode(node* node) {

	}
public:
	myRedBlackTree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void operator=(myRedBlackTree& ml) {
		queue<node*>q;
		node* addnode = nullptr;
		q.push(ml.root);
		while (q.size()) {
			addnode = q.front();
			if (nullptr != addnode->left) {
				q.push(addnode->left);
			}
			if (nullptr != addnode->right) {
				q.push(addnode->right);
			}
			this->insert(q.front()->t);
			q.pop();
		}
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已新建myRedBlackTree的getLRnode方法^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(T tf = NULL, bool isRed = true, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int nodenf;
	int iprints;
	void change(node* n) {
		
	}
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(t, true);
					ic++;

				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(t, true);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap(turnnode->t, turnnode->right->t);
		node* maxnode = turnnode->right->right;
		turnnode->left = turnnode->right;
		delete turnnode->right;
		this->swap(turnnode->left->left, turnnode->left->right);
		turnnode->right = maxnode;
	}
	void rightTurn(node** turnnode) {
		this->swap(turnnode->t, turnnode->left->t);
		node* minnode = turnnode->left->left;
		turnnode->right = turnnode->left;
		delete turnnode->left;
		this->swap(turnnode->right->left, turnnode->right->right);
		turnnode->left = minnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			this->getLRnode(node->left);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			this->getLRnode(node->right);
		}
	}
public:
	myRedBlackTree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void operator=(myRedBlackTree& ml) {
		queue<node*>q;
		node* addnode = nullptr;
		q.push(ml.root);
		while (q.size()) {
			addnode = q.front();
			if (nullptr != addnode->left) {
				q.push(addnode->left);
			}
			if (nullptr != addnode->right) {
				q.push(addnode->right);
			}
			this->insert(q.front()->t);
			q.pop();
		}
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已新建change方法，并修改了insert重载方法的参数^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(T tf = NULL, bool isRed = true, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int nodenf;
	int iprints;
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(t, true);
					ic++;
					leftTurn(rootf);
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(t, true);
					ic++;
					if ((*beforenode)->left->isRed){
						rightTurn(rootf)
					}
					filpColours(rootf);
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		delete (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		(*turnnode)->right = (*turnnode)->left;
		delete (*turnnode)->left;
		delete (*turnnode)->right->left;
		(*turnnode)->left = minnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			this->getLRnode(node->left);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			this->getLRnode(node->right);
		}
	}
public:
	myRedBlackTree() {
		root = new node;
		root->set();
		this->ic = 0;
		this->nodenf = 0;
		this->returnnode = nullptr;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void operator=(myRedBlackTree& ml) {
		queue<node*>q;
		node* addnode = nullptr;
		q.push(ml.root);
		while (q.size()) {
			addnode = q.front();
			if (nullptr != addnode->left) {
				q.push(addnode->left);
			}
			if (nullptr != addnode->right) {
				q.push(addnode->right);
			}
			this->insert(q.front()->t);
			q.pop();
		}
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已删除change方法，并完全实现了insert重载方法^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(T tf = NULL, bool isRed = true, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int nodenf;
	int iprints;
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(t, true);
					ic++;
					leftTurn(rootf);
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(t, true);
					ic++;
					if ((*beforenode)->left->isRed){
						rightTurn(rootf);
					}
					filpColours(rootf);
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		delete (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		(*turnnode)->right = (*turnnode)->left;
		delete (*turnnode)->left;
		delete (*turnnode)->right->left;
		(*turnnode)->left = minnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node;
		this->ic = 0;
		this->nodenf = 0;
	}
	myRedBlackTree(T* arr, int ihas) {

	}
	myRedBlackTree(myRedBlackTree& tree) {

	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///第一次修改之后的红黑树类实现^
/*
//meiri.cpp
#include <iostream>
#include "myRedbLackTree.hpp"
using namespace std;

void print(int item, bool isNotEnd) {
	cout << item;
	if (isNotEnd) {
		cout << ", ";
	}
	else {
		cout << endl;
	}
}

int main() {
	myRedBlackTree<int>m;
	for (int i = 0; i < 10; i++) {
		m.insert(i);
	}
	m.printtree(print);
	return 0;
}
*///第一次测试的代码^
/*
//myRedBalckTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(T tf = NULL, bool isRed = true, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int iprints;
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(t, true);
					ic++;
					leftTurn(rootf);
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(t, true);
					ic++;
					if ((*beforenode)->left->isRed){
						rightTurn(rootf);
					}
					filpColours(rootf);
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		delete (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		(*turnnode)->right = (*turnnode)->left;
		delete (*turnnode)->left;
		delete (*turnnode)->right->left;
		(*turnnode)->left = minnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node;
		this->ic = 0;
	}
	myRedBlackTree(T* arr, int ihas) {

	}
	myRedBlackTree(myRedBlackTree& tree) {

	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///多余成员变量已删除^
/*
//myRedBalckTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(bool isRed = true, T tf = NULL, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int iprints;
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(true, t);
					ic++;
					leftTurn(rootf);
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(true, t);
					ic++;
					if (nullptr != (*beforenode)->left->left && (*beforenode)->left->isRed && (*beforenode)->left->left->isRed){
						rightTurn(rootf);
					}
					filpColours(rootf);
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		delete (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		(*turnnode)->right = (*turnnode)->left;
		delete (*turnnode)->left;
		delete (*turnnode)->right->left;
		(*turnnode)->left = minnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
	}
	myRedBlackTree(T* arr, int ihas) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	myRedBlackTree(myRedBlackTree& tree) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已修改红黑树部分方法实现^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(bool isRed = true, T tf = NULL, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int iprints;
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(true, t);
					ic++;
					leftTurn(rootf);
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(true, t);
					ic++;
					if (nullptr != (*beforenode)->left->left && (*beforenode)->left->isRed && (*beforenode)->left->left->isRed){
						rightTurn(rootf);
					}
					filpColours(rootf);
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		(*turnnode)->right = (*turnnode)->left;
		delete (*turnnode)->left;
		delete (*turnnode)->right->left;
		(*turnnode)->left = minnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
	}
	myRedBlackTree(T* arr, int ihas) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	myRedBlackTree(myRedBlackTree& tree) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已修正红黑树leftTurn方法^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(bool isRed = true, T tf = NULL, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int iprints;
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(true, t);
					ic++;
					leftTurn(rootf);
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(true, t);
					ic++;
					if (nullptr != (*beforenode)->left->left && (*beforenode)->left->isRed && (*beforenode)->left->left->isRed){
						rightTurn(rootf);
					}
					filpColours(rootf);
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* minnode = (*turnnode)->left;
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
		(*turnnode)->left->left = minnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		node* maxnode = (*turnnode)->right;
		(*turnnode)->right = (*turnnode)->left;
		this->swap((*turnnode)->right->left, (*turnnode)->right->right);
		(*turnnode)->left = minnode;
		(*turnnode)->right->right = maxnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
	}
	myRedBlackTree(T* arr, int ihas) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	myRedBlackTree(myRedBlackTree& tree) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已修正红黑树的leftTurn和rightTurn方法^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(bool isRed = true, T tf = NULL, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int iprints;
	void check(node** nodea, node** beforenode) {
		if ((*nodea)->right->isRed) {
			leftTurn(nodea);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left->left && (*beforenode)->left->isRed && (*beforenode)->left->left->isRed) {
			rightTurn(nodea);
			filpColours(nodea);
		}
	}
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(true, t);
					ic++;
					check(rootf, beforenode);
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(true, t);
					ic++;
					check(rootf, beforenode);
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* minnode = (*turnnode)->left;
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
		(*turnnode)->left->left = minnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		node* maxnode = (*turnnode)->right;
		(*turnnode)->right = (*turnnode)->left;
		this->swap((*turnnode)->right->left, (*turnnode)->right->right);
		(*turnnode)->left = minnode;
		(*turnnode)->right->right = maxnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
	}
	myRedBlackTree(T* arr, int ihas) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	myRedBlackTree(myRedBlackTree& tree) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已新建并实现check方法，且修正好私有重载的insert方法^
/*
//meiri.cpp
#include <iostream>
#include "myRedbLackTree.hpp"
using namespace std;

void print(int item, bool isNotEnd) {
	cout << item;
	if (isNotEnd) {
		cout << ", ";
	}
	else {
		cout << endl;
	}
}

int main() {
	myRedBlackTree<int>m;
	for (int i = 10; i > 1; i--) {
		m.insert(i);
	}
	m.printtree(print);
	return 0;
}
*///已更换新的测试代码^
/*
//meiri.cpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(bool isRed = true, T tf = NULL, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int iprints;
	void check(node** nodea, node** beforenode) {
		if (nullptr != (*nodea)->right && (*nodea)->right->isRed) {
			leftTurn(nodea);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left->left && (*beforenode)->left->isRed && (*beforenode)->left->left->isRed) {
			rightTurn(beforenode);
			filpColours(beforenode);
		}
	}
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(true, t);
					ic++;
					check(rootf, beforenode);
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(true, t);
					ic++;
					check(rootf, beforenode);
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* minnode = (*turnnode)->left;
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
		(*turnnode)->left->left = minnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		node* maxnode = (*turnnode)->right;
		(*turnnode)->right = (*turnnode)->left;
		this->swap((*turnnode)->right->left, (*turnnode)->right->right);
		(*turnnode)->left = minnode;
		(*turnnode)->right->right = maxnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = false;
		}
		(*filpnode)->left->isRed = true;
		(*filpnode)->right->isRed = true;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
	}
	myRedBlackTree(T* arr, int ihas) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	myRedBlackTree(myRedBlackTree& tree) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已修正红黑树的check方法^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(bool isRed = true, T tf = NULL, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int iprints;
	void check(node** nodea, node** beforenode) {
		if (nullptr != beforenode && nullptr != (*beforenode)->right && nullptr != (*beforenode)->right->right && (*beforenode)->right->isRed && (*beforenode)->right->right->isRed) {
			leftTurn(nodea);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->left->left && (*beforenode)->left->isRed && (*beforenode)->left->left->isRed) {
			rightTurn(beforenode);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->right && (*beforenode)->left->isRed && (*beforenode)->right->isRed) {
			filpColours(beforenode);
		}
	}
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(true, t);
					ic++;
					check(rootf, beforenode);
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(true, t);
					ic++;
					check(rootf, beforenode);
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* minnode = (*turnnode)->left;
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
		(*turnnode)->left->left = minnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		node* maxnode = (*turnnode)->right;
		(*turnnode)->right = (*turnnode)->left;
		this->swap((*turnnode)->right->left, (*turnnode)->right->right);
		(*turnnode)->left = minnode;
		(*turnnode)->right->right = maxnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = true;
		}
		(*filpnode)->left->isRed = false;
		(*filpnode)->right->isRed = false;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
	}
	myRedBlackTree(T* arr, int ihas) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	myRedBlackTree(myRedBlackTree& tree) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已修正红黑树的filpColour方法^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(bool isRed = true, T tf = NULL, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int iprints;
	void check(node** nodea, node** beforenode) {
		if (nullptr != beforenode && nullptr != (*beforenode)->right && nullptr != (*beforenode)->right->right && (*beforenode)->right->isRed && (*beforenode)->right->right->isRed) {
			leftTurn(nodea);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->left->left && (*beforenode)->left->isRed && (*beforenode)->left->left->isRed) {
			rightTurn(beforenode);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->right && (*beforenode)->left->isRed && (*beforenode)->right->isRed) {
			filpColours(beforenode);
		}
	}
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
			return;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(true, t);
					ic++;
					
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(true, t);
					ic++;
					//check(rootf, beforenode);
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
		check(rootf, beforenode);
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* minnode = (*turnnode)->left;
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
		(*turnnode)->left->left = minnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		node* maxnode = (*turnnode)->right;
		(*turnnode)->right = (*turnnode)->left;
		this->swap((*turnnode)->right->left, (*turnnode)->right->right);
		(*turnnode)->left = minnode;
		(*turnnode)->right->right = maxnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = true;
		}
		(*filpnode)->left->isRed = false;
		(*filpnode)->right->isRed = false;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
	}
	myRedBlackTree(T* arr, int ihas) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	myRedBlackTree(myRedBlackTree& tree) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///红黑树的insert重载方法已再次修正^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(bool isRed = true, T tf = NULL, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int iprints;
	void check(node** nodea, node** beforenode) {
		if (nullptr != beforenode && nullptr != (*beforenode)->right && nullptr != (*beforenode)->right->right && (*beforenode)->right->isRed && (*beforenode)->right->right->isRed) {
			leftTurn(nodea);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->left->left && (*beforenode)->left->isRed && (*beforenode)->left->left->isRed) {
			rightTurn(beforenode);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->right && (*beforenode)->left->isRed && (*beforenode)->right->isRed) {
			filpColours(beforenode);
		}
	}
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
			return;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(true, t);
					ic++;
					
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(true, t);
					ic++;
					//check(rootf, beforenode);
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
		check(rootf, beforenode);
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* minnode = (*turnnode)->left;
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
		(*turnnode)->left->left = minnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		node* maxnode = (*turnnode)->right;
		(*turnnode)->right = (*turnnode)->left;
		this->swap((*turnnode)->right->left, (*turnnode)->right->right);
		(*turnnode)->left = minnode;
		(*turnnode)->right->right = maxnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = true;
		}
		(*filpnode)->left->isRed = false;
		(*filpnode)->right->isRed = false;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
	}
	myRedBlackTree(T* arr, int ihas) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
		for (int i = 0; i < ihas; i++) {
			this->insert(arr[i]);
		}
	}
	myRedBlackTree(myRedBlackTree& tree) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;

	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///红黑树的数组构造方法已实现完成^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(bool isRed = true, T tf = NULL, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int iprints;
	void check(node** nodea, node** beforenode) {
		if (nullptr != beforenode && nullptr != (*beforenode)->right && nullptr != (*beforenode)->right->right && (*beforenode)->right->isRed && (*beforenode)->right->right->isRed) {
			leftTurn(nodea);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->left->left && (*beforenode)->left->isRed && (*beforenode)->left->left->isRed) {
			rightTurn(beforenode);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->right && (*beforenode)->left->isRed && (*beforenode)->right->isRed) {
			filpColours(beforenode);
		}
	}
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
			return;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(true, t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(true, t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
		check(rootf, beforenode);
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* minnode = (*turnnode)->left;
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
		(*turnnode)->left->left = minnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		node* maxnode = (*turnnode)->right;
		(*turnnode)->right = (*turnnode)->left;
		this->swap((*turnnode)->right->left, (*turnnode)->right->right);
		(*turnnode)->left = minnode;
		(*turnnode)->right->right = maxnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = true;
		}
		(*filpnode)->left->isRed = false;
		(*filpnode)->right->isRed = false;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
	}
	myRedBlackTree(T* arr, int ihas) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
		for (int i = 0; i < ihas; i++) {
			this->insert(arr[i]);
		}
	}
	myRedBlackTree(myRedBlackTree& tree) {
		root = new node(false, tree.root->t);
		this->ic = tree.ic;
		this->iprints = 0;
		node** addnode = &this->root;
		node* searchnode = tree.root;


	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///红黑树的拷贝函数的基础已搭建好^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(bool isRed = true, T tf = NULL, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int iprints;
	void check(node** nodea, node** beforenode) {
		if (nullptr != beforenode && nullptr != (*beforenode)->right && nullptr != (*beforenode)->right->right && (*beforenode)->right->isRed && (*beforenode)->right->right->isRed) {
			leftTurn(nodea);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->left->left && (*beforenode)->left->isRed && (*beforenode)->left->left->isRed) {
			rightTurn(beforenode);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->right && (*beforenode)->left->isRed && (*beforenode)->right->isRed) {
			filpColours(beforenode);
		}
	}
	void copy(node** addnode, node* searchnode) {
		if (nullptr != searchnode) {
			(*addnode)->t = searchnode->t;
			(*addnode)->isRed = searchnode->isRed;
			copy(&(*addnode)->left, searchnode->left);
			copy(&(*addnode)->right, searchnode->right);
		}
	}
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
			return;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(true, t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(true, t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
		check(rootf, beforenode);
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* minnode = (*turnnode)->left;
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
		(*turnnode)->left->left = minnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		node* maxnode = (*turnnode)->right;
		(*turnnode)->right = (*turnnode)->left;
		this->swap((*turnnode)->right->left, (*turnnode)->right->right);
		(*turnnode)->left = minnode;
		(*turnnode)->right->right = maxnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = true;
		}
		(*filpnode)->left->isRed = false;
		(*filpnode)->right->isRed = false;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
	}
	myRedBlackTree(T* arr, int ihas) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
		for (int i = 0; i < ihas; i++) {
			this->insert(arr[i]);
		}
	}
	myRedBlackTree(myRedBlackTree& tree) {
		root = new node(false);
		this->ic = tree.ic;
		this->iprints = 0;
		node** addnode = &this->root;
		node* searchnode = tree.root;
		this->copy(&this->root, tree.root);
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已新建并实现好红黑树的copy临时方法，且实现了红黑树的拷贝方法^
/*
//meiri.cpp
#include <iostream>
#include "myRedbLackTree.hpp"
using namespace std;

void print(int item, bool isNotEnd) {
	cout << item;
	if (isNotEnd) {
		cout << ", ";
	}
	else {
		cout << endl;
	}
}

int main() {
	int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	myRedBlackTree<int>m(arr, 10);
	cout << "max = " << m.max() << " min = " << m.min() << endl;
	return 0;
}
*///已测试红黑树的max和min方法^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(bool isRed = true, T tf = NULL, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int iprints;
	void check(node** nodea, node** beforenode) {
		if (nullptr != beforenode && nullptr != (*beforenode)->right && nullptr != (*beforenode)->right->right && (*beforenode)->right->isRed && (*beforenode)->right->right->isRed) {
			leftTurn(beforenode);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->left->left && (*beforenode)->left->isRed && (*beforenode)->left->left->isRed) {
			rightTurn(beforenode);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->right && (*beforenode)->left->isRed && (*beforenode)->right->isRed) {
			filpColours(beforenode);
		}
	}
	void copy(node** addnode, node* searchnode) {
		if (nullptr != searchnode) {
			if (this->root != *addnode) {
				*addnode = new node(searchnode->isRed, searchnode->t);
			}
			copy(&(*addnode)->left, searchnode->left);
			copy(&(*addnode)->right, searchnode->right);
		}
	}
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
			return;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(true, t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(true, t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
		check(rootf, beforenode);
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* minnode = (*turnnode)->left;
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
		(*turnnode)->left->left = minnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		node* maxnode = (*turnnode)->right;
		(*turnnode)->right = (*turnnode)->left;
		this->swap((*turnnode)->right->left, (*turnnode)->right->right);
		(*turnnode)->left = minnode;
		(*turnnode)->right->right = maxnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = true;
		}
		(*filpnode)->left->isRed = false;
		(*filpnode)->right->isRed = false;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
	}
	myRedBlackTree(T* arr, int ihas) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
		for (int i = 0; i < ihas; i++) {
			this->insert(arr[i]);
		}
	}
	myRedBlackTree(myRedBlackTree& tree) {
		root = new node(false, tree.root->t);
		this->ic = tree.ic;
		this->iprints = 0;
		this->copy(&this->root, tree.root);
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
//meiri.cpp
#include <iostream>
#include "myRedbLackTree.hpp"
using namespace std;

void print(int item, bool isNotEnd) {
	cout << item;
	if (isNotEnd) {
		cout << ", ";
	}
	else {
		cout << endl;
	}
}

int main() {
	int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	myRedBlackTree<int>mt(arr, 10);
	myRedBlackTree<int>m = mt;
	m.printtree(print);
	return 0;
}
*///已测试并修正红黑树的拷贝构造方法和临时的copy方法^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
#include <queue>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(bool isRed = true, T tf = NULL, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int iprints;
	void check(node** nodea, node** beforenode) {
		if (nullptr != beforenode && nullptr != (*beforenode)->right && nullptr != (*beforenode)->right->right && (*beforenode)->right->isRed && (*beforenode)->right->right->isRed) {
			leftTurn(beforenode);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->left->left && (*beforenode)->left->isRed && (*beforenode)->left->left->isRed) {
			rightTurn(beforenode);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->right && (*beforenode)->left->isRed && (*beforenode)->right->isRed) {
			filpColours(beforenode);
		}
	}
	void copy(node** addnode, node* searchnode) {
		if (nullptr != searchnode) {
			if (this->root != *addnode) {
				*addnode = new node(searchnode->isRed, searchnode->t);
			}
			copy(&(*addnode)->left, searchnode->left);
			copy(&(*addnode)->right, searchnode->right);
		}
	}
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
			return;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(true, t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(true, t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
		check(rootf, beforenode);
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* minnode = (*turnnode)->left;
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
		(*turnnode)->left->left = minnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		node* maxnode = (*turnnode)->right;
		(*turnnode)->right = (*turnnode)->left;
		this->swap((*turnnode)->right->left, (*turnnode)->right->right);
		(*turnnode)->left = minnode;
		(*turnnode)->right->right = maxnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = true;
		}
		(*filpnode)->left->isRed = false;
		(*filpnode)->right->isRed = false;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 != this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
	}
	myRedBlackTree(T* arr, int ihas) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
		for (int i = 0; i < ihas; i++) {
			this->insert(arr[i]);
		}
	}
	myRedBlackTree(myRedBlackTree& tree) {
		root = new node(false, tree.root->t);
		this->ic = tree.ic;
		this->iprints = 0;
		this->copy(&this->root, tree.root);
	}
	myRedBlackTree& operator=(myRedBlackTree& tree){
		delete root;
		root = new node(false, tree.root->t);
		this->ic = tree.ic;
		this->iprints = 0;
		this->copy(&this->root, tree.root);
		return *this;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
//meiri.cpp
#include <iostream>
#include "myRedBlackTree.hpp"
using namespace std;

void print(int item, bool isNotEnd) {
	cout << item;
	if (isNotEnd) {
		cout << ", ";
	}
	else {
		cout << endl;
	}
}

int main() {
	int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	myRedBlackTree<int>mt(arr, 10);
	myRedBlackTree<int>m = mt;
	myRedBlackTree<int>ma;
	ma = m;
	ma.printtree(print);
	return 0;
}
*///已新建并实现红黑树的重载赋值运算符^
/*
//myRedBlackTree.hpp
#pragma once
#include <iostream>
using namespace std;
template<class T>
class myRedBlackTree {
private:
	int ic;
	class node {
	public:
		T t;
		node* left;
		node* right;
		bool isRed;
		node(bool isRed = true, T tf = NULL, node* leftf = nullptr, node* rightf = nullptr) {
			this->t = tf;
			this->left = leftf;
			this->right = rightf;
			this->isRed = isRed;
		}
	};
	node* root;
	int iprints;
	void check(node** nodea, node** beforenode) {
		if (nullptr != beforenode && nullptr != (*beforenode)->right && nullptr != (*beforenode)->right->right && (*beforenode)->right->isRed && (*beforenode)->right->right->isRed) {
			leftTurn(beforenode);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->left->left && (*beforenode)->left->isRed && (*beforenode)->left->left->isRed) {
			rightTurn(beforenode);
		}
		if (nullptr != beforenode && nullptr != (*beforenode)->left && nullptr != (*beforenode)->right && (*beforenode)->left->isRed && (*beforenode)->right->isRed) {
			filpColours(beforenode);
		}
	}
	void copy(node** addnode, node* searchnode) {
		if (nullptr != searchnode) {
			if (this->root != *addnode) {
				*addnode = new node(searchnode->isRed, searchnode->t);
			}
			copy(&(*addnode)->left, searchnode->left);
			copy(&(*addnode)->right, searchnode->right);
		}
	}
	void insert(T t, node** rootf, node** beforenode = nullptr) {
		if (!ic) {
			root->t = t;
			ic++;
			return;
		}
		else {
			if (t > (*rootf)->t) {
				if (nullptr == (*rootf)->right) {
					(*rootf)->right = new node(true, t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->right, rootf);
				}
			}
			else {
				if (nullptr == (*rootf)->left) {
					(*rootf)->left = new node(true, t);
					ic++;
				}
				else {
					insert(t, &(*rootf)->left, rootf);
				}
			}
		}
		check(rootf, beforenode);
	}
	template<typename Ta>
	void swap(Ta& itema, Ta& itemb) {
		Ta temp = itema;
		itema = itemb;
		itemb = temp;
	}
	void leftTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->right->t);
		node* minnode = (*turnnode)->left;
		node* maxnode = (*turnnode)->right->right;
		(*turnnode)->left = (*turnnode)->right;
		this->swap((*turnnode)->left->left, (*turnnode)->left->right);
		(*turnnode)->right = maxnode;
		(*turnnode)->left->left = minnode;
	}
	void rightTurn(node** turnnode) {
		this->swap((*turnnode)->t, (*turnnode)->left->t);
		node* minnode = (*turnnode)->left->left;
		node* maxnode = (*turnnode)->right;
		(*turnnode)->right = (*turnnode)->left;
		this->swap((*turnnode)->right->left, (*turnnode)->right->right);
		(*turnnode)->left = minnode;
		(*turnnode)->right->right = maxnode;
	}
	void filpColours(node** filpnode) {
		if (this->root != *filpnode) {
			(*filpnode)->isRed = true;
		}
		(*filpnode)->left->isRed = false;
		(*filpnode)->right->isRed = false;
	}
	void printLRnode(node* node, void (*printfun)(T item, bool b)) {
		if (nullptr != node) {
			printLRnode(node->left, printfun);
			printfun(node->t, this->iprints + 1 < this->ic);
			this->iprints++;
			printLRnode(node->right, printfun);
		}
	}
public:
	myRedBlackTree() {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
	}
	myRedBlackTree(T* arr, int ihas) {
		root = new node(false);
		this->ic = 0;
		this->iprints = 0;
		for (int i = 0; i < ihas; i++) {
			this->insert(arr[i]);
		}
	}
	myRedBlackTree(myRedBlackTree& tree) {
		root = new node(false, tree.root->t);
		this->ic = tree.ic;
		this->iprints = 0;
		this->copy(&this->root, tree.root);
	}
	myRedBlackTree& operator=(myRedBlackTree& tree){
		delete root;
		root = new node(false, tree.root->t);
		this->ic = tree.ic;
		this->iprints = 0;
		this->copy(&this->root, tree.root);
		return *this;
	}
	void insert(T t) {
		insert(t, &root);
	}
	int capacity() const {
		return ic;
	}
	void clear() {
		if (nullptr != root->left) {
			delete root->left;
			root->left = nullptr;
		}
		if (nullptr != root->right) {
			delete root->right;
			root->right = nullptr;
		}
		root->t = NULL;
		this->ic = 0;
	}
	~myRedBlackTree() {
		clear();
		delete root;
	}
	bool IsEmpty() const {
		return !ic;
	}
	void printtree(void (*printfun)(T item, bool b)) {
		this->iprints = 0;
		printLRnode(root, printfun);
	}
	T max() {
		node** findnode = &root;
		while (nullptr != (*findnode)->right) {
			findnode = &(*findnode)->right;
		}
		return (*findnode)->t;
	}
	T min() {
		node** findnode = &root;
		while (nullptr != (*findnode)->left) {
			findnode = &(*findnode)->left;
		}
		return (*findnode)->t;
	}
};
*///已不在红黑树类里边导入queue类文件^
/*
//1GUF.hpp
#pragma once
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
template<class T>
class oneGroupUF {
private:
	class node {
	public:
		T item;
		bool from;
		node(T t = NULL, bool f = false) {
			this->item = t;
			this->from = f;
		}
	};
	vector<node*> nodeArr;
	int ic;
	vector<vector<T>>sequencArr;
	void swap_node(const unsigned int index, const unsigned int indexa) {
		node* temp = this->nodeArr[index];
		this->nodeArr[index] = this->nodeArr[indexa];
		this->nodeArr[indexa] = temp;
	}
	void generateAllSequences(const unsigned int insert_index) {
		if (this->ic <= insert_index) {
			vector<T>v;
			for (node* n : this->nodeArr) {
				v.push_back(n->item);
			}
			this->sequencArr.push_back(v);
			return;
		}
		for (int i = 0; i < this->ic; i++) {
			if (!this->nodeArr[i]->from) {
				this->nodeArr[i]->from = true;
				swap_node(insert_index, i);
				generateAllSequences(insert_index + 1);
				swap_node(insert_index, i);
				this->nodeArr[i]->from = false;
			}
		}
	}
public:
	oneGroupUF() {
		this->ic = 0;
	}
	oneGroupUF(const unsigned int isize) {
		this->nodeArr.reserve(isize);
		this->ic = isize;
	}
	oneGroupUF(vector<T>v) {
		for (T item : v) {
			this->nodeArr.push_back(new node(item));
		}
		this->ic = v.size();
	}
	oneGroupUF(oneGroupUF& uf) {
		for (node* n : uf.nodeArr) {
			this->push_back(n->item);
		}
	}
	bool searchNodeFrom(const unsigned int index) {
		if (index < this->ic) {
			return this->nodeArr[index]->from;
		}
		else {
			return false;
		}
	}
	T& at(const unsigned int index) {
		assert(index < this->ic);
		return this->nodeArr[index]->item;
	}
	T& operator[](const unsigned int index) {
		return at(index);
	}
	T push_back(const T t) {
		this->nodeArr.push_back(new node(t));
		this->ic++;
		return t;
	}
	T pop_back() {
		if (!this->ic) {
			return NULL;
		}
		T last = this->nodeArr.back()->item;
		delete this->nodeArr.back();
		this->nodeArr.pop_back();
		this->ic--;
		return last;
	}
	void clear() {
		while (this->ic) {
			pop_back();
		}
	}
	vector<vector<T>> generateAllSequences() {
		generateAllSequences(0);
		return this->sequencArr;
	}
	~oneGroupUF() {
		clear();
	}
	unsigned int countSequences() {
		return this->sequencArr.size();
	}
};
//meiri.cpp
#include <iostream>
#include "1GUF.hpp"
using namespace std;

int main() {
	vector<int>v = { 1, 2, 3, 4 };
	oneGroupUF<int>o = v;
	vector<vector<int>>vv = o.generateAllSequences();
	for (vector<int>tempv : vv) {
		for (int i : tempv) {
			cout << i << " ";
		}
		cout << endl;
	}
	return 0;
}
*///已基本完成一组并查集OneGroupUF类^
/*
//1GUF.hpp
#pragma once
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
template<class T>
class oneGroupUF {
private:
	class node {
	public:
		T item;
		bool from;
		node(T t = NULL, bool f = false) {
			this->item = t;
			this->from = f;
		}
	};
	vector<node*> nodeArr;
	int ic;
	vector<vector<T>>sequencArr;
	void swap_node(const unsigned int index, const unsigned int indexa) {
		node* temp = this->nodeArr[index];
		this->nodeArr[index] = this->nodeArr[indexa];
		this->nodeArr[indexa] = temp;
	}
	void generateAllSequences(const unsigned int insert_index) {
		if (this->ic <= insert_index) {
			vector<T>v;
			for (node* n : this->nodeArr) {
				v.push_back(n->item);
			}
			this->sequencArr.push_back(v);
			return;
		}
		for (int i = 0; i < this->ic; i++) {
			if (!this->nodeArr[i]->from) {
				this->nodeArr[i]->from = true;
				swap_node(insert_index, i);
				generateAllSequences(insert_index + 1);
				swap_node(insert_index, i);
				this->nodeArr[i]->from = false;
			}
		}
	}
public:
	oneGroupUF() {
		this->ic = 0;
	}
	oneGroupUF(const unsigned int isize) {
		this->nodeArr.reserve(isize);
		this->ic = isize;
	}
	oneGroupUF(vector<T>v) {
		for (T item : v) {
			this->nodeArr.push_back(new node(item));
		}
		this->ic = v.size();
	}
	oneGroupUF(oneGroupUF& uf) {
		for (node* n : uf.nodeArr) {
			this->push_back(n->item);
		}
	}
	bool searchNodeFrom(const unsigned int index) {
		if (index < this->ic) {
			return this->nodeArr[index]->from;
		}
		else {
			return false;
		}
	}
	T& at(const unsigned int index) {
		assert(index < this->ic);
		return this->nodeArr[index]->item;
	}
	T& operator[](const unsigned int index) {
		return at(index);
	}
	T push_back(const T t) {
		this->nodeArr.push_back(new node(t));
		this->ic++;
		return t;
	}
	T pop_back() {
		if (!this->ic) {
			return NULL;
		}
		T last = this->nodeArr.back()->item;
		delete this->nodeArr.back();
		this->nodeArr.pop_back();
		this->ic--;
		return last;
	}
	void clear() {
		while (this->ic) {
			pop_back();
		}
	}
	vector<vector<T>> generateAllSequences() {
		generateAllSequences(0);
		return this->sequencArr;
	}
	~oneGroupUF() {
		clear();
	}
	unsigned int countSequences() {
		return this->sequencArr.size();
	}
};
//meiri.cpp
#include <iostream>
#include "1GUF.hpp"
using namespace std;

int main() {
	vector<int>v = { 1, 2, 3, 4 };
	oneGroupUF<int>o = v;
	vector<vector<int>>vv = o.generateAllSequences();
	for (vector<int>tempv : vv) {
		for (int i : tempv) {
			cout << i << " ";
		}
		cout << endl;
	}
	return 0;
}
*///已基本完成单组并查集OneGroupUF类^
/*
//1GUF.hpp
#pragma once
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
template<class T>
class oneGroupUF {
private:
	class node {
	public:
		T item;
		bool from;
		node(T t = NULL, bool f = false) {
			this->item = t;
			this->from = f;
		}
	};
	vector<node*> nodeArr;
	int ic;
	vector<vector<T>>sequencArr;
	void swap_node(const unsigned int index, const unsigned int indexa) {
		node* temp = this->nodeArr[index];
		this->nodeArr[index] = this->nodeArr[indexa];
		this->nodeArr[indexa] = temp;
	}
	void generateAllSequences(const unsigned int insert_index) {
		if (this->ic <= insert_index && this->ic) {
			vector<T>v;
			for (node* n : this->nodeArr) {
				v.push_back(n->item);
			}
			if (this->sequencArr.end() == find(this->sequencArr.begin(), this->sequencArr.end(), v)) {
				this->sequencArr.push_back(v);
			}
			return;
		}
		for (int i = 0; i < this->ic; i++) {
			if (!this->nodeArr[i]->from) {
				this->nodeArr[i]->from = true;
				swap_node(insert_index, i);
				generateAllSequences(insert_index + 1);
				swap_node(insert_index, i);
				this->nodeArr[i]->from = false;
			}
		}
	}
public:
	oneGroupUF() {
		this->ic = 0;
	}
	oneGroupUF(const unsigned int isize) {
		this->nodeArr.reserve(isize);
		this->ic = isize;
	}
	oneGroupUF(vector<T>v) {
		for (T item : v) {
			this->nodeArr.push_back(new node(item));
		}
		this->ic = v.size();
	}
	oneGroupUF(oneGroupUF& uf) {
		for (node* n : uf.nodeArr) {
			this->push_back(n->item);
		}
	}
	bool searchNodeFrom(const unsigned int index) {
		if (index < this->ic) {
			return this->nodeArr[index]->from;
		}
		else {
			return false;
		}
	}
	T& at(const unsigned int index) {
		assert(index < this->ic);
		return this->nodeArr[index]->item;
	}
	T& operator[](const unsigned int index) {
		return at(index);
	}
	T push_back(const T t) {
		this->nodeArr.push_back(new node(t));
		this->ic++;
		return t;
	}
	T pop_back() {
		if (!this->ic) {
			return NULL;
		}
		T last = this->nodeArr.back()->item;
		delete this->nodeArr.back();
		this->nodeArr.pop_back();
		this->ic--;
		return last;
	}
	void clear() {
		while (this->ic) {
			pop_back();
		}
	}
	vector<vector<T>> generateAllSequences() {
		this->sequencArr.clear();
		generateAllSequences(0);
		return this->sequencArr;
	}
	~oneGroupUF() {
		clear();
	}
	unsigned int countSequences() {
		return this->sequencArr.size();
	}
};
//meiri.cpp
#include <iostream>
#include "1GUF.hpp"
#include <climits>
using namespace std;

void print(oneGroupUF<int>& o) {
	vector<vector<int>>vv = o.generateAllSequences();
	for (vector<int>tempv : vv) {
		for (int i : tempv) {
			cout << i << " ";
		}
		cout << endl;
	}
}

int main() {
	oneGroupUF<int>o;
	for (int i = 0; i < 4; i++) {
		o.push_back(i);
	}
	print(o);
	cout << o.countSequences() << endl;
	cout << "-----------" << endl;
	o.clear();
	print(o);
	cout << o.countSequences() << endl;
	return 0;
}
*///已修正单组并查集oneGroupUF的generateAllSequences私有重载方法，并测试了单组并查集oneGroupUF的push_back方法，clear方法^
/*
//1GUF.hpp
#pragma once
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
template<class T>
class oneGroupUF {
private:
	class node {
	public:
		T item;
		bool from;
		node(T t = NULL, bool f = false) {
			this->item = t;
			this->from = f;
		}
	};
	vector<node*> nodeArr;
	int ic;
	vector<vector<T>>sequencArr;
	void swap_node(const unsigned int index, const unsigned int indexa) {
		node* temp = this->nodeArr[index];
		this->nodeArr[index] = this->nodeArr[indexa];
		this->nodeArr[indexa] = temp;
	}
	void generateAllSequences(const unsigned int insert_index) {
		if (this->ic <= insert_index && this->ic) {
			vector<T>v;
			for (node* n : this->nodeArr) {
				v.push_back(n->item);
			}
			if (this->sequencArr.end() == find(this->sequencArr.begin(), this->sequencArr.end(), v)) {
				this->sequencArr.push_back(v);
			}
			return;
		}
		for (int i = 0; i < this->ic; i++) {
			if (!this->nodeArr[i]->from) {
				this->nodeArr[i]->from = true;
				swap_node(insert_index, i);
				generateAllSequences(insert_index + 1);
				swap_node(insert_index, i);
				this->nodeArr[i]->from = false;
			}
		}
	}
public:
	oneGroupUF() {
		this->ic = 0;
	}
	oneGroupUF(const unsigned int isize) {
		this->nodeArr.reserve(isize);
		this->ic = isize;
	}
	oneGroupUF(vector<T>v) {
		for (T item : v) {
			this->nodeArr.push_back(new node(item));
		}
		this->ic = v.size();
	}
	oneGroupUF(oneGroupUF& uf) {
		for (node* n : uf.nodeArr) {
			this->push_back(n->item);
		}
	}
	bool searchNodeFrom(const unsigned int index) {
		if (index < this->ic) {
			return this->nodeArr[index]->from;
		}
		else {
			return false;
		}
	}
	T& at(const unsigned int index) {
		assert(index < this->ic);
		return this->nodeArr[index]->item;
	}
	T& operator[](const unsigned int index) {
		return at(index);
	}
	T push_back(const T t) {
		this->nodeArr.push_back(new node(t));
		this->ic++;
		return t;
	}
	T pop_back() {
		if (!this->ic) {
			return NULL;
		}
		T last = this->nodeArr.back()->item;
		delete this->nodeArr.back();
		this->nodeArr.pop_back();
		this->ic--;
		return last;
	}
	void clear() {
		while (this->ic) {
			pop_back();
		}
	}
	vector<vector<T>> generateAllSequences() {
		this->sequencArr.clear();
		generateAllSequences(0);
		return this->sequencArr;
	}
	~oneGroupUF() {
		clear();
	}
	unsigned int countSequences() {
		return this->sequencArr.size();
	}
	unsigned int getCapacity() {
		return this->ic;
	}
};
//meiri.cpp
#include <iostream>
#include "1GUF.hpp"
#include <climits>
using namespace std;

template<typename T>
void print(oneGroupUF<T>& o) {
	vector<vector<T>>vv = o.generateAllSequences();
	for (vector<T>tempv : vv) {
		for (T i : tempv) {
			cout << i << " ";
		}
		cout << endl;
	}
}

int main() {
	oneGroupUF<char>o;
	for (char ch = 'a'; ch <= 'z'; ch++) {
		o.push_back(ch);
	}
	o.push_back('.');
	cout << o.getCapacity() << endl;
	o.pop_back();
	cout << o.getCapacity() << endl;
	print(o);
	return 0;
}
*///已新建并测试了oneGroupUF单组并查集的getCapacity方法和pop_back方法^
/*
//1GUF.hpp
#pragma once
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
template<class T>
class oneGroupUF {
private:
	class node {
	public:
		T item;
		bool from;
		node(T t = NULL, bool f = false) {
			this->item = t;
			this->from = f;
		}
	};
	vector<node*> nodeArr;
	int ic;
	vector<vector<T>>sequencArr;
	void swap_node(const unsigned int index, const unsigned int indexa) {
		node* temp = this->nodeArr[index];
		this->nodeArr[index] = this->nodeArr[indexa];
		this->nodeArr[indexa] = temp;
	}
	void generateAllSequences(const unsigned int insert_index) {
		if (this->ic <= insert_index && this->ic) {
			vector<T>v;
			for (node* n : this->nodeArr) {
				v.push_back(n->item);
			}
			if (this->sequencArr.end() == find(this->sequencArr.begin(), this->sequencArr.end(), v)) {
				this->sequencArr.push_back(v);
			}
			return;
		}
		for (int i = 0; i < this->ic; i++) {
			if (!this->nodeArr[i]->from) {
				this->nodeArr[i]->from = true;
				swap_node(insert_index, i);
				generateAllSequences(insert_index + 1);
				swap_node(insert_index, i);
				this->nodeArr[i]->from = false;
			}
		}
	}
public:
	oneGroupUF() {
		this->ic = 0;
	}
	oneGroupUF(const unsigned int isize) {
		this->nodeArr.reserve(isize);
		this->ic = isize;
	}
	oneGroupUF(vector<T>v) {
		for (T item : v) {
			this->nodeArr.push_back(new node(item));
		}
		this->ic = v.size();
	}
	oneGroupUF(oneGroupUF& uf) {
		for (node* n : uf.nodeArr) {
			this->push_back(n->item);
		}
	}
	T& at(const unsigned int index) {
		assert(index < this->ic);
		return this->nodeArr[index]->item;
	}
	T& operator[](const unsigned int index) {
		return at(index);
	}
	T push_back(const T t) {
		this->nodeArr.push_back(new node(t));
		this->ic++;
		return t;
	}
	T pop_back() {
		if (!this->ic) {
			return NULL;
		}
		T last = this->nodeArr.back()->item;
		delete this->nodeArr.back();
		this->nodeArr.pop_back();
		this->ic--;
		return last;
	}
	void clear() {
		while (this->ic) {
			pop_back();
		}
	}
	vector<vector<T>> generateAllSequences() {
		this->sequencArr.clear();
		generateAllSequences(0);
		return this->sequencArr;
	}
	~oneGroupUF() {
		clear();
	}
	unsigned int countSequences() {
		return this->sequencArr.size();
	}
	unsigned int getCapacity() {
		return this->ic;
	}
};
*///已删除单组并查集oneGroupUF的searchNodeFrom方法^
/*
//1GUF.hpp
#pragma once
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
template<class T>
class oneGroupUF {
private:
	class node {
	public:
		T item;
		bool from;
		node(T t = NULL, bool f = false) {
			this->item = t;
			this->from = f;
		}
	};
	vector<node*> nodeArr;
	int ic;
	vector<vector<T>>sequencArr;
	void swap_node(const unsigned int index, const unsigned int indexa) {
		node* temp = this->nodeArr[index];
		this->nodeArr[index] = this->nodeArr[indexa];
		this->nodeArr[indexa] = temp;
	}
	void generateAllSequences(const unsigned int insert_index) {
		if (this->ic <= insert_index && this->ic) {
			vector<T>v;
			for (node* n : this->nodeArr) {
				v.push_back(n->item);
			}
			if (this->sequencArr.end() == find(this->sequencArr.begin(), this->sequencArr.end(), v)) {
				this->sequencArr.push_back(v);
			}
			return;
		}
		for (int i = 0; i < this->ic; i++) {
			if (!this->nodeArr[i]->from) {
				this->nodeArr[i]->from = true;
				swap_node(insert_index, i);
				generateAllSequences(insert_index + 1);
				swap_node(insert_index, i);
				this->nodeArr[i]->from = false;
			}
		}
	}
public:
	oneGroupUF() {
		this->ic = 0;
	}
	oneGroupUF(const unsigned int isize) {
		this->nodeArr.reserve(isize);
		this->ic = isize;
	}
	oneGroupUF(vector<T>v) {
		for (T item : v) {
			this->nodeArr.push_back(new node(item));
		}
		this->ic = v.size();
	}
	oneGroupUF(oneGroupUF& uf) {
		for (node* n : uf.nodeArr) {
			this->push_back(n->item);
		}
	}
	T& at(const unsigned int index) {
		assert(index < this->ic);
		return this->nodeArr[index]->item;
	}
	T& operator[](const unsigned int index) {
		return at(index);
	}
	T push_back(const T t) {
		this->nodeArr.push_back(new node(t));
		this->ic++;
		return t;
	}
	T pop_back() {
		if (!this->ic) {
			return NULL;
		}
		T last = this->nodeArr.back()->item;
		delete this->nodeArr.back();
		this->nodeArr.pop_back();
		this->ic--;
		return last;
	}
	void clear() {
		while (this->ic) {
			pop_back();
		}
	}
	vector<vector<T>> generateAllSequences() {
		this->sequencArr.clear();
		generateAllSequences(0);
		return this->sequencArr;
	}
	~oneGroupUF() {
		clear();
	}
	unsigned int countSequences() {
		return this->sequencArr.size();
	}
	unsigned int getCapacity() {
		return this->ic;
	}
};
//meiri.cpp
#include <iostream>
#include "1GUF.hpp"
using namespace std;

template<typename T>
void print(oneGroupUF<T>& o) {
	vector<vector<T>>vv = o.generateAllSequences();
	for (vector<T>tempv : vv) {
		for (T i : tempv) {
			cout << i << " ";
		}
		cout << endl;
	}
}

int main() {
	oneGroupUF<char>o;
	for (char ch = 'a'; ch <= 'd'; ch++) {
		o.push_back(ch);
	}
	for (int i = 0; i < 4; i++) {
		cout << o[i];
		if (3 == i) {
			cout << endl;
		}
		else {
			cout << ", ";
		}
	}
	
	return 0;
}
*///已测试oneGroupUF单组并查集的at方法和重载的中括号运算符^
/*
//1GUF.hpp
#pragma once
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
template<class T>
class oneGroupUF {
private:
	class node {
	public:
		T item;
		bool from;
		node(T t = NULL, bool f = false) {
			this->item = t;
			this->from = f;
		}
	};
	vector<node*> nodeArr;
	int ic;
	vector<vector<T>>sequencArr;
	void swap_node(const unsigned int index, const unsigned int indexa) {
		node* temp = this->nodeArr[index];
		this->nodeArr[index] = this->nodeArr[indexa];
		this->nodeArr[indexa] = temp;
	}
	void generateAllSequences(const unsigned int insert_index) {
		if (this->ic <= insert_index && this->ic) {
			vector<T>v;
			for (node* n : this->nodeArr) {
				v.push_back(n->item);
			}
			if (this->sequencArr.end() == find(this->sequencArr.begin(), this->sequencArr.end(), v)) {
				this->sequencArr.push_back(v);
			}
			return;
		}
		for (int i = 0; i < this->ic; i++) {
			if (!this->nodeArr[i]->from) {
				this->nodeArr[i]->from = true;
				swap_node(insert_index, i);
				generateAllSequences(insert_index + 1);
				swap_node(insert_index, i);
				this->nodeArr[i]->from = false;
			}
		}
	}
public:
	oneGroupUF() {
		this->ic = 0;
	}
	oneGroupUF(const unsigned int isize) {
		this->nodeArr.reserve(isize);
		this->ic = isize;
	}
	oneGroupUF(vector<T>v) {
		for (T item : v) {
			this->nodeArr.push_back(new node(item));
		}
		this->ic = v.size();
	}
	oneGroupUF(oneGroupUF& uf) {
		for (node* n : uf.nodeArr) {
			this->push_back(n->item);
		}
		this->sequencArr = uf.sequencArr;
	}
	T& at(const unsigned int index) {
		assert(index < this->ic);
		return this->nodeArr[index]->item;
	}
	T& operator[](const unsigned int index) {
		return at(index);
	}
	T push_back(const T t) {
		this->nodeArr.push_back(new node(t));
		this->ic++;
		return t;
	}
	T pop_back() {
		if (!this->ic) {
			return NULL;
		}
		T last = this->nodeArr.back()->item;
		delete this->nodeArr.back();
		this->nodeArr.pop_back();
		this->ic--;
		return last;
	}
	void clear() {
		while (this->ic) {
			pop_back();
		}
	}
	vector<vector<T>> generateAllSequences() {
		this->sequencArr.clear();
		generateAllSequences(0);
		return this->sequencArr;
	}
	~oneGroupUF() {
		clear();
	}
	unsigned int countSequences() {
		return this->sequencArr.size();
	}
	unsigned int getCapacity() {
		return this->ic;
	}
};
*///已修正oneGroupUF单组并查集的拷贝构造方法^
/*
//meiri.cpp
#include <iostream>
#include "1GUF.hpp"
using namespace std;

template<typename T>
void print(oneGroupUF<T>& o) {
	vector<vector<T>>vv = o.generateAllSequences();
	for (vector<T>tempv : vv) {
		for (T i : tempv) {
			cout << i << " ";
		}
		cout << endl;
	}
}

int main() {
	oneGroupUF<char>o;
	for (char ch = 'a'; ch <= 'd'; ch++) {
		o.push_back(ch);
	}
	o.generateAllSequences();
	oneGroupUF<char>oa = o;
	print(oa);
	cout << oa.countSequences() << endl;
	return 0;
}
*///已测试oneGroupUF单组并查集的拷贝构造方法^
/*
//1GUF.hpp
#pragma once
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
template<class T>
class oneGroupUF {
private:
	class node {
	public:
		T item;
		bool from;
		node(T t = NULL, bool f = false) {
			this->item = t;
			this->from = f;
		}
	};
	vector<node*> nodeArr;
	int ic;
	vector<vector<T>>sequencArr;
	void swap_node(const unsigned int index, const unsigned int indexa) {
		node* temp = this->nodeArr[index];
		this->nodeArr[index] = this->nodeArr[indexa];
		this->nodeArr[indexa] = temp;
	}
	void generateAllSequences(const unsigned int insert_index) {
		if (this->ic <= insert_index && this->ic) {
			vector<T>v;
			for (node* n : this->nodeArr) {
				v.push_back(n->item);
			}
			if (this->sequencArr.end() == find(this->sequencArr.begin(), this->sequencArr.end(), v)) {
				this->sequencArr.push_back(v);
			}
			return;
		}
		for (int i = 0; i < this->ic; i++) {
			if (!this->nodeArr[i]->from) {
				this->nodeArr[i]->from = true;
				swap_node(insert_index, i);
				generateAllSequences(insert_index + 1);
				swap_node(insert_index, i);
				this->nodeArr[i]->from = false;
			}
		}
	}
public:
	oneGroupUF() {
		this->ic = 0;
	}
	oneGroupUF(const unsigned int isize) {
		this->nodeArr.reserve(isize);
		this->ic = isize;
	}
	oneGroupUF(vector<T>v) {
		for (T item : v) {
			this->nodeArr.push_back(new node(item));
		}
		this->ic = v.size();
	}
	oneGroupUF(oneGroupUF& uf) {
		for (node* n : uf.nodeArr) {
			this->push_back(n->item);
		}
		this->sequencArr = uf.sequencArr;
	}
	oneGroupUF& operator=(oneGroupUF& uf) {
		this->clear();
		for (node* n : uf.nodeArr) {
			this->push_back(n->item);
		}
		this->sequencArr = uf.sequencArr;
	}
	T& at(const unsigned int index) {
		assert(index < this->ic);
		return this->nodeArr[index]->item;
	}
	T& operator[](const unsigned int index) {
		return at(index);
	}
	T push_back(const T t) {
		this->nodeArr.push_back(new node(t));
		this->ic++;
		return t;
	}
	T pop_back() {
		if (!this->ic) {
			return NULL;
		}
		T last = this->nodeArr.back()->item;
		delete this->nodeArr.back();
		this->nodeArr.pop_back();
		this->ic--;
		return last;
	}
	void clear() {
		while (this->ic) {
			pop_back();
		}
	}
	vector<vector<T>> generateAllSequences() {
		this->sequencArr.clear();
		generateAllSequences(0);
		return this->sequencArr;
	}
	~oneGroupUF() {
		clear();
	}
	unsigned int countSequences() {
		return this->sequencArr.size();
	}
	unsigned int getCapacity() {
		return this->ic;
	}
};
*///已新建并实现重载赋值运算符^
/*
//1GUF.hpp
#pragma once
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;
template<class T>
class oneGroupUF {
private:
	class node {
	public:
		T item;
		bool from;
		node(T t = NULL, bool f = false) {
			this->item = t;
			this->from = f;
		}
	};
	vector<node*> nodeArr;
	int ic;
	vector<vector<T>>sequencArr;
	void swap_node(const unsigned int index, const unsigned int indexa) {
		node* temp = this->nodeArr[index];
		this->nodeArr[index] = this->nodeArr[indexa];
		this->nodeArr[indexa] = temp;
	}
	void generateAllSequences(const unsigned int insert_index) {
		if (this->ic <= insert_index && this->ic) {
			vector<T>v;
			for (node* n : this->nodeArr) {
				v.push_back(n->item);
			}
			if (this->sequencArr.end() == find(this->sequencArr.begin(), this->sequencArr.end(), v)) {
				this->sequencArr.push_back(v);
			}
			return;
		}
		for (int i = 0; i < this->ic; i++) {
			if (!this->nodeArr[i]->from) {
				this->nodeArr[i]->from = true;
				swap_node(insert_index, i);
				generateAllSequences(insert_index + 1);
				swap_node(insert_index, i);
				this->nodeArr[i]->from = false;
			}
		}
	}
public:
	oneGroupUF() {
		this->ic = 0;
	}
	oneGroupUF(const unsigned int isize) {
		this->nodeArr.reserve(isize);
		this->ic = isize;
	}
	oneGroupUF(vector<T>v) {
		for (T item : v) {
			this->nodeArr.push_back(new node(item));
		}
		this->ic = v.size();
	}
	oneGroupUF(oneGroupUF& uf) {
		for (node* n : uf.nodeArr) {
			this->push_back(n->item);
		}
		this->sequencArr = uf.sequencArr;
	}
	oneGroupUF& operator=(oneGroupUF& uf) {
		this->clear();
		for (node* n : uf.nodeArr) {
			this->push_back(n->item);
		}
		this->sequencArr = uf.sequencArr;
		return *this;
	}
	T& at(const unsigned int index) {
		assert(index < this->ic);
		return this->nodeArr[index]->item;
	}
	T& operator[](const unsigned int index) {
		return at(index);
	}
	T push_back(const T t) {
		this->nodeArr.push_back(new node(t));
		this->ic++;
		return t;
	}
	T pop_back() {
		if (!this->ic) {
			return NULL;
		}
		T last = this->nodeArr.back()->item;
		delete this->nodeArr.back();
		this->nodeArr.pop_back();
		this->ic--;
		return last;
	}
	void clear() {
		while (this->ic) {
			pop_back();
		}
	}
	vector<vector<T>> generateAllSequences() {
		this->sequencArr.clear();
		generateAllSequences(0);
		return this->sequencArr;
	}
	~oneGroupUF() {
		clear();
	}
	unsigned int countSequences() {
		return this->sequencArr.size();
	}
	unsigned int getCapacity() {
		return this->ic;
	}
};
//meiri.cpp
#include <iostream>
#include "1GUF.hpp"
using namespace std;

template<typename T>
void print(oneGroupUF<T>& o) {
	vector<vector<T>>vv = o.generateAllSequences();
	for (vector<T>tempv : vv) {
		for (T i : tempv) {
			cout << i << " ";
		}
		cout << endl;
	}
}

int main() {
	oneGroupUF<char>o;
	vector<char>v = {'s', 't', 'a', 't', 'i', 'c', 'E', 'r', 'r', 'o', 'r'};
	for (char ch = 'a'; ch <= 'd'; ch++) {
		o.push_back(ch);
	}
	o.generateAllSequences();
	oneGroupUF<char>oa = v;
	oa = o;
	print(oa);
	cout << oa.countSequences() << endl;
	return 0;
}
*///已测试并修正oneGroupUF单组并查集的重载赋值运算符^
/*
//HierarchicalNum.hpp
#include <iostream>
#include <vector>
using namespace std;
class unsignedHierarchicalNum
{
private:
	vector<unsigned int>num;
	unsigned int len;
	unsigned int toUnsignedInt(vector<unsigned int>& num) {
		unsigned int u_i = 0;
		unsigned int digitNum = 1;
		auto it = num.end() - 1;
		while (num.begin() <= it) {
			u_i += *it * digitNum;
			digitNum *= digitNum + 1;
			it--;
		}
		return u_i;
	}
	void add(const int addNum, vector<unsigned int>& n) {
		unsigned int upNum = toUnsignedInt(n) + addNum;
		auto it = n.end() - 1;
		unsigned int levelUp = 2;
		while (it <= n.begin()) {
			*it = upNum % levelUp;
			upNum /= levelUp;
			levelUp++;
			it--;
			*it = upNum;
		}
	}
	void sub(const int subNum, vector<unsigned int>& n) {
		unsigned int upNum = toUnsignedInt(n) - subNum;
		auto it = n.end() - 1;
		unsigned int levelUp = 2;
		while (it <= n.begin()) {
			*it = upNum % levelUp;
			upNum /= levelUp;
			levelUp++;
			it--;
			*it = upNum;
		}
	}
public:
	unsignedHierarchicalNum(const unsigned int n, const unsigned int numLen = 0) {
		if (numLen) {
			this->len = numLen;
			this->num.reserve(numLen);
		}
		else {
			unsigned int tim = 1;
			unsigned int i = 1;
			while (tim >= n) {
				tim *= ++i;
			}
			this->len = i;
			this->num.reserve(i);
		}
		add(n, this->num);
	}
	unsignedHierarchicalNum operator+(const int n) {
		unsignedHierarchicalNum num(this->toUnsignedInt() + n);
		return num;
	}
	unsignedHierarchicalNum operator-(const int n) {
		unsignedHierarchicalNum num(this->toUnsignedInt() - n);
		return num;
	}
	unsignedHierarchicalNum& operator++() {
		add(1, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator--() {
		sub(1, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator++(int) {
		return;
	}
	unsignedHierarchicalNum& operator--(int) {
		return;
	}
	unsignedHierarchicalNum& operator+=(const int addNum) {
		return;
	}
	unsignedHierarchicalNum& operator-=(const int subNum) {
		return;
	}
	unsignedHierarchicalNum& operator=(unsignedHierarchicalNum& n) {
		this->len = n.len;
		this->num = n.num;
		return *this;
	}
	unsigned int getPosNum(const unsigned int position) {
		if (position >= num.size()) {
			return NULL;
		}
		else {
			return num[position];
		}
	}
	unsigned int toUnsignedInt() {
		unsigned int u_i = 0;
		unsigned int digitNum = 1;
		auto it = this->num.end() - 1;
		while (this->num.begin() <= it) {
			u_i += *it * digitNum;
			digitNum *= digitNum + 1;
			it--;
		}
		return u_i;
	}
};
*///已新建unsignedHierarchicalNum阶进制数的所有所需方法，并实现unsignedHierarchicalNum阶进制数类的一些主要方法^
/*
//HierarchicalNum.hpp
#include <iostream>
#include <vector>
using namespace std;
class unsignedHierarchicalNum
{
private:
	vector<unsigned int>num;
	unsigned int len;
	unsigned int toUnsignedInt(vector<unsigned int>& num) {
		unsigned int u_i = 0;
		unsigned int digitNum = 1;
		auto it = num.end() - 1;
		while (num.begin() <= it) {
			u_i += *it * digitNum;
			digitNum *= digitNum + 1;
			it--;
		}
		return u_i;
	}
	void add(const int addNum, vector<unsigned int>& n) {
		unsigned int upNum = toUnsignedInt(n) + addNum;
		auto it = n.end() - 1;
		unsigned int levelUp = 2;
		while (it <= n.begin()) {
			*it = upNum % levelUp;
			upNum /= levelUp;
			levelUp++;
			it--;
			*it = upNum;
		}
	}
	void sub(const int subNum, vector<unsigned int>& n) {
		unsigned int upNum = toUnsignedInt(n) - subNum;
		auto it = n.end() - 1;
		unsigned int levelUp = 2;
		while (it <= n.begin()) {
			*it = upNum % levelUp;
			upNum /= levelUp;
			levelUp++;
			it--;
			*it = upNum;
		}
	}
public:
	unsignedHierarchicalNum(const unsigned int n, const unsigned int numLen = 0) {
		if (numLen) {
			this->len = numLen;
			this->num.reserve(numLen);
		}
		else {
			unsigned int tim = 1;
			unsigned int i = 1;
			while (tim >= n) {
				tim *= ++i;
			}
			this->len = i;
			this->num.reserve(i);
		}
		add(n, this->num);
	}
	unsignedHierarchicalNum operator+(const int n) {
		unsignedHierarchicalNum num(this->toUnsignedInt() + n);
		return num;
	}
	unsignedHierarchicalNum operator-(const int n) {
		unsignedHierarchicalNum num(this->toUnsignedInt() - n);
		return num;
	}
	unsignedHierarchicalNum& operator++() {
		add(1, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator--() {
		sub(1, this->num);
		return *this;
	}
	unsignedHierarchicalNum operator++(int) {
		unsignedHierarchicalNum num = *this;
		add(1, this->num);
		return num;
	}
	unsignedHierarchicalNum operator--(int) {
		unsignedHierarchicalNum num = *this;
		sub(1, this->num);
		return num;
	}
	unsignedHierarchicalNum& operator+=(const int addNum) {
		add(addNum, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator-=(const int subNum) {
		sub(subNum, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator=(unsignedHierarchicalNum& n) {
		this->len = n.len;
		this->num = n.num;
		return *this;
	}
	unsigned int getPosNum(const unsigned int position) {
		if (position >= num.size()) {
			return NULL;
		}
		else {
			return num[position];
		}
	}
	unsigned int toUnsignedInt() {
		unsigned int u_i = 0;
		unsigned int digitNum = 1;
		auto it = this->num.end() - 1;
		while (this->num.begin() <= it) {
			u_i += *it * digitNum;
			digitNum *= digitNum + 1;
			it--;
		}
		return u_i;
	}
};
*///已实现阶进制类unsignedHierarchicalNum的所有所需方法^
/*
//meiri.cpp
#include<iostream>
#include "HierarchicalNum.hpp"
using namespace std;

int main()
{
    unsignedHierarchicalNum u_n(100);
    cout << u_n.toUnsignedInt();
    return 0;
}
*///已测试阶进制数类unsignedHierarchicalNum的有参构造方法和toUnsignedInt方法^
/*
//HierarchicalNum.hpp
#include <iostream>
#include <vector>
using namespace std;
class unsignedHierarchicalNum
{
private:
	vector<unsigned int>num;
	unsigned int len;
	unsigned int toUnsignedInt(vector<unsigned int>& num) {
		unsigned int u_i = 0;
		unsigned int digitNum = 1;
		auto it = num.end() - 1;
		while (num.begin() <= it) {
			u_i += *it * digitNum;
			digitNum *= digitNum + 1;
			it--;
		}
		return u_i;
	}
	void add(const int addNum, vector<unsigned int>& n) {
		unsigned int upNum = toUnsignedInt(n) + addNum;
		auto it = n.end() - 1;
		unsigned int levelUp = 2;
		while (it <= n.begin()) {
			*it = upNum % levelUp;
			upNum /= levelUp;
			levelUp++;
			it--;
			*it = upNum;
		}
	}
	void sub(const int subNum, vector<unsigned int>& n) {
		unsigned int upNum = toUnsignedInt(n) - subNum;
		auto it = n.end() - 1;
		unsigned int levelUp = 2;
		while (it <= n.begin()) {
			*it = upNum % levelUp;
			upNum /= levelUp;
			levelUp++;
			it--;
			*it = upNum;
		}
	}
public:
	unsignedHierarchicalNum(const unsigned int n, const unsigned int numLen = 0) {
		if (numLen) {
			this->len = numLen;
			this->num.reserve(numLen);
		}
		else {
			unsigned int tim = 1;
			unsigned int i = 1;
			while (tim < n) {
				tim *= ++i;
			}
			this->len = i;
			for (; i; i--) {
				this->num.push_back(0);
			}
		}
		add(n, this->num);
	}
	unsignedHierarchicalNum operator+(const int n) {
		unsignedHierarchicalNum num(this->toUnsignedInt() + n);
		return num;
	}
	unsignedHierarchicalNum operator-(const int n) {
		unsignedHierarchicalNum num(this->toUnsignedInt() - n);
		return num;
	}
	unsignedHierarchicalNum& operator++() {
		add(1, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator--() {
		sub(1, this->num);
		return *this;
	}
	unsignedHierarchicalNum operator++(int) {
		unsignedHierarchicalNum num = *this;
		add(1, this->num);
		return num;
	}
	unsignedHierarchicalNum operator--(int) {
		unsignedHierarchicalNum num = *this;
		sub(1, this->num);
		return num;
	}
	unsignedHierarchicalNum& operator+=(const int addNum) {
		add(addNum, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator-=(const int subNum) {
		sub(subNum, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator=(unsignedHierarchicalNum& n) {
		this->len = n.len;
		this->num = n.num;
		return *this;
	}
	unsigned int getPosNum(const unsigned int position) {
		if (position >= num.size()) {
			return NULL;
		}
		else {
			return num[position];
		}
	}
	unsigned int toUnsignedInt() {
		unsigned int u_i = 0;
		unsigned int digitNum = 1;
		auto it = this->num.end() - 1;
		while (this->num.begin() <= it) {
			u_i += *it * digitNum;
			digitNum *= digitNum + 1;
			it--;
		}
		return u_i;
	}
};
*///已尝试修正unsignedHierarchicalNum阶进制数类的构造方法^
/*
//HierarchicalNum.hpp
#include <iostream>
#include <vector>
using namespace std;
class unsignedHierarchicalNum
{
private:
	vector<unsigned int>num;
	unsigned int len;
	unsigned int toUnsignedInt(vector<unsigned int>& num) {
		unsigned int u_i = 0;
		unsigned int digitNum = 1;
		unsigned int timNum = 2;
		int it = num.size() - 1;
		while (0 <= it) {
			u_i += num[it--] * digitNum;
			digitNum *= timNum++;
		}
		return u_i;
	}
	void add(const int addNum, vector<unsigned int>& n) {
		unsigned int upNum = toUnsignedInt(n) + addNum;
		int it = n.size() - 1;
		unsigned int levelUp = 2;
		while (it >= 0) {
			n[it] = upNum % levelUp;
			upNum /= levelUp;
			levelUp++;
			it-- ? n[it] = upNum : 0;
		}
	}
	void sub(const int subNum, vector<unsigned int>& n) {
		unsigned int upNum = toUnsignedInt(n) - subNum;
		int it = n.size() - 1;
		unsigned int levelUp = 2;
		while (it >= 0) {
			n[it] = upNum % levelUp;
			upNum /= levelUp;
			levelUp++;
			it-- ? n[it] = upNum : 0;
		}
	}
public:
	unsignedHierarchicalNum(const unsigned int n, const unsigned int numLen = 0) {
		unsigned int tim = 1;
		unsigned int i = 1;
		while (!numLen && tim < n) {
			tim *= ++i;
		}
		this->len = i;
		for (; i; i--) {
			this->num.push_back(0);
		}
		add(n, this->num);
	}
	unsignedHierarchicalNum operator+(const int n) {
		unsignedHierarchicalNum num(this->toUnsignedInt() + n);
		return num;
	}
	unsignedHierarchicalNum operator-(const int n) {
		unsignedHierarchicalNum num(this->toUnsignedInt() - n);
		return num;
	}
	unsignedHierarchicalNum& operator++() {
		add(1, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator--() {
		sub(1, this->num);
		return *this;
	}
	unsignedHierarchicalNum operator++(int) {
		unsignedHierarchicalNum num = *this;
		add(1, this->num);
		return num;
	}
	unsignedHierarchicalNum operator--(int) {
		unsignedHierarchicalNum num = *this;
		sub(1, this->num);
		return num;
	}
	unsignedHierarchicalNum& operator+=(const int addNum) {
		add(addNum, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator-=(const int subNum) {
		sub(subNum, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator=(unsignedHierarchicalNum& n) {
		this->len = n.len;
		this->num = n.num;
		return *this;
	}
	unsigned int getPosNum(const unsigned int position) const {
		return position >= num.size() ? NULL : num[position];
	}
	unsigned int toUnsignedInt() {
		unsigned int u_i = 0;
		unsigned int digitNum = 1;
		unsigned int timNum = 2;
		int it = this->num.size() - 1;
		while (0 <= it) {
			u_i += this->num[it--] * digitNum;
			digitNum *= timNum++;
		}
		return u_i;
	}
};
*///已修正好阶进制数unsignedHierarchicalNum的一些方法^
/*
//meiri.cpp
#include<iostream>
#include "HierarchicalNum.hpp"
using namespace std;

int main()
{
    unsignedHierarchicalNum u_n(100);
    cout << (u_n - 10).toUnsignedInt();
    return 0;
}
*///已为阶进制数unsignedHierarchicalNum更换新的测试代码并测试^
/*
//meiri.cpp
#include<iostream>
#include "HierarchicalNum.hpp"
using namespace std;

int main()
{
    unsignedHierarchicalNum u_n(100);
    cout << (u_n + 10).toUnsignedInt();
    return 0;
}
*///已测试阶进制数unsignedHierarchicalNum的加号重载运算符^
/*
//HierarchicalNum.hpp
#include <iostream>
#include <vector>
using namespace std;
class unsignedHierarchicalNum
{
private:
	vector<unsigned int>num;
	unsigned int len;
	unsigned int toUnsignedInt(vector<unsigned int>& num) {
		unsigned int u_i = 0;
		unsigned int digitNum = 1;
		unsigned int timNum = 2;
		int it = num.size() - 1;
		while (0 <= it) {
			u_i += num[it--] * digitNum;
			digitNum *= timNum++;
		}
		return u_i;
	}
	void add(const int addNum, vector<unsigned int>& n) {
		unsigned int upNum = toUnsignedInt(n) + addNum;
		int it = n.size() - 1;
		unsigned int levelUp = 2;
		while (it >= 0) {
			n[it] = upNum % levelUp;
			upNum /= levelUp;
			levelUp++;
			it-- ? n[it] = upNum : 0;
		}
	}
	void sub(const int subNum, vector<unsigned int>& n) {
		unsigned int upNum = toUnsignedInt(n) - subNum;
		int it = n.size() - 1;
		unsigned int levelUp = 2;
		while (it >= 0) {
			n[it] = upNum % levelUp;
			upNum /= levelUp;
			levelUp++;
			it-- ? n[it] = upNum : 0;
		}
	}
public:
	unsignedHierarchicalNum(const unsigned int n, const unsigned int numLen = 0) {
		unsigned int tim = 1;
		unsigned int i = 1;
		while (!numLen && tim < n) {
			tim *= ++i;
		}
		this->len = i;
		for (; i; i--) {
			this->num.push_back(0);
		}
		add(n, this->num);
	}
	unsignedHierarchicalNum operator+(const int n) {
		unsignedHierarchicalNum num(this->toUnsignedInt() + n);
		return num;
	}
	unsignedHierarchicalNum operator-(const int n) {
		unsignedHierarchicalNum num(this->toUnsignedInt() - n);
		return num;
	}
	unsignedHierarchicalNum& operator++() {
		add(1, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator--() {
		sub(1, this->num);
		return *this;
	}
	unsignedHierarchicalNum operator++(int) {
		unsignedHierarchicalNum num = *this;
		add(1, this->num);
		return num;
	}
	unsignedHierarchicalNum operator--(int) {
		unsignedHierarchicalNum num = *this;
		sub(1, this->num);
		return num;
	}
	unsignedHierarchicalNum& operator+=(const int addNum) {
		add(addNum, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator-=(const int subNum) {
		sub(subNum, this->num);
		return *this;
	}
	unsigned int operator=(unsigned int n) {
		unsigned int upNum = n;
		int it = this->num.size() - 1;
		unsigned int levelUp = 2;
		while (it >= 0) {
			this->num[it] = upNum % levelUp;
			upNum /= levelUp;
			levelUp++;
			it-- ? this->num[it] = upNum : 0;
		}
		return n;
	}
	unsignedHierarchicalNum& operator=(unsignedHierarchicalNum& n) {
		this->len = n.len;
		this->num = n.num;
		return *this;
	}
	unsigned int getPosNum(const unsigned int position) const {
		return position >= num.size() ? NULL : num[position];
	}
	unsigned int toUnsignedInt() {
		unsigned int u_i = 0;
		unsigned int digitNum = 1;
		unsigned int timNum = 2;
		int it = this->num.size() - 1;
		while (0 <= it) {
			u_i += this->num[it--] * digitNum;
			digitNum *= timNum++;
		}
		return u_i;
	}
};
//meiri.cpp
#include<iostream>
#include "HierarchicalNum.hpp"
using namespace std;

int main()
{
    unsignedHierarchicalNum u_n(100);
    u_n = 10;
    cout << u_n.toUnsignedInt();
    return 0;
}
*///已新建并测试了阶进制数类unsignedHierarchicalNum的返回无符号整数的重载赋值运算符^
/*
//meiri.cpp
#include<iostream>
#include "HierarchicalNum.hpp"
using namespace std;

int main()
{
    unsignedHierarchicalNum u_n(100);
    u_n += 10;
    cout << u_n.toUnsignedInt();
    return 0;
}
*///已测试阶进制数类unsignedHierarchicalNum的加等号运算符^
/*
//meiri.cpp
#include <iostream>
#include "HierarchicalNum.hpp"
using namespace std;

int main()
{
    unsignedHierarchicalNum u_n(100);
    u_n -= 10;
    cout << u_n.toUnsignedInt();
    return 0;
}
*///已测试阶进制数类unsignedHierarchicalNum的减等号运算符^
/*
//meiri.cpp
#include <iostream>
#include "HierarchicalNum.hpp"
using namespace std;

int main()
{
    unsignedHierarchicalNum u_n(100);
    cout << u_n++.toUnsignedInt() << endl;
    cout << (++u_n).toUnsignedInt() << endl;
    cout << u_n--.toUnsignedInt() << endl;
    cout << (--u_n).toUnsignedInt() << endl;
    return 0;
}
*///已测试阶进制数类unsignedHierarchicalNum的前缀自增运算符，后缀自增运算符，前缀自减运算符和后缀自减运算符^
/*
//HierarchicalNum.hpp
#include <iostream>
#include <vector>
using namespace std;
class unsignedHierarchicalNum
{
private:
	vector<unsigned int>num;
	unsigned int len;
	unsigned int toUnsignedInt(vector<unsigned int>& num) {
		unsigned int u_i = 0;
		unsigned int digitNum = 1;
		unsigned int timNum = 2;
		int it = num.size() - 1;
		while (0 <= it) {
			u_i += num[it--] * digitNum;
			digitNum *= timNum++;
		}
		return u_i;
	}
	void add(const int addNum, vector<unsigned int>& n) {
		unsigned int upNum = toUnsignedInt(n) + addNum;
		int it = n.size() - 1;
		unsigned int levelUp = 2;
		while (it >= 0) {
			n[it] = upNum % levelUp;
			upNum /= levelUp;
			levelUp++;
			it-- ? n[it] = upNum : 0;
		}
	}
	void sub(const int subNum, vector<unsigned int>& n) {
		unsigned int upNum = toUnsignedInt(n) - subNum;
		int it = n.size() - 1;
		unsigned int levelUp = 2;
		while (it >= 0) {
			n[it] = upNum % levelUp;
			upNum /= levelUp;
			levelUp++;
			it-- ? n[it] = upNum : 0;
		}
	}
public:
	unsignedHierarchicalNum(const unsigned int n, const unsigned int numLen = 0) {
		unsigned int tim = 1;
		unsigned int i = numLen ? numLen : 1;
		while (!numLen && tim < n) {
			tim *= ++i;
		}
		this->len = i;
		for (; i; i--) {
			this->num.push_back(0);
		}
		add(n, this->num);
	}
	unsignedHierarchicalNum operator+(const int n) {
		unsignedHierarchicalNum num(this->toUnsignedInt() + n);
		return num;
	}
	unsignedHierarchicalNum operator-(const int n) {
		unsignedHierarchicalNum num(this->toUnsignedInt() - n);
		return num;
	}
	unsignedHierarchicalNum& operator++() {
		add(1, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator--() {
		sub(1, this->num);
		return *this;
	}
	unsignedHierarchicalNum operator++(int) {
		unsignedHierarchicalNum num = *this;
		add(1, this->num);
		return num;
	}
	unsignedHierarchicalNum operator--(int) {
		unsignedHierarchicalNum num = *this;
		sub(1, this->num);
		return num;
	}
	unsignedHierarchicalNum& operator+=(const int addNum) {
		add(addNum, this->num);
		return *this;
	}
	unsignedHierarchicalNum& operator-=(const int subNum) {
		sub(subNum, this->num);
		return *this;
	}
	unsigned int operator=(unsigned int n) {
		unsigned int upNum = n;
		int it = this->num.size() - 1;
		unsigned int levelUp = 2;
		while (it >= 0) {
			this->num[it] = upNum % levelUp;
			upNum /= levelUp;
			levelUp++;
			it-- ? this->num[it] = upNum : 0;
		}
		return n;
	}
	unsignedHierarchicalNum& operator=(unsignedHierarchicalNum& n) {
		this->len = n.len;
		this->num = n.num;
		return *this;
	}
	unsigned int getPosNum(const unsigned int position) const {
		return position >= num.size() ? NULL : num[position];
	}
	unsigned int toUnsignedInt() {
		unsigned int u_i = 0;
		unsigned int digitNum = 1;
		unsigned int timNum = 2;
		int it = this->num.size() - 1;
		while (0 <= it) {
			u_i += this->num[it--] * digitNum;
			digitNum *= timNum++;
		}
		return u_i;
	}
};
//meiri.cpp
#include <iostream>
#include "HierarchicalNum.hpp"
using namespace std;

int main()
{
    unsignedHierarchicalNum u_n(100, 5);
    for (int i = 0; i < 5; i++) {
        cout << u_n.getPosNum(i);
    }
    cout << endl;
    return 0;
}
*///已修正阶进制数类unsignedHierarchicalNum的有参构造方法，并测试了该类的getPosNum方法^
/*
//HierarchicalNum.cpp
#include <iostream>
#include "HierarchicalNum.h"
using namespace std;
unsigned int getPosNum(const unsigned int u_i, const unsigned int index) {
	unsigned int digitNum = 1;
	unsigned int i = index + 1;
	while (i > 1) {
		digitNum *= i--;
	}
	return u_i / digitNum % (index + 2);
}
*///已新建并实现新的getPosNum方法^
/*
//meiri.cpp
#include <iostream>
#include "HierarchicalNum.h"
using namespace std;

int main()
{
    unsigned int u_i = 100;
    for (int i = 4; i > 0; i--) {
        cout << getPosNum(u_i, i);
    }
    return 0;
} 
*///已测试新的getPosNum方法的实现^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
public:
	Sequence(const unsigned int len) {

	}
	Sequence(const vector<T> f_items) {

	}
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {

	}
	vector<vector<T>>getSequence() {

	}
	unsigned int sequenceCount() {

	}
};
*///已新建并基本构建出Sequence类模板^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
public:
	Sequence() {
		this->maxNum = 1;
		this->swapNum = 0;
	}
	Sequence(const unsigned int len) {
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = len;
		while (this->maxNum *= factNum, factNum-- > 1){}
		while (len--) { this->items.push_back(0); }
	}
	Sequence(const vector<T> f_items) {
		this->items = f_items;
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = this->items.size();
		while (this->maxNum *= factNum, factNum-- > 1){}
	}
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {
		T tempItem = this->items[index];
		this->items[index] = this->items[indexa];
		this->items[indexa] = tempItem;
	}
	vector<vector<T>>getSequence() {

	}
	unsigned int sequenceCount() {
		return this->sequenceVector.size();
	}
	T pushBackItem(const T item) {
		
	}
	T popBackItem(const T item) {

	}
};
*///已新建并实现Sequence类的一些方法^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
public:
	Sequence() {
		this->maxNum = 1;
		this->swapNum = 0;
	}
	Sequence(const unsigned int len) {
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = len - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
		while (len--) { this->items.push_back(0); }
	}
	Sequence(const vector<T> f_items) {
		this->items = f_items;
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = this->items.size() - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
	}
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {
		T tempItem = this->items[index];
		this->items[index] = this->items[indexa];
		this->items[indexa] = tempItem;
	}
	vector<vector<T>>getSequence() {

	}
	unsigned int sequenceCount() {
		return this->sequenceVector.size();
	}
	T pushBackItem(const T item) {
		
	}
	T popBackItem(const T item) {

	}
};
*///已修正Sequence类的一些构造方法^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
public:
	Sequence() {
		this->maxNum = 1;
		this->swapNum = 0;
	}
	Sequence(const unsigned int len) {
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = len - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
		while (len--) { this->items.push_back(0); }
	}
	Sequence(const vector<T> f_items) {
		this->items = f_items;
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = this->items.size() - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
	}
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {
		T tempItem = this->items[index];
		this->items[index] = this->items[indexa];
		this->items[indexa] = tempItem;
	}
	vector<vector<T>>getSequence() {

	}
	unsigned int sequenceCount() {
		return this->sequenceVector.size();
	}
	T pushBackItem(const T item) {
		this->items.push_back(item);
		this->maxNum *= this->items.size() - 1;
	}
	T popBackItem(const T item) {

	}
};
*///已实现Sequence类的pushBackItem方法^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
public:
	Sequence() {
		this->maxNum = 1;
		this->swapNum = 0;
	}
	Sequence(const unsigned int len) {
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = len - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
		while (len--) { this->items.push_back(0); }
	}
	Sequence(const vector<T> f_items) {
		this->items = f_items;
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = this->items.size() - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
	}
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {
		T tempItem = this->items[index];
		this->items[index] = this->items[indexa];
		this->items[indexa] = tempItem;
	}
	vector<vector<T>>getSequence() {

	}
	unsigned int sequenceCount() {
		return this->sequenceVector.size();
	}
	T pushBackItem(const T item) {
		int oldSize = this->items.size()
		this->items.push_back(item);
		this->maxNum *= oldSize <= 1 ? 1 : oldSize - 1;
	}
	T popBackItem(const T item) {

	}
};
*///已修正Sequence类的pushBackItem方法^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
public:
	Sequence() {
		this->maxNum = 1;
		this->swapNum = 0;
	}
	Sequence(const unsigned int len) {
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = len - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
		while (len--) { this->items.push_back(0); }
	}
	Sequence(const vector<T> f_items) {
		this->items = f_items;
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = this->items.size() - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
	}
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {
		T tempItem = this->items[index];
		this->items[index] = this->items[indexa];
		this->items[indexa] = tempItem;
	}
	vector<vector<T>>getSequence() {

	}
	unsigned int sequenceCount() {
		return this->sequenceVector.size();
	}
	T pushBackItem(const T item) {
		this->items.push_back(item);
		this->maxNum *= this->items.size();
	}
	T popBackItem(const T item) {
		if (this->items.size()) {
			this->maxNum /= this->items.size();
			this->items.pop_back(item);
		}
	}
};
*///已重新修正pushBackItem方法，并实现了popBackItem方法^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
public:
	Sequence() {
		this->maxNum = 1;
		this->swapNum = 0;
	}
	Sequence(const unsigned int len) {
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = len - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
		while (len--) { this->items.push_back(0); }
	}
	Sequence(const vector<T> f_items) {
		this->items = f_items;
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = this->items.size() - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
	}
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {
		T tempItem = this->items[index];
		this->items[index] = this->items[indexa];
		this->items[indexa] = tempItem;
	}
	vector<vector<T>>getSequence() {
		vector<vector<T>>Sequences;
		Sequences.push_back(this->items);
		this->swapNum = 1;
		while (swapNum < this->maxNum) {
			
			swapNum++;
		}
	}
	unsigned int sequenceCount() {
		return this->sequenceVector.size();
	}
	T pushBackItem(const T item) {
		this->items.push_back(item);
		this->maxNum *= this->items.size();
	}
	T popBackItem(const T item) {
		if (this->items.size()) {
			this->maxNum /= this->items.size();
			this->items.pop_back(item);
		}
	}
};
*///已实现Sequence类的getSequence方法的基础^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
public:
	Sequence() {
		this->maxNum = 1;
		this->swapNum = 0;
	}
	Sequence(const unsigned int len) {
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = len - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
		while (len--) { this->items.push_back(0); }
	}
	Sequence(const vector<T> f_items) {
		this->items = f_items;
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = this->items.size() - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
	}
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {
		T tempItem = this->items[index];
		this->items[index] = this->items[indexa];
		this->items[indexa] = tempItem;
	}
	vector<vector<T>>getSequence() {
		if (this->items.size()) {
			vector<vector<T>>Sequences;
			Sequences.push_back(this->items);
			this->swapNum = 1;
			int digitNum = this->items.size() - 1;
			int swapIndex = 0;
			int index = this->items.size() - 2;
			while (swapNum < this->maxNum) {
				for (swapIndex = 0, index = this->items.size() - 2; index > 0; index--, swapIndex++) {
					swapVectorItem(index, index + getPosNum(swapNum, swapIndex));
				}
				Sequences.push_back(this->items);
				for (swapIndex = 0, index = this->items.size() - 2; index > 0; index--, swapIndex++) {
					swapVectorItem(index, index + getPosNum(swapNum, swapIndex));
				}
				swapNum++;
			}
		}
	}
	unsigned int sequenceCount() {
		return this->sequenceVector.size();
	}
	T pushBackItem(const T item) {
		this->items.push_back(item);
		this->maxNum *= this->items.size();
	}
	T popBackItem(const T item) {
		if (this->items.size()) {
			this->maxNum /= this->items.size();
			this->items.pop_back(item);
		}
	}
};
*///已实现Sequence类的getSequence方法^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {
		T tempItem = this->items[index];
		this->items[index] = this->items[indexa];
		this->items[indexa] = tempItem;
	}
public:
	Sequence() {
		this->maxNum = 1;
		this->swapNum = 0;
	}
	Sequence(const unsigned int len) {
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = len - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
		while (len--) { this->items.push_back(0); }
	}
	Sequence(const vector<T> f_items) {
		this->items = f_items;
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = this->items.size() - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
	}
	vector<vector<T>>getSequence() {
		this->sequenceVector.clear();
		if (this->items.size()) {
			this->sequenceVector.push_back(this->items);
			this->swapNum = 1;
			int digitNum = this->items.size() - 1;
			int swapIndex = 0;
			int index = this->items.size() - 2;
			while (swapNum < this->maxNum) {
				for (swapIndex = 0, index = this->items.size() - 2; index > 0; index--, swapIndex++) {
					swapVectorItem(index, index + getPosNum(swapNum, swapIndex));
				}
				Sequences.push_back(this->items);
				for (swapIndex = 0, index = this->items.size() - 2; index > 0; index--, swapIndex++) {
					swapVectorItem(index, index + getPosNum(swapNum, swapIndex));
				}
				swapNum++;
			}
		}
		return Sequence
	}
	unsigned int sequenceCount() {
		return this->sequenceVector.size();
	}
	T pushBackItem(const T item) {
		this->items.push_back(item);
		this->maxNum *= this->items.size();
	}
	T popBackItem(const T item) {
		if (this->items.size()) {
			this->maxNum /= this->items.size();
			this->items.pop_back(item);
		}
	}
};
*///已将一个方法转为私有方法^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {
		T tempItem = this->items[index];
		this->items[index] = this->items[indexa];
		this->items[indexa] = tempItem;
	}
public:
	Sequence() {
		this->maxNum = 1;
		this->swapNum = 0;
	}
	Sequence(const unsigned int len) {
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = len - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
		while (len--) { this->items.push_back(0); }
	}
	Sequence(const vector<T> f_items) {
		this->items = f_items;
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = this->items.size() - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
	}
	vector<vector<T>>getSequence() {
		this->sequenceVector.clear();
		if (this->items.size()) {
			this->sequenceVector.push_back(this->items);
			this->swapNum = 1;
			int digitNum = this->items.size() - 1;
			int swapIndex = 0;
			int index = this->items.size() - 2;
			while (swapNum < this->maxNum) {
				for (swapIndex = 0, index = this->items.size() - 2; index > 0; index--, swapIndex++) {
					swapVectorItem(index, index + getPosNum(swapNum, swapIndex));
				}
				this->sequenceVector.push_back(this->items);
				for (swapIndex = 0, index = this->items.size() - 2; index > 0; index--, swapIndex++) {
					swapVectorItem(index, index + getPosNum(swapNum, swapIndex));
				}
				swapNum++;
			}
		}
		return this->sequenceVector;
	}
	unsigned int sequenceCount() {
		return this->sequenceVector.size();
	}
	T pushBackItem(const T item) {
		this->items.push_back(item);
		this->maxNum *= this->items.size();
	}
	T popBackItem(const T item) {
		if (this->items.size()) {
			this->maxNum /= this->items.size();
			this->items.pop_back(item);
		}
	}
};
*///已修正好Sequence类的getSequence方法^
/*
//meiri.cpp
#include <iostream>
#include "Sequence.hpp"
using namespace std;

int main()
{
    Sequence<int>s;
    return 0;
}
*///已测试Sequence类的无参构造方法^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {
		T tempItem = this->items[index];
		this->items[index] = this->items[indexa];
		this->items[indexa] = tempItem;
	}
public:
	Sequence() {
		this->maxNum = 1;
		this->swapNum = 0;
	}
	Sequence(unsigned int len) {
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = len - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
		while (len--) { this->items.push_back(0); }
	}
	Sequence(const vector<T> f_items) {
		this->items = f_items;
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = this->items.size() - 1;
		while (this->maxNum *= factNum, factNum-- > 1){}
	}
	vector<vector<T>>getSequence() {
		this->sequenceVector.clear();
		if (this->items.size()) {
			this->sequenceVector.push_back(this->items);
			this->swapNum = 1;
			int digitNum = this->items.size() - 1;
			int swapIndex = 0;
			int index = this->items.size() - 2;
			while (swapNum < this->maxNum) {
				for (swapIndex = 0, index = this->items.size() - 2; index > 0; index--, swapIndex++) {
					swapVectorItem(index, index + getPosNum(swapNum, swapIndex));
				}
				this->sequenceVector.push_back(this->items);
				for (swapIndex = 0, index = this->items.size() - 2; index > 0; index--, swapIndex++) {
					swapVectorItem(index, index + getPosNum(swapNum, swapIndex));
				}
				swapNum++;
			}
		}
		return this->sequenceVector;
	}
	unsigned int sequenceCount() {
		return this->sequenceVector.size();
	}
	T pushBackItem(const T item) {
		this->items.push_back(item);
		this->maxNum *= this->items.size();
	}
	T popBackItem(const T item) {
		if (this->items.size()) {
			this->maxNum /= this->items.size();
			this->items.pop_back(item);
		}
	}
};
//meiri.cpp
#include <iostream>
#include "Sequence.hpp"
using namespace std;

int main()
{
    Sequence<int>s(5);
    return 0;
}
*///已测试并修正了Sequence类的长度构造方法^
/*
//meiri.cpp
#include <iostream>
#include "Sequence.hpp"
using namespace std;

int main()
{
    vector<int>v = { 1, 2, 3 };
    Sequence<int>s = v;
    return 0;
}
*///已测试Sequence类的vector数组构造方法^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {
		T tempItem = this->items[index];
		this->items[index] = this->items[indexa];
		this->items[indexa] = tempItem;
	}
	bool isUnique(const vector<T> checkVector) {
		for (vector<T> v : this->sequenceVector) {
			if (checkVector == v) {
				return false;
			}
		}
		return true;
	}
public:
	Sequence() {
		this->maxNum = 1;
		this->swapNum = 0;
	}
	Sequence(unsigned int len) {
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = len;
		while (this->maxNum *= factNum, factNum-- > 1){}
		while (len--) { this->items.push_back(0); }
	}
	Sequence(const vector<T> f_items) {
		this->items = f_items;
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = this->items.size();
		while (this->maxNum *= factNum, factNum-- > 1){}
	}
	vector<vector<T>>getSequence() {
		this->sequenceVector.clear();
		if (this->items.size()) {
			this->sequenceVector.push_back(this->items);
			this->swapNum = 1;
			int digitNum = this->items.size() - 1;
			int swapIndex = 0;
			int index = this->items.size() - 2;
			vector<T>tempItems = this->items;
			while (swapNum < this->maxNum) {
				for (swapIndex = this->items.size() - 2, index = 0; index < this->items.size() - 1; index++, swapIndex--) {
					swapVectorItem(index, index + getPosNum(swapNum, swapIndex));
				}
				if (isUnique(this->items)) {
					this->sequenceVector.push_back(this->items);
				}
				this->items = tempItems;
				swapNum++;
			}
		}
		return this->sequenceVector;
	}
	unsigned int sequenceCount() {
		return this->sequenceVector.size();
	}
	T pushBackItem(const T item) {
		this->items.push_back(item);
		this->maxNum *= this->items.size();
	}
	T popBackItem(const T item) {
		if (this->items.size()) {
			this->maxNum /= this->items.size();
			this->items.pop_back(item);
		}
	}
};
//meiri.cpp
#include <iostream>
#include "Sequence.hpp"
using namespace std;

int main()
{
    vector<int>v = { 1, 2, 3 };
    Sequence<int>s = v;
    vector<vector<int>>vv = s.getSequence();
    for (vector<int> v : vv) {
        for (int i : v) {
            cout << i << " ";
        }
        cout << endl;
    }
    return 0;
}
*///已测试并修正了Sequence类的getSequence方法^
/*
//meiri.cpp
#include <iostream>
#include "Sequence.hpp"
using namespace std;

int main()
{
    vector<int>v = { 1, 2, 3, 4 };
    Sequence<int>s = v;
    cout << s.sequenceCount() << " ";
    s.getSequence();
    cout << s.sequenceCount() << endl;
    return 0;
}
*///已测试Sequence类的sequenceCount方法^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {
		T tempItem = this->items[index];
		this->items[index] = this->items[indexa];
		this->items[indexa] = tempItem;
	}
	bool isUnique(const vector<T> checkVector) {
		for (vector<T> v : this->sequenceVector) {
			if (checkVector == v) {
				return false;
			}
		}
		return true;
	}
public:
	Sequence() {
		this->maxNum = 1;
		this->swapNum = 0;
	}
	Sequence(unsigned int len) {
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = len;
		while (this->maxNum *= factNum, factNum-- > 1){}
		while (len--) { this->items.push_back(0); }
	}
	Sequence(const vector<T> f_items) {
		this->items = f_items;
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = this->items.size();
		while (this->maxNum *= factNum, factNum-- > 1){}
	}
	vector<vector<T>>getSequence() {
		this->sequenceVector.clear();
		if (this->items.size()) {
			this->sequenceVector.push_back(this->items);
			this->swapNum = 1;
			int digitNum = this->items.size() - 1;
			int swapIndex = 0;
			int index = this->items.size() - 2;
			vector<T>tempItems = this->items;
			while (swapNum < this->maxNum) {
				for (swapIndex = this->items.size() - 2, index = 0; index < this->items.size() - 1; index++, swapIndex--) {
					swapVectorItem(index, index + getPosNum(swapNum, swapIndex));
				}
				if (isUnique(this->items)) {
					this->sequenceVector.push_back(this->items);
				}
				this->items = tempItems;
				swapNum++;
			}
		}
		return this->sequenceVector;
	}
	unsigned int sequenceCount() {
		return this->sequenceVector.size();
	}
	T pushBackItem(const T item) {
		this->items.push_back(item);
		this->maxNum *= this->items.size();
		return item;
	}
	T popBackItem() {
		if (this->items.size()) {
			T item = this->items.back();
			this->maxNum /= this->items.size();
			this->items.pop_back();
			return item;
		}
		else {
			return NULL;
		}
	}
};
//meiri.cpp
#include <iostream>
#include "Sequence.hpp"
using namespace std;

int main()
{
    vector<int>v = { 1, 2, 3, 4 };
    Sequence<int>sa;
    sa.popBackItem();
    Sequence<int>s = v;
    s.popBackItem();
    s.getSequence();
    cout << s.sequenceCount() << endl;
    return 0;
}
*///已测试并修正了Sequence类的popBackItem方法^
/*
//meiri.cpp
#include <iostream>
#include "Sequence.hpp"
using namespace std;

int main()
{
    vector<int>v = { 1, 3, 3, 3 };
    Sequence<int>s = v;
    vector<vector<int>>vv = s.getSequence();
    for (vector<int> v : vv) {
        for (int i : v) {
            cout << i << " ";
        }
        cout << endl;
    }
    return 0;
}
*///已测试Sequence类的在Sequence类的items数组中元素不唯一的情况下执行的getSequence方法^
/*
//meiri.cpp
#include <iostream>
#include "Sequence.hpp"
using namespace std;

int main()
{
    vector<char>v = { 'a', 'b', 'c', 'd', 'e', 'f', 'g'};
    Sequence<char>s = v;
    vector<vector<char>>vv = s.getSequence();
    for (vector<char> v : vv) {
        for (char ch : v) {
            cout << ch << " ";
        }
        cout << endl;
    }
    return 0;
}
*///Sequence类的最后一次测试^
/*
//stringPlus.h
#pragma once
#include <iostream>
using namespace std;
class stringPlus {
private:
	string last;
public:
	string getLast();
	string calc(string str, string stra);
};
//stringCalc.cpp
#include "stringPlus.h"
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();

	return this->last;
}
*///已构建出stringPlus类的基础^
/*
//stringPlus.cpp
#include "stringPlus.h"
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();
	bool isAddOne = false;
	bool itIsZero = str.size();
	bool itaIsZero = stra.size();
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero) {
		digitNum = (itIsZero ? 0 : *it++) + (itaIsZero ? 0 : *ita++) + isAddOne;
		isAddOne = digitNum / 10;
		digitNum %= 10;
		this->last.insert(this->last.begin(), '0' + digitNum);
		if (str.crend() == it) {
			itIsZero = true;
		}
		if (stra.crend() == ita) {
			itaIsZero = true;
		}
	}
	return this->last;
}
*///已实现stringPlus类的calc方法^
/*
//stringPlus.cpp
#include "stringPlus.h"
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();
	bool isAddOne = false;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero) {
		digitNum = (itIsZero ? 0 : *it++ - '0') + (itaIsZero ? 0 : *ita++ - '0') + isAddOne;
		isAddOne = digitNum / 10;
		digitNum %= 10;
		this->last.insert(this->last.begin(), '0' + digitNum);
		if (str.crend() == it) {
			itIsZero = true;
		}
		if (stra.crend() == ita) {
			itaIsZero = true;
		}
	}
	return this->last;
}
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
using namespace std;

int main() {
    stringPlus sp;
    string str = sp.calc("11", "11");
    cout << str << endl;
    return 0;
}
*///已初步测试并修正了stringPlus类的calc方法^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
using namespace std;

int main() {
    stringPlus sp;
    sp.calc("11", "11");
    string str = sp.getLast();
    cout << str << endl;
    return 0;
}
*///已测试stringPlus类的getLast方法^
/*
//stringPlus.cpp
#include "stringPlus.h"
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();
	bool isAddOne = false;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero) {
		digitNum = (itIsZero ? 0 : *it++ - '0') + (itaIsZero ? 0 : *ita++ - '0') + isAddOne;
		isAddOne = digitNum / 10;
		digitNum %= 10;
		this->last.insert(this->last.begin(), '0' + digitNum);
		if (str.crend() == it) {
			itIsZero = true;
		}
		if (stra.crend() == ita) {
			itaIsZero = true;
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	return this->last;
}
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
using namespace std;

int main() {
    stringPlus sp;
    cout << sp.calc("12345", "") << " " << sp.calc("", "") << " " << sp.calc("12345", "12345") << " " << sp.calc("16262323445364387934457643645364", "18231723462347892372349234790") << " " << endl;
    return 0;
}
*///已测试stringPlus类的空字符串计算与大值计算^
/*
//stringCalc.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool isNegative = false;
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		digitNum = (itIsZero ? 0 : (1 - strIsNegative * 2) * (*it - '0')) + (itaIsZero ? 0 : (1 - straIsNegative * 2) * (*ita - '0')) + addNum;
		isNegative = digitNum ? digitNum < 0 : isNegative;
		addNum = (1 - 2 * (itIsZero || str.crend() == it ? 0 : 1 - 2 * strIsNegative * *it) < (itaIsZero || stra.crend() == ita ? 0 : 1 - 2 * straIsNegative * *ita)) * digitNum / 10;
		digitNum = (itIsZero || str.crend() == it ? 0 : 1 - 2 * strIsNegative * *it) < (itaIsZero || stra.crend() == ita ? 0 : 1 - 2 * straIsNegative * *ita) ? 10 + digitNum : abs(digitNum %= 10);
		if (!itaIsZero || !itIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
		(itIsZero || (it++, 0)), (itaIsZero || (ita++, 0));
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	return this->last;
}
*///calc方法就先改到这边^
/*
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	bool isNegative = false;
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = ix + iy + addNum;
		isNegative = digitNum ? digitNum < 0 : isNegative;
		addNum = tenSub && !itIsZero && iy ? -1 : (ix + iy) / 10;
		digitNum = tenSub && !itIsZero && iy ? abs(ix) + abs(iy) : abs(digitNum %= 10);
		if (!itaIsZero || !itIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	return this->last;
}
*///稍微修改了一下calc方法^
/*
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	bool isNegative = false;
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = ix + iy + addNum;
		isNegative = digitNum ? digitNum < 0 : isNegative;
		addNum = digitNum < 0 ? -1 : digitNum / 10;
		digitNum = abs(digitNum < 0 * 10 + (digitNum % 10));
		if (!itaIsZero || !itIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	return this->last;
}
*///再修改了一下calc方法^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {
		T tempItem = this->items[index];
		this->items[index] = this->items[indexa];
		this->items[indexa] = tempItem;
	}
	bool isUnique(const vector<T> checkVector) {
		for (vector<T> v : this->sequenceVector) {
			if (checkVector == v) {
				return false;
			}
		}
		return true;
	}
public:
	Sequence() {
		this->maxNum = 1;
		this->swapNum = 0;
	}
	Sequence(unsigned int len) {
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = len;
		while (this->maxNum *= factNum, factNum-- > 1){}
		while (len--) { this->items.push_back(0); }
	}
	Sequence(const vector<T> f_items) {
		this->items = f_items;
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = this->items.size();
		while (this->maxNum *= factNum, factNum-- > 1){}
	}
	vector<vector<T>> getSequence() {
		this->sequenceVector.clear();
		if (this->items.size()) {
			this->sequenceVector.push_back(this->items);
			this->swapNum = 1;
			int digitNum = this->items.size() - 1;
			int swapIndex = 0;
			int index = this->items.size() - 2;
			vector<T>tempItems = this->items;
			while (swapNum < this->maxNum) {
				for (swapIndex = this->items.size() - 2, index = 0; index < this->items.size() - 1; index++, swapIndex--) {
					swapVectorItem(index, index + getPosNum(swapNum, swapIndex));
				}
				if (isUnique(this->items)) {
					this->sequenceVector.push_back(this->items);
				}
				this->items = tempItems;
				swapNum++;
			}
		}
		else {
			this->sequenceVector.push_back(this->items);
		}
		return this->sequenceVector;
	}
	unsigned int sequenceCount() const {
		return this->sequenceVector.size();
	}
	T pushBackItem(const T item) {
		this->items.push_back(item);
		this->maxNum *= this->items.size();
		return item;
	}
	T popBackItem() {
		if (this->items.size()) {
			T item = this->items.back();
			this->maxNum /= this->items.size();
			this->items.pop_back();
			return item;
		}
		else {
			return NULL;
		}
	}
};
*///已修正getSequence方法的实现^
/*
//meiri.cpp
#include <iostream>
#include "Sequence.hpp"
using namespace std;

int main()
{
    vector<int>v = { 1 };
    Sequence<int>s;
    Sequence<int>sa = v;
    s.getSequence();
    sa.getSequence();
    cout << s.sequenceCount() << " " << sa.sequenceCount() << endl;
    return 0;
}
*///已测试Sequence类修正之后的getSequence方法^
/*
//Sequence.hpp
#include <iostream>
#include <vector>
#include "HierarchicalNum.h"
using namespace std;
template<class T>
class Sequence {
private:
	vector<T>items;
	vector<vector<T>>sequenceVector;
	unsigned int maxNum;
	unsigned int swapNum;
	void swapVectorItem(const unsigned int index, const unsigned int indexa) {
		T tempItem = this->items[index];
		this->items[index] = this->items[indexa];
		this->items[indexa] = tempItem;
	}
	bool isUnique(const vector<T> checkVector) {
		for (vector<T> v : this->sequenceVector) {
			if (checkVector == v) {
				return false;
			}
		}
		return true;
	}
public:
	Sequence() {
		this->maxNum = 1;
		this->swapNum = 0;
	}
	Sequence(unsigned int len) {
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = len;
		while (this->maxNum *= factNum, factNum-- > 1){}
		while (len--) { this->items.push_back(0); }
	}
	Sequence(const vector<T> f_items) {
		this->items = f_items;
		this->maxNum = 1;
		this->swapNum = 0;
		unsigned int factNum = this->items.size();
		while (this->maxNum *= factNum, factNum-- > 1){}
	}
	vector<vector<T>> getSequence() {
		this->sequenceVector.clear();
		if (this->items.size()) {
			this->sequenceVector.push_back(this->items);
			this->swapNum = 1;
			int swapIndex = this->items.size() - 2;
			int index = 0;
			vector<T>tempItems = this->items;
			while (swapNum < this->maxNum) {
				for (swapIndex = this->items.size() - 2, index = 0; index < this->items.size() - 1; index++, swapIndex--) {
					swapVectorItem(index, index + getPosNum(swapNum, swapIndex));
				}
				if (isUnique(this->items)) {
					this->sequenceVector.push_back(this->items);
				}
				this->items = tempItems;
				swapNum++;
			}
		}
		else {
			this->sequenceVector.push_back(this->items);
		}
		return this->sequenceVector;
	}
	unsigned int sequenceCount() const {
		return this->sequenceVector.size();
	}
	T pushBackItem(const T item) {
		this->items.push_back(item);
		this->maxNum *= this->items.size();
		return item;
	}
	T popBackItem() {
		if (this->items.size()) {
			T item = this->items.back();
			this->maxNum /= this->items.size();
			this->items.pop_back();
			return item;
		}
		else {
			return NULL;
		}
	}
};
*///已删除Sequence类中的getSequence方法中的多余的digitNum变量^
/*
//meiri.cpp
#include <iostream>
#include "Sequence.hpp"
using namespace std;

int main()
{
    vector<int>v = { 1 };
    vector<int>va = { 1, 2, 3, 4 };
    Sequence<int>s;
    Sequence<int>sa = v;
    Sequence<int>sc = va;
    s.getSequence();
    sa.getSequence();
    vector<vector<int>>vv = sc.getSequence();
    cout << s.sequenceCount() << " " << sa.sequenceCount() << " " << sc.sequenceCount() << endl;
    for (vector<int> v : vv) {
        for (int i : v) {
            cout << i << " ";
        }
        cout << endl;
    }
    return 0;
}
*///已测试删掉多余变量digitNum之后的Sequence类的getSequence方法^
/*
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == false;
	bool isNegative = '-' == (abs(atoi(str.c_str())) > abs(atoi(stra.c_str())) ? str.front() : stra.front());
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = ix + iy + addNum;
		addNum = digitNum < 0 ? -1 : digitNum / 10;
		digitNum = abs(digitNum < 0 * 10 + (digitNum % 10));
		if (!itaIsZero || !itIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	return this->last;
}
*///已重新初始化变量isNegative^
/*
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == false;
	bool isNegative = '-' == (abs(atoi(str.c_str())) > abs(atoi(stra.c_str())) ? str.front() : stra.front());
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = ix + iy + !(0 > addNum && 2 == itIsZero + itaIsZero) * addNum;
		addNum = abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itaIsZero || !itIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	return this->last;
}
*///stringPlus类的calc方法结果的准确率已上升到50%左右^
/*
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == false;
	bool isNegative = '-' == (abs(atoi(str.c_str())) > abs(atoi(stra.c_str())) ? str.front() : stra.front());
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	return this->last;
}
*///修改了一下stringPlus类的calc方法^
/*
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	bool isNegative = '-' == (abs(atoi(str.c_str())) > abs(atoi(stra.c_str())) ? str.front() : stra.front());
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	return this->last;
}
*///再修改了一下stringPlus类的calc方法^
/*
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	bool isNegative = '-' == (abs(atoi(str.c_str())) > abs(atoi(stra.c_str())) ? str.front() : stra.front());
	int id = 0;
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	while (('0' > this->last[id] || '9' < this->last[id]) && id < this->last.size()) {
		id++;
	}
	while (id < this->last.size() && '0' == this->last[id]) {
		this->last.erase(id);
	}
	return this->last;
}
*///修改了一下stringPlus类的calc方法^
/*
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	bool isNegative = '-' == (abs(atoi(str.c_str())) > abs(atoi(stra.c_str())) ? str.front() : stra.front());
	int id = 0;
	int toDel = 0;
	string tempstr;
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	while ('-' == this->last[id] && id < this->last.size()) {
		id++;
	}
	while (id < this->last.size() && '0' == this->last[id]) {
		toDel = 0;
		while (toDel < this->last.size()) {
			if (toDel == id && ++toDel) {
				continue;
			}
			tempstr.push_back(this->last[toDel++]);
		}
		this->last = tempstr;
	}
	return this->last;
}
*///calc方法基本无问题^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
using namespace std;

int main() {
    stringPlus sp;
    cout << sp.calc("-100", "1") <<  endl;
    return 0;
}
*///已测试新的strinmgPlus类新的calc方法^
/*
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	bool isNegative = '-' == (abs(atoi(str.c_str())) > abs(atoi(stra.c_str())) ? str.front() : stra.front());
	int id = 0;
	int toDel = 0;
	string tempstr;
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	while ('-' == this->last[id] && id < this->last.size()) {
		id++;
	}
	while (id < this->last.size() && '0' == this->last[id]) {
		toDel = 0;
		while (toDel < this->last.size()) {
			if (toDel == id && ++toDel) {
				continue;
			}
			tempstr.push_back(this->last[toDel++]);
		}
		this->last = tempstr;
	}
	return this->last;
}
*///已再次优化stringPlus类的calc方法^
/*
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::calc(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	bool isNegative = '-' == (abs(atoi(str.c_str())) > abs(atoi(stra.c_str())) ? str.front() : stra.front());
	int id = 0;
	int toDel = 0;
	string tempstr;
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	while ('-' == this->last[id] && id < this->last.size()) {
		id++;
	}
	while (id < this->last.size() && '0' == this->last[id]) {
		toDel = 0;
		while (toDel < this->last.size()) {
			if (toDel == id && ++toDel) {
				continue;
			}
			tempstr.push_back(this->last[toDel++]);
		}
		this->last = tempstr;
	}
	return this->last;
}
*///已新添str和stra字符串的过滤无效字符功能^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
using namespace std;

int main() {
    stringPlus sp;
    cout << sp.calc("-1|0", "7a6") <<  endl;
    return 0;
}
*///已测试stringPlus类的过滤无效字符功能^
/*
//stringPlus.h
#pragma once
#include <iostream>
using namespace std;
class stringPlus {
protected:
	string last;
public:
	virtual string getLast();
	virtual string calc(string str, string stra);
};
*///已修改stringPlus类的构造^
/*
//stringSub.h
#pragma once
#include "stringPlus.h"
#include <iostream>
using namespace std;
class stringSub : public stringPlus {
public:
	string calc(string str, string stra);
};
//stringSub.cpp
#include "stringSub.h"
string stringSub::calc(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = !(stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	bool isNegative = '-' == (abs(atoi(str.c_str())) > abs(atoi(stra.c_str())) ? str.front() : stra.front());
	int id = 0;
	int toDel = 0;
	string tempstr;
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	while ('-' == this->last[id] && id < this->last.size()) {
		id++;
	}
	while (id < this->last.size() && '0' == this->last[id]) {
		toDel = 0;
		while (toDel < this->last.size()) {
			if (toDel == id && ++toDel) {
				continue;
			}
			tempstr.push_back(this->last[toDel++]);
		}
		this->last = tempstr;
	}
	return this->last;
}
*///已新建stringSub.h与stringSub.cpp程序文件^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
using namespace std;

int main() {
    stringPlus sp;
    cout << sp.calc(sp.calc("-10", "7"), "999") << endl;
    return 0;
}
*///已测试字符串的连续计算^
/*
//stringPlus.h
#pragma once
#include <iostream>
using namespace std;
class stringPlus {
protected:
	string last;
public:
	virtual string getLast();
	virtual string add(string str, string stra);
};
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::add(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	bool isNegative = '-' == (abs(atoi(str.c_str())) > abs(atoi(stra.c_str())) ? str.front() : stra.front());
	int id = 0;
	int toDel = 0;
	string tempstr;
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	while ('-' == this->last[id] && id < this->last.size()) {
		id++;
	}
	while (id < this->last.size() && '0' == this->last[id]) {
		toDel = 0;
		while (toDel < this->last.size()) {
			if (toDel == id && ++toDel) {
				continue;
			}
			tempstr.push_back(this->last[toDel++]);
		}
		this->last = tempstr;
	}
	return this->last;
}
//stringSub.h
#pragma once
#include "stringPlus.h"
#include <iostream>
using namespace std;
class stringSub{
private:
	string last;
public:
	string getLast();
	string sub(string str, string stra);
};
//stringSub.cpp
#include "stringSub.h"
string stringSub::getLast() {
	return this->last;
}
string stringSub::sub(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = !(stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	bool isNegative = '-' == (abs(atoi(str.c_str())) > abs(atoi(stra.c_str())) ? str.front() : stra.front());
	int id = 0;
	int toDel = 0;
	string tempstr;
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	while ('-' == this->last[id] && id < this->last.size()) {
		id++;
	}
	while (id < this->last.size() && '0' == this->last[id]) {
		toDel = 0;
		while (toDel < this->last.size()) {
			if (toDel == id && ++toDel) {
				continue;
			}
			tempstr.push_back(this->last[toDel++]);
		}
		this->last = tempstr;
	}
	return this->last;
}
*///已更改stringPlus类与stringSub类的方法名字^
/*
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::add(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	int absStr = abs(atoi(str.c_str()));
	int absStra = abs(atoi(stra.c_str()));
	bool isNegative = '-' == (absStr > absStra ? str.front() : absStr == absStra ? false : stra.front());
	int id = 0;
	int toDel = 0;
	string tempstr;
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	while ('-' == this->last[id] && id < this->last.size()) {
		id++;
	}
	while (id < this->last.size() && '0' == this->last[id]) {
		toDel = 0;
		while (toDel < this->last.size()) {
			if (toDel == id && ++toDel) {
				continue;
			}
			tempstr.push_back(this->last[toDel++]);
		}
		this->last = tempstr;
	}
	return this->last;
}
*///已修改isNegative变量的初始化方式^
/*
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::add(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	int absStr = abs(atoi(str.c_str()));
	int absStra = abs(atoi(stra.c_str()));
	bool isNegative = '-' == (absStr > absStra ? str.front() : absStr == absStra ? false : stra.front());
	int id = 0;
	int toDel = 0;
	string tempstr;
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	while ('-' == this->last[id] && id < this->last.size()) {
		id++;
	}
	while (id < this->last.size() - 1 && '0' == this->last[id]) {
		toDel = 0;
		while (toDel < this->last.size()) {
			if (toDel == id && ++toDel) {
				continue;
			}
			tempstr.push_back(this->last[toDel++]);
		}
		this->last = tempstr;
	}
	return this->last;
}
*///已修改last字符串的删除多余字符的方式^
/*
//stringSub.cpp
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = !(stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	int absStr = abs(atoi(str.c_str()));
	int absStra = abs(atoi(stra.c_str()));
	bool isNegative = '-' == (absStr > absStra ? str.front() : absStr == absStra ? false : stra.front());
	int id = 0;
	int toDel = 0;
	string tempstr;
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	while ('-' == this->last[id] && id < this->last.size()) {
		id++;
	}
	while (id < this->last.size() - 1 && '0' == this->last[id]) {
		toDel = 0;
		while (toDel < this->last.size()) {
			if (toDel == id && ++toDel) {
				continue;
			}
			tempstr.push_back(this->last[toDel++]);
		}
		this->last = tempstr;
	}
	return this->last;
}
*///已修改stringSub类的sub方法^
/*
//stringPlus.cpp
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	int id = 0;
	int toDel = 0;
	string tempstr;
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	int absStr = abs(atoi(str.c_str()));
	int absStra = abs(atoi(stra.c_str()));
	bool isNegative = '-' == (absStr > absStra ? str.front() : absStr == absStra ? false : stra.front());
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	while ('-' == this->last[id] && id < this->last.size()) {
		id++;
	}
	while (id < this->last.size() - 1 && '0' == this->last[id]) {
		toDel = 0;
		while (toDel < this->last.size()) {
			if (toDel == id && ++toDel) {
				continue;
			}
			tempstr.push_back(this->last[toDel++]);
		}
		this->last = tempstr;
	}
	return this->last;
}
*///已修改stringPlus类的add方法^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
using namespace std;

int main() {
    stringPlus sp;
    stringSub ss;
    cout << ss.sub(sp.add("3", ""), "2");
    return 0;
}
*///已测试stringPlus类和stringSub类的字符串混合计算^
/*
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
	return this->last;
}
string stringPlus::add(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	int id = 0;
	int toDel = 0;
	string tempstr;
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	int absStr = abs(atoi(str.c_str()));
	int absStra = abs(atoi(stra.c_str()));
	bool isNegative = '-' == (absStr > absStra ? str.front() : absStr == absStra ? false : stra.front());
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum || digitNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	while ('-' == this->last[id] && id < this->last.size()) {
		id++;
	}
	while (id < this->last.size() - 1 && '0' == this->last[id]) {
		toDel = 0;
		while (toDel < this->last.size()) {
			if (toDel == id && ++toDel) {
				continue;
			}
			tempstr.push_back(this->last[toDel++]);
		}
		this->last = tempstr;
	}
	return this->last;
}
*///已修正stringPlus方法中的一些bug^
/*
//stringSub.cpp
#include "stringSub.h"
string stringSub::getLast() {
	return this->last;
}
string stringSub::sub(string str, string stra) {
	this->last.clear();
	int addNum = 0;
	int ix = 0;
	int iy = 0;
	int id = 0;
	int toDel = 0;
	string tempstr;
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if ('-' != stra.front()) {
		stra.insert(0, "-");
	}
	else {
		for (int i = 0; i < stra.size() - 1; i++) {
			stra[i] = stra[i + 1];
		}
		stra.pop_back();
	}
	if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
		str.swap(stra);
	}
	auto it = str.crbegin();
	auto ita = stra.crbegin();
	bool itIsZero = !str.size();
	bool itaIsZero = !stra.size();
	bool strIsNegative = (str.size() ? '-' == str.front() : false);
	bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
	bool tenSub = 1 == strIsNegative + straIsNegative;
	int absStr = abs(atoi(str.c_str()));
	int absStra = abs(atoi(stra.c_str()));
	bool isNegative = '-' == (absStr > absStra ? str.front() : absStr == absStra ? false : stra.front());
	int digitNum = 0;
	while (!itaIsZero || !itIsZero || addNum) {
		if (str.crend() == it || '0' > *it || '9' < *it) {
			itIsZero = true;
		}
		if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
			itaIsZero = true;
		}
		ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
		iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
		digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
		digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
		addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
		digitNum = abs(digitNum % 10);
		if (!itIsZero || !itaIsZero || addNum || digitNum) {
			this->last.insert(this->last.begin(), '0' + digitNum);
		}
	}
	if (this->last.empty()) {
		this->last.push_back('0');
	}
	else if (isNegative) {
		this->last.insert(this->last.begin(), '-');
	}
	while ('-' == this->last[id] && id < this->last.size()) {
		id++;
	}
	while (id < this->last.size() - 1 && '0' == this->last[id]) {
		toDel = 0;
		while (toDel < this->last.size()) {
			if (toDel == id && ++toDel) {
				continue;
			}
			tempstr.push_back(this->last[toDel++]);
		}
		this->last = tempstr;
	}
	return this->last;
}
*///已修正stringSub类的sub方法中stra转负数的操作^
/*
//stringTim.cpp
#include "stringTim.h"
string stringTim::tim(string str, string stra) {
	string timStr = "0";
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = 1 == ('-' == str.front()) + ('-' == stra.front()) && (atoi(str.c_str()) && atoi(stra.c_str()));
	int i = abs(atoi(stra.c_str()));
	for (; i; i--) {
		timStr = add(timStr, str);
	}
	if (isNegative) {
		timStr.insert(0, "-");
		if ('-' == timStr[0] && '-' == timStr[1]) {
			for (int i = 0; i < timStr.size() - 2; i++) {
				timStr[i] = timStr[i + 2];
			}
			timStr.erase(timStr.size() - 2);
		}
	}
	this->last = timStr;
	return timStr;
}
*///stringTim类的tim方法已基本无bug^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
#include "stringTim.h"
#include <set>
using namespace std;

int main() {
    stringTim st;
    cout << st.tim("22", "22");
    return 0;
}
*///测试一下stringTim类的tim方法^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
#include "stringTim.h"
#include <set>
using namespace std;

int main() {
    stringTim st;
    string timStr = "1";
    int i = 0;
    cout << "请输入你要求的2的次方数：";
    cin >> i;
    if (i < 0) {
        cout << "不支持" << endl;
        return 1;
    }
    for (; i; i--) {
        timStr = st.tim(timStr, "2");
    }
    cout << timStr << endl;
    return 0;
}
*///2的几次方计算器^
/*
//stringTim.h
#pragma once
#include "stringPlus.h"
class stringTim : public stringPlus {
public:
	virtual string tim(string str, string stra);
};
*///已将tim方法设为虚方法^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
#include "stringTim.h"
#include <set>
using namespace std;

int main() {
    stringTim st;
    stringPlus sp;
    cout << sp.add(st.tim("29", "6"), st.tim("29", "4")) << endl;
    return 0;
}
*///乘法分配律^
/*
//stringDiv.h
#pragma once
#include "stringSub.h"
class stringDiv : public stringSub {
	string div(string str, string stra);
};
*///已创建stringDiv类^
/*
//stringDiv.cpp
#include "stringDiv.h"
string stringDiv::div(string str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	if (isNegative) {
		divStr.insert(0, "-");
	}
	this->last = divStr;
	return divStr;
}
*///已实现stringDiv类的div方法^
/*
//stringPlus.h
#pragma once
#include <iostream>
using namespace std;
class stringPlus {
protected:
        string last;
public:
        virtual string getLast();
        virtual string add(string str, string stra);
        virtual string addAssign(string& str, string stra);
};
//stringPlus.cpp
#include "stringPlus.h"
#include <cmath>
string stringPlus::getLast() {
        return this->last;
}
string stringPlus::add(string str, string stra) {
        this->last.clear();
        int addNum = 0;
        int ix = 0;
        int iy = 0;
        int id = 0;
        int toDel = 0;
        string tempstr;
        for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
                if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
                        str.erase(index);
                }
                if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
                        stra.erase(index);
                }
        }
        if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
                str.swap(stra);
        }
        bool itIsZero = !str.size();
        bool itaIsZero = !stra.size();
        bool strIsNegative = (str.size() ? '-' == str.front() : false);
        bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
        bool tenSub = 1 == strIsNegative + straIsNegative;
        int absStr = abs(atoi(str.c_str()));
        int absStra = abs(atoi(stra.c_str()));
        bool isNegative = '-' == (absStr > absStra ? str.front() : absStr == absStra ? false : stra.front());
        auto it = str.crbegin();
        auto ita = stra.crbegin();
        int digitNum = 0;
        while (!itaIsZero || !itIsZero || addNum) {
                if (str.crend() == it || '0' > *it || '9' < *it) {
                        itIsZero = true;
                }
                if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
                        itaIsZero = true;
                }
                ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
                iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
                digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
                digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
                addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
                digitNum = abs(digitNum % 10);
                if (!itIsZero || !itaIsZero || addNum || digitNum) {
                        this->last.insert(this->last.begin(), '0' + digitNum);
                }
        }
        if (this->last.empty()) {
                this->last.push_back('0');
        }
        else if (isNegative) {
                this->last.insert(this->last.begin(), '-');
        }
        while ('-' == this->last[id] && id < this->last.size()) {
                id++;
        }
        while (id < this->last.size() - 1 && '0' == this->last[id]) {
                toDel = 0;
                while (toDel < this->last.size()) {
                        if (toDel == id && ++toDel) {
                                continue;
                        }
                        tempstr.push_back(this->last[toDel++]);
                }
                this->last = tempstr;
        }
        return this->last;
}
string stringPlus::addAssign(string& str, string stra) {
        this->last.clear();
        int addNum = 0;
        int ix = 0;
        int iy = 0;
        int id = 0;
        int toDel = 0;
        string tempstr;
        for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
                if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
                        str.erase(index);
                }
                if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
                        stra.erase(index);
                }
        }
        if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
                str.swap(stra);
        }
        bool itIsZero = !str.size();
        bool itaIsZero = !stra.size();
        bool strIsNegative = (str.size() ? '-' == str.front() : false);
        bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
        bool tenSub = 1 == strIsNegative + straIsNegative;
        int absStr = abs(atoi(str.c_str()));
        int absStra = abs(atoi(stra.c_str()));
        bool isNegative = '-' == (absStr > absStra ? str.front() : absStr == absStra ? false : stra.front());
        auto it = str.crbegin();
        auto ita = stra.crbegin();
        int digitNum = 0;
        while (!itaIsZero || !itIsZero || addNum) {
                if (str.crend() == it || '0' > *it || '9' < *it) {
                        itIsZero = true;
                }
                if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
                        itaIsZero = true;
                }
                ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
                iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
                digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
                digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
                addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
                digitNum = abs(digitNum % 10);
                if (!itIsZero || !itaIsZero || addNum || digitNum) {
                        this->last.insert(this->last.begin(), '0' + digitNum);
                }
        }
        if (this->last.empty()) {
                this->last.push_back('0');
        }
        else if (isNegative) {
                this->last.insert(this->last.begin(), '-');
        }
        while ('-' == this->last[id] && id < this->last.size()) {
                id++;
        }
        while (id < this->last.size() - 1 && '0' == this->last[id]) {
                toDel = 0;
                while (toDel < this->last.size()) {
                        if (toDel == id && ++toDel) {
                                continue;
                        }
                        tempstr.push_back(this->last[toDel++]);
                }
                this->last = tempstr;
        }
        return str = this->last;
}
//stringSub.h
#pragma once
#include "stringPlus.h"
#include <iostream>
using namespace std;
class stringSub{
protected:
        string last;
public:
        virtual string getLast();
        virtual string sub(string str, string stra);
        virtual string subAssign(string& str, string stra);
};
//stringSub.cpp
#include "stringSub.h"
string stringSub::getLast() {
        return this->last;
}
string stringSub::sub(string str, string stra) {
        this->last.clear();
        int addNum = 0;
        int ix = 0;
        int iy = 0;
        int id = 0;
        int toDel = 0;
        string tempstr;
        for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
                if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
                        str.erase(index);
                }
                if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
                        stra.erase(index);
                }
        }
        if ('-' != stra.front()) {
                stra.insert(0, "-");
        }
        else {
                for (int i = 0; i < stra.size() - 1; i++) {
                        stra[i] = stra[i + 1];
                }
                stra.pop_back();
        }
        if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
                str.swap(stra);
        }
        auto it = str.crbegin();
        auto ita = stra.crbegin();
        bool itIsZero = !str.size();
        bool itaIsZero = !stra.size();
        bool strIsNegative = (str.size() ? '-' == str.front() : false);
        bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
        bool tenSub = 1 == strIsNegative + straIsNegative;
        int absStr = abs(atoi(str.c_str()));
        int absStra = abs(atoi(stra.c_str()));
        bool isNegative = '-' == (absStr > absStra ? str.front() : absStr == absStra ? false : stra.front());
        int digitNum = 0;
        while (!itaIsZero || !itIsZero || addNum) {
                if (str.crend() == it || '0' > *it || '9' < *it) {
                        itIsZero = true;
                }
                if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
                        itaIsZero = true;
                }
                ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
                iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
                digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
                digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
                addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
                digitNum = abs(digitNum % 10);
                if (!itIsZero || !itaIsZero || addNum || digitNum) {
                        this->last.insert(this->last.begin(), '0' + digitNum);
                }
        }
        if (this->last.empty()) {
                this->last.push_back('0');
        }
        else if (isNegative) {
                this->last.insert(this->last.begin(), '-');
        }
        while ('-' == this->last[id] && id < this->last.size()) {
                id++;
        }
        while (id < this->last.size() - 1 && '0' == this->last[id]) {
                toDel = 0;
                while (toDel < this->last.size()) {
                        if (toDel == id && ++toDel) {
                                continue;
                        }
                        tempstr.push_back(this->last[toDel++]);
                }
                this->last = tempstr;
        }
        return this->last;
}
string stringSub::subAssign(string& str, string stra) {
        this->last.clear();
        int addNum = 0;
        int ix = 0;
        int iy = 0;
        int id = 0;
        int toDel = 0;
        string tempstr;
        for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
                if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
                        str.erase(index);
                }
                if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
                        stra.erase(index);
                }
        }
        if ('-' != stra.front()) {
                stra.insert(0, "-");
        }
        else {
                for (int i = 0; i < stra.size() - 1; i++) {
                        stra[i] = stra[i + 1];
                }
                stra.pop_back();
        }
        if (abs(atoi(stra.c_str())) > abs(atoi(str.c_str()))) {
                str.swap(stra);
        }
        auto it = str.crbegin();
        auto ita = stra.crbegin();
        bool itIsZero = !str.size();
        bool itaIsZero = !stra.size();
        bool strIsNegative = (str.size() ? '-' == str.front() : false);
        bool straIsNegative = (stra.size() ? '-' == stra.front() : false);
        bool tenSub = 1 == strIsNegative + straIsNegative;
        int absStr = abs(atoi(str.c_str()));
        int absStra = abs(atoi(stra.c_str()));
        bool isNegative = '-' == (absStr > absStra ? str.front() : absStr == absStra ? false : stra.front());
        int digitNum = 0;
        while (!itaIsZero || !itIsZero || addNum) {
                if (str.crend() == it || '0' > *it || '9' < *it) {
                        itIsZero = true;
                }
                if (stra.crend() == ita || '0' > *ita || '9' < *ita) {
                        itaIsZero = true;
                }
                ix = (1 - 2 * strIsNegative) * (itIsZero ? 0 : *it++ - '0');
                iy = (1 - 2 * straIsNegative) * (itaIsZero ? 0 : *ita++ - '0');
                digitNum = (tenSub && abs(ix) < abs(iy)) ? 10 + abs(ix) - abs(iy) : ix + iy;
                digitNum += !(0 > addNum && 2 == itIsZero + itaIsZero) * (1 - 2 * (digitNum < 0)) * addNum;
                addNum = tenSub && abs(ix) < abs(iy) ? -1 : digitNum / 10;
                digitNum = abs(digitNum % 10);
                if (!itIsZero || !itaIsZero || addNum || digitNum) {
                        this->last.insert(this->last.begin(), '0' + digitNum);
                }
        }
        if (this->last.empty()) {
                this->last.push_back('0');
        }
        else if (isNegative) {
                this->last.insert(this->last.begin(), '-');
        }
        while ('-' == this->last[id] && id < this->last.size()) {
                id++;
        }
        while (id < this->last.size() - 1 && '0' == this->last[id]) {
                toDel = 0;
                while (toDel < this->last.size()) {
                        if (toDel == id && ++toDel) {
                                continue;
                        }
                        tempstr.push_back(this->last[toDel++]);
                }
                this->last = tempstr;
        }
        return str = this->last;
}
//stringTim.h
#pragma once
#include "stringPlus.h"
class stringTim : public stringPlus {
public:
        virtual string tim(string str, string stra);
        virtual string timAssign(string& str, string stra);
};
//stringTim.cpp
#include "stringTim.h"
string stringTim::tim(string str, string stra) {
        string timStr = "0";
        for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
                if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
                        str.erase(index);
                }
                if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
                        stra.erase(index);
                }
        }
        bool isNegative = 1 == ('-' == str.front()) + ('-' == stra.front()) && (atoi(str.c_str()) && atoi(stra.c_str()));
        int i = abs(atoi(stra.c_str()));
        for (; i; i--) {
                timStr = add(timStr, str);
        }
        if (isNegative) {
                timStr.insert(0, "-");
                if ('-' == timStr[0] && '-' == timStr[1]) {
                        for (int i = 0; i < timStr.size() - 2; i++) {
                                timStr[i] = timStr[i + 2];
                        }
                        timStr.erase(timStr.size() - 2);
                }
        }
        this->last = timStr;
        return timStr;
}
string stringTim::timAssign(string& str, string stra) {
        string timStr = "0";
        for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
                if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
                        str.erase(index);
                }
                if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
                        stra.erase(index);
                }
        }
        bool isNegative = 1 == ('-' == str.front()) + ('-' == stra.front()) && (atoi(str.c_str()) && atoi(stra.c_str()));
        int i = abs(atoi(stra.c_str()));
        for (; i; i--) {
                timStr = add(timStr, str);
        }
        if (isNegative) {
                timStr.insert(0, "-");
                if ('-' == timStr[0] && '-' == timStr[1]) {
                        for (int i = 0; i < timStr.size() - 2; i++) {
                                timStr[i] = timStr[i + 2];
                        }
                        timStr.erase(timStr.size() - 2);
                }
        }
        str = this->last = timStr;
        return timStr;
}
//stringDiv.h
#pragma once
#include "stringSub.h"
class stringDiv : public stringSub {
public:
        virtual string div(string str, string stra);
        virtual string divAssign(string& str, string stra);
};
//stringDiv.cpp
#include "stringDiv.h"
string stringDiv::div(string str, string stra) {
        for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
                if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
                        str.erase(index);
                }
                if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
                        stra.erase(index);
                }
        }
        bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
        '-' == str.front() ? str = sub("0", str) : "";
        '-' == stra.front() ? stra = sub("0", stra) : "";
        string divStr = "0";
        while (atoi(sub(str, stra).c_str()) >= 0) {
                str = sub(str, stra);
                divStr = sub(divStr, "-1");
        }
        if (isNegative) {
                divStr.insert(0, "-");
        }
        this->last = divStr;
        return divStr;
}
string stringDiv::divAssign(string& str, string stra) {
        for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
                if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
                        str.erase(index);
                }
                if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
                        stra.erase(index);
                }
        }
        bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
        '-' == str.front() ? str = sub("0", str) : "";
        '-' == stra.front() ? stra = sub("0", stra) : "";
        string divStr = "0";
        while (atoi(sub(str, stra).c_str()) >= 0) {
                str = sub(str, stra);
                divStr = sub(divStr, "-1");
        }
        if (isNegative) {
                divStr.insert(0, "-");
        }
        str = this->last = divStr;
        return divStr;
}
*///已往stringPlus类，stringSub类，stringTim类和stringDiv类，添加所对应的assign方法^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
#include "stringTim.h"
#include "stringDiv.h"
#include <set>
using namespace std;

int main() {
    stringPlus sp;
    stringSub ss;
    stringTim st;
    stringDiv sd;
    string str = "0";
    sp.addAssign(str, "5");
    cout << str << " ";
    ss.subAssign(str, "3");
    cout << str << " ";
    st.timAssign(str, "2");
    cout << str << " ";
    sd.divAssign(str, "4");
    cout << str << endl;
    return 0;
}
*///已测试stringPlus类，stringSub类，stringTim类和stringDiv类所对应的assign方法^
/*
//stringDiv.cpp
#include "stringDiv.h"
string stringDiv::div(string str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	if (isNegative) {
		divStr.insert(0, "-");
	}
	this->last = divStr;
	return divStr;
}
string stringDiv::divAssign(string& str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	if (isNegative) {
		divStr.insert(0, "-");
	}
	str = this->last = divStr;
	return divStr;
}
*///已修正stringDiv的div和divAssign方法的可以除以0的bug^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
#include "stringTim.h"
#include "stringDiv.h"
#include <set>
using namespace std;

int main() {
    stringDiv ss;
    cout << ss.div("33", "-0") << endl;
    cout << "OK" << endl;
    return 0;
}
*///已测试stringDiv类的div方法是否可以除以0^
/*
//stringDiv.cpp
#include "stringDiv.h"
string stringDiv::div(string str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	if (isNegative) {
		divStr.insert(0, "-");
	}
	this->last = divStr;
	return divStr;
}
string stringDiv::divAssign(string& str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	if (isNegative) {
		divStr.insert(0, "-");
	}
	str = this->last = divStr;
	return divStr;
}
*///已为stringDiv类的整数除法计算方法添加错误提示^
/*
//stringMod.h
#pragma once
#include "stringSub.h"
class stringMod : public stringSub {
public:
	string mod(string str, string stra);
	string modAssign(string& str, string stra);
};
//stringMod.cpp
#include "stringMod.h"
string stringMod::mod(string str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = '-' == str.front();
	str = (('-' == str.front()) ? sub("0", str) : str);
	stra = (('-' == stra.front()) ? sub("0", stra) : stra);
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	while (atoi(sub(str, stra).c_str()) >= 0) {
		subAssign(str, stra);
	}
	if (isNegative) {
		str.insert(0, "-");
	}
	this->last = str;
	return str;
}
string stringMod::modAssign(string& str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = '-' == str.front();
	str = (('-' == str.front()) ? sub("0", str) : str);
	stra = (('-' == stra.front()) ? sub("0", stra) : stra);
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	while (atoi(sub(str, stra).c_str()) >= 0) {
		subAssign(str, stra);
	}
	if (isNegative) {
		str.insert(0, "-");
	}
	this->last = str;
	return str;
}
*///已创建stringMod类，并实现该类的相关方法^
/*
//stringMod.h
#pragma once
#include "stringTim.h"
#include "stringDiv.h"
class stringMod : public stringTim, public stringDiv {
	string last;
public:
	string getLast();
	string mod(string str, string stra);
	string modAssign(string& str, string stra);
};


//stringMod.cpp
#include "stringMod.h"
string stringMod::mod(string str, string stra) {
	this->last = sub(str, tim(stra, div(str, stra)));
	return str;
}
string stringMod::modAssign(string& str, string stra) {
	this->last = subAssign(str, tim(stra, div(str, stra)));
	return str;
}
string stringMod::getLast() {
	return this->last;
}
*///已重新实现stringMod类的mod计算方法^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
#include "stringTim.h"
#include "stringDiv.h"
#include "stringMod.h"
#include <set>
using namespace std;

int main() {
    stringMod sm;
    cout << -1 % -3 << endl;
    cout << sm.mod("-1", "-3") << endl;
    cout << sm.getLast();
    return 0;
}
*///已再次测试stringMod类的mod计算方法^
/*
//stringTim.h
#pragma once
#include "stringPlus.h"
class stringTim : protected stringPlus {
protected:
	string last;
public:
	virtual string getLast();
	virtual string tim(string str, string stra);
	virtual string timAssign(string& str, string stra);
};
//stringTim.cpp
#include "stringTim.h"
string stringTim::tim(string str, string stra) {
	string timStr = "0";
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = 1 == ('-' == str.front()) + ('-' == stra.front()) && (atoi(str.c_str()) && atoi(stra.c_str()));
	int i = abs(atoi(stra.c_str()));
	for (; i; i--) {
		timStr = add(timStr, str);
	}
	if (isNegative) {
		timStr.insert(0, "-");
		if ('-' == timStr[0] && '-' == timStr[1]) {
			for (int i = 0; i < timStr.size() - 2; i++) {
				timStr[i] = timStr[i + 2];
			}
			timStr.erase(timStr.size() - 2);
		}
	}
	this->last = timStr;
	return timStr;
}
string stringTim::timAssign(string& str, string stra) {
	string timStr = "0";
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = 1 == ('-' == str.front()) + ('-' == stra.front()) && (atoi(str.c_str()) && atoi(stra.c_str()));
	int i = abs(atoi(stra.c_str()));
	for (; i; i--) {
		timStr = add(timStr, str);
	}
	if (isNegative) {
		timStr.insert(0, "-");
		if ('-' == timStr[0] && '-' == timStr[1]) {
			for (int i = 0; i < timStr.size() - 2; i++) {
				timStr[i] = timStr[i + 2];
			}
			timStr.erase(timStr.size() - 2);
		}
	}
	str = this->last = timStr;
	return timStr;
}
string stringTim::getLast() {
	return this->last;
}
//stringDiv.h
#pragma once
#include "stringSub.h"
class stringDiv : protected stringSub {
protected:
	string last;
public:
	virtual string getLast();
	virtual string div(string str, string stra);
	virtual string divAssign(string& str, string stra);
};


//stringDiv.cpp
#include "stringDiv.h"
string stringDiv::div(string str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	if (isNegative) {
		divStr.insert(0, "-");
	}
	this->last = divStr;
	return divStr;
}
string stringDiv::divAssign(string& str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	if (isNegative) {
		divStr.insert(0, "-");
	}
	str = this->last = divStr;
	return divStr;
}
string stringDiv::getLast() {
	return this->last;
}
*///已修改stringTim类和stringDiv类^
/*
//stringDiv.h
#pragma once
#include "stringSub.h"
class stringDiv : protected stringSub {
protected:
	string last;
public:
	virtual string getLast();
	virtual string div(string str, string stra);
	virtual string divAssign(string& str, string stra);
	virtual string div(string str, string stra, bool isUp);
	virtual string divAssign(string& str, string stra, bool isUp);
};

//stringDiv.cpp
#include "stringDiv.h"
string stringDiv::div(string str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	if (isNegative) {
		divStr.insert(0, "-");
	}
	this->last = divStr;
	return divStr;
}
string stringDiv::divAssign(string& str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	if (isNegative) {
		divStr.insert(0, "-");
	}
	str = this->last = divStr;
	return divStr;
}
string stringDiv::getLast() {
	return this->last;
}
string stringDiv::div(string str, string stra, bool isUp){
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	1 == isNegative + isUp ? subAssign(divStr, "-1") : "";
	if (isNegative) {
		divStr.insert(0, "-");
	}
	this->last = divStr;
	return divStr;
}
string stringDiv::divAssign(string& str, string stra, bool isUp) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	1 == isNegative + isUp ? subAssign(divStr, "-1") : "";
	if (isNegative) {
		divStr.insert(0, "-");
	}
	str = this->last = divStr;
	return divStr;
}
*///已添加stringDiv类的div重载方法和divAssign重载方法^
/*
//stringMod.cpp
#include "stringMod.h"
string stringMod::mod(string str, string stra) {
	this->last = sub(str, tim(stra, div(str, stra, false)));
	return this->last;
}
string stringMod::modAssign(string& str, string stra) {
	this->last = subAssign(str, tim(stra, div(str, stra, false)));
	return this->last;
}
string stringMod::getLast() {
	return this->last;
}
*///已更改stringMod类中的mod计算方法的实现^
/*
//stringTim.cpp
#include "stringTim.h"
string stringTim::tim(string str, string stra) {
	string timStr = "0";
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = 1 == ('-' == str.front()) + ('-' == stra.front()) && (atoi(str.c_str()) && atoi(stra.c_str()));
	int i = abs(atoi(stra.c_str()));
	'-' == str.front() ? str = sub("0", str) : "";
	for (; i; i--) {
		timStr = add(timStr, str);
	}
	if (isNegative) {
		timStr.insert(0, "-");
	}
	this->last = timStr;
	return timStr;
}
string stringTim::timAssign(string& str, string stra) {
	string timStr = "0";
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	bool isNegative = 1 == ('-' == str.front()) + ('-' == stra.front()) && (atoi(str.c_str()) && atoi(stra.c_str()));
	int i = abs(atoi(stra.c_str()));
	'-' == str.front() ? str = sub("0", str) : "";
	for (; i; i--) {
		timStr = add(timStr, str);
	}
	if (isNegative) {
		timStr.insert(0, "-");
	}
	str = this->last = timStr;
	return timStr;
}
string stringTim::getLast() {
	return this->last;
}
*///已修改stringTim类的tim计算方法^
/*
//stringTim.cpp
#include "stringTim.h"
string stringTim::tim(string str, string stra) {
	string timStr = "0";
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (!str.size()) {
		str = "0";
	}
	if (!stra.size()) {
		stra = "0";
	}
	bool isNegative = 1 == ('-' == str.front()) + ('-' == stra.front()) && (atoi(str.c_str()) && atoi(stra.c_str()));
	int i = abs(atoi(stra.c_str()));
	'-' == str.front() ? str = sub("0", str) : "";
	for (; i; i--) {
		timStr = add(timStr, str);
	}
	if (isNegative) {
		timStr.insert(0, "-");
	}
	this->last = timStr;
	return timStr;
}
string stringTim::timAssign(string& str, string stra) {
	string timStr = "0";
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (!str.size()) {
		str = "0";
	}
	if (!stra.size()) {
		stra = "0";
	}
	bool isNegative = 1 == ('-' == str.front()) + ('-' == stra.front()) && (atoi(str.c_str()) && atoi(stra.c_str()));
	int i = abs(atoi(stra.c_str()));
	'-' == str.front() ? str = sub("0", str) : "";
	for (; i; i--) {
		timStr = add(timStr, str);
	}
	if (isNegative) {
		timStr.insert(0, "-");
	}
	str = this->last = timStr;
	return timStr;
}
string stringTim::getLast() {
	return this->last;
}
//stringDiv.cpp
#include "stringDiv.h"
string stringDiv::div(string str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (!str.size()) {
		str = "0";
	}
	if (!stra.size()) {
		stra = "0";
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	if (isNegative) {
		divStr.insert(0, "-");
	}
	this->last = divStr;
	return divStr;
}
string stringDiv::divAssign(string& str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (!str.size()) {
		str = "0";
	}
	if (!stra.size()) {
		stra = "0";
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	if (isNegative) {
		divStr.insert(0, "-");
	}
	str = this->last = divStr;
	return divStr;
}
string stringDiv::getLast() {
	return this->last;
}
string stringDiv::div(string str, string stra, bool isUp){
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (!str.size()) {
		str = "0";
	}
	if (!stra.size()) {
		stra = "0";
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	1 == isNegative + isUp && "0" != str ? subAssign(divStr, "-1") : "";
	if (isNegative && "0" != divStr) {
		divStr.insert(0, "-");
	}
	this->last = divStr;
	return divStr;
}
string stringDiv::divAssign(string& str, string stra, bool isUp) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (!str.size()) {
		str = "0";
	}
	if (!stra.size()) {
		stra = "0";
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	1 == isNegative + isUp && "0" != str ? subAssign(divStr, "-1") : "";
	if (isNegative && "0" != divStr) {
		divStr.insert(0, "-");
	}
	str = this->last = divStr;
	return divStr;
}
*///已为stringTim类和stringDiv类的计算方法中添加字符串为空的检测^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
#include "stringTim.h"
#include "stringDiv.h"
#include "stringMod.h"
#include <set>
using namespace std;

int main() {
    stringTim st;
    stringDiv sd;
    cout << st.tim("", "") << endl;
    cout << sd.div("", "") << endl;
    return 0;
}
*///已测试stringTim类和stringDiv类的计算方法中添加字符串为空的检测^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
#include "stringTim.h"
#include "stringDiv.h"
#include "stringMod.h"
#include <set>
using namespace std;

int main() {
    stringPlus sp;
    stringSub ss;
    stringTim st;
    stringDiv sd;
    cout << st.tim(sp.add(sd.div("3", "1"), ss.sub("5", "2")), "6") << endl;
    return 0;
}
*///四则计算^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
#include "stringTim.h"
#include "stringDiv.h"
#include "stringMod.h"
#include <set>
using namespace std;

int main() {
    stringMod sm;
    cout << sm.mod(sm.mod("7", "2"), "2");
    return 0;
}
*///双重无用mod^
/*
//stringPow.h
#pragma once
#include "stringDiv.h"
class stringPow : protected stringDiv {
	string last;
public:
	string getLast();
};
//stringPow.cpp
#include "stringPow.h"
string stringPow::getLast() {
	return this->last;
}
*///已创建stringPow类^
/*
//stringPow.h
#pragma once
#include "stringDiv.h"
class stringPow : protected stringDiv {
	string last;
public:
	string getLast();
	string pow(string str, string stra);
	string powAssign(string& str, string stra);
};
//stringPow.cpp
#include "stringPow.h"
string stringPow::getLast() {
	return this->last;
}
string stringPow::pow(string str, string stra) {
	return this->last;
}
string stringPow::powAssign(string& str, string stra) {
	return this->last;
}
*///已新建一个pow方法和一个powAssign方法^
/*
//stringPow.cpp
#include "stringPow.h"
string stringPow::getLast() {
	return this->last;
}
string stringPow::pow(string str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (!str.size()) {
		str = "0";
	}
	if (!stra.size()) {
		stra = "0";
	}
	string powStr = "1";
	if ('-' == stra.front()) {
		return this->last = "0";
	}
	else {
		int i = atoi(stra.c_str());
		for (; i; i--) {
			timAssign(powStr, str);
		}
	}
	return this->last = powStr;
}
string stringPow::powAssign(string& str, string stra) {
	return this->last;
}
*///已实现pow方法^
/*
//stringPow.cpp
#include "stringPow.h"
string stringPow::getLast() {
	return this->last;
}
string stringPow::pow(string str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (!str.size()) {
		str = "0";
	}
	if (!stra.size()) {
		stra = "0";
	}
	string powStr = "1";
	if ('-' == stra.front()) {
		return this->last = "0";
	}
	else {
		int i = atoi(stra.c_str());
		for (; i; i--) {
			timAssign(powStr, str);
		}
	}
	return this->last = powStr;
}
string stringPow::powAssign(string& str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (!str.size()) {
		str = "0";
	}
	if (!stra.size()) {
		stra = "0";
	}
	string powStr = "1";
	if ('-' == stra.front()) {
		return this->last = "0";
	}
	else {
		int i = atoi(stra.c_str());
		for (; i; i--) {
			timAssign(powStr, str);
		}
	}
	return this->last = str = powStr;
}
*///已实现powAssign方法^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
#include "stringTim.h"
#include "stringDiv.h"
#include "stringMod.h"
#include "stringPow.h"
#include <set>
using namespace std;

int main() {
    stringPow sa;
    cout << sa.pow("2", "3") << endl;
    return 0;
}
*///测试stringPow类的pow方法^
/*
//stringDiv.cpp
#include "stringDiv.h"
string stringDiv::div(string str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (!str.size()) {
		str = "0";
	}
	if (!stra.size()) {
		stra = "0";
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	if (isNegative && "0" != divStr) {
		divStr.insert(0, "-");
	}
	this->last = divStr;
	return divStr;
}
string stringDiv::divAssign(string& str, string stra) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (!str.size()) {
		str = "0";
	}
	if (!stra.size()) {
		stra = "0";
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	if (isNegative && "0" != divStr) {
		divStr.insert(0, "-");
	}
	str = this->last = divStr;
	return divStr;
}
string stringDiv::getLast() {
	return this->last;
}
string stringDiv::div(string str, string stra, bool isUp){
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (!str.size()) {
		str = "0";
	}
	if (!stra.size()) {
		stra = "0";
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	1 == isNegative + isUp && "0" != str ? subAssign(divStr, "-1") : "";
	if (isNegative && "0" != divStr) {
		divStr.insert(0, "-");
	}
	this->last = divStr;
	return divStr;
}
string stringDiv::divAssign(string& str, string stra, bool isUp) {
	for (int index = 0; index < (str.size() > stra.size() ? str.size() : stra.size()); index++) {
		if (index < str.size() && '-' != str[index] && ('0' > str[index] || '9' < str[index])) {
			str.erase(index);
		}
		if (index < stra.size() && '-' != stra[index] && ('0' > stra[index] || '9' < stra[index])) {
			stra.erase(index);
		}
	}
	if (!str.size()) {
		str = "0";
	}
	if (!stra.size()) {
		stra = "0";
	}
	bool isNegative = (1 == ('-' == str.front()) + ('-' == stra.front()));
	'-' == str.front() ? str = sub("0", str) : "";
	'-' == stra.front() ? stra = sub("0", stra) : "";
	if ("0" == stra) {
		cout << "错误：不能除以0" << endl;
		exit(1);
	}
	string divStr = "0";
	while (atoi(sub(str, stra).c_str()) >= 0) {
		str = sub(str, stra);
		divStr = sub(divStr, "-1");
	}
	1 == isNegative + isUp && "0" != str ? subAssign(divStr, "-1") : "";
	if (isNegative && "0" != divStr) {
		divStr.insert(0, "-");
	}
	str = this->last = divStr;
	return divStr;
}
*///已修正stringDiv类的div及一系列计算方法^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
#include "stringTim.h"
#include "stringDiv.h"
#include "stringMod.h"
#include "stringPow.h"
#include <set>
using namespace std;

int main() {
    stringPow sa;
    cout << sa.pow("-2", "-3") << endl;
    return 0;
}
*///已测试stringPow类pow方法的次方计算^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
#include "stringTim.h"
#include "stringDiv.h"
#include "stringMod.h"
#include "stringPow.h"
#include <set>
using namespace std;

int main() {
    stringPow sa;
    cout << sa.pow("1", "-1000") << endl;
    cout << sa.pow("-1", "-1000") << endl;
    return 0;
}
*///已测试stringPow类pow方法的基数为1或-1的计算^
/*
//meiri.cpp
#include <iostream>
#include "stringPlus.h"
#include "stringSub.h"
#include "stringTim.h"
#include "stringDiv.h"
#include "stringMod.h"
#include "stringPow.h"
#include <set>
using namespace std;

int main() {
    stringPlus sa;
    stringPow sp;
    cout << "3^2 + 4^2 = " << sa.add(sp.pow("3", "2"), sp.pow("4", "2")) << endl;
    return 0;
}
*///勾股定理^
